// РАЗЛИЧНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ
// КОТОРЫЕ МОГУТ ИСПОЛЬЗОВАТЬСЯ НЕЗАВИСИМО ОТ КОНФИГУРАЦИИ

// Функция содержит описание изменений модуля
Функция ОписаниеИзмененийМодуля() Экспорт
	
Возврат 

"
|20190709 Заяш
| Добавлена процедура
| СКД_СкомпоноватьРезультатОтчета
| из публикации https://infostart.ru/public/1082944

|20190704 Заяш 
| Добавлена процедура
| РегистрБухгалтерииЗапись_КонтрольЗаполнения

|20190403 Заяш
| Перенесены все наработки из проекта НА
| Добавлены функции пакетной обработки документов.

|20190115 Заяш
| Возрващена функция Строка_ПреобразоватьВМассив
| потому  что стандартная функция СтрРазделить делит только по одному символу
| а эта функция позволяет разделить по последовательности символов

|20190102 Заяш
| Добавлена процедура Пауза

|20181224 Заяш
|Функция Проверка_Тип теперь умеет работать с типом Неопределено

|20181219 Заяш
|Процедура Документы_ПровестиУведомитьПользователя добавлена

|20181219 Заяш
|Функция Строка_ПреобразоватьВМассив перенесена в устаревшие
|Все зависимости функции в модуле убраны

|20181218 Заяш
| Добавлена функция Кэш_Получить

|20181027 Заяш
| Добавлена функция СписокЗначений_ВыделитьВхожденияВПредставлении

|20180920 Заяш
| Добавлена функция ТекущийПользователь_РольДоступна

|20180117 Заяш
| Добавлена функция СообщитьИЗаписатьВЖурнал

|20171226 Заяш
| Добавлена функция Справочник_ПолучитьСсылкуПоНаименованиюЭлемента
| Добавлена функция ТабличнаяЧастьСтрока_ПолучитьИмяТабличнойЧасти

|20171024 Заяш
| Функция Строка_ПодставитьПараметры отправлена в устаревшие
| Заменена на функцию глобального контекста СтрШаблон

|20171020 Заяш
| Добавлены функции
| ТабличноеПоле_Колонки_Настройки_Загрузить
| ТабличноеПоле_Колонки_Настройки_Сохранить

|20171012 Заяш
| Добавлена процедура СоответствиеВТаблицуЗначений

|20170913 Заяш
| Добавлены процедуры
| Ссылка_ЕстьТабличнаяЧасть
| Ссылка_ЕстьРеквизитТабличнойЧасти

|20170803 Заяш
| Добавлена процедура
| Ссылка_Реквизит_ПолучитьИзБД

|20170801 Заяш
|Добавлены процедуры
|Объект_ЗаполнитьРеквизитЕслиПустой
|Объект_ОбновитьРеквизит

| 20170731 Заяш
| Изменена функция Тип_ЭтоСсылка
| Теперь она может принимать в качестве входного параметра объект метаданных
| Исправлено описание функции
|
| Изменена функция Справочник_ПолучитьСсылкуПоКодуЭлемента
| Добавлена возможность задать название создаваемого элемента справочника
| Исправлено описание функции

| 20170612 Заяш 
| Добавлена фунция Строка_СоеденитьСтроки

| 20170323 Заяш
| Добавлена функция ОтчетОбъект_ПолучитьРезультат
| Упорядочены директивы компиляции и описания функций, чтобы корректно работала контекстная подсказка
| Добавлены функции для работы с UnixTimeStamp
| Процедура НеРеализовано

| 20161121 Заяш
| Откорректированы директивы препроцессора 'НаСервере'

| 20161031 Заяш
| Добавлена фунция ЕстьПравоАдминистрирования
| 
| 20160616 Заяш
| Добавлена функция Ссылка_ЕстьРеквизит

| 20160208 Заяш
| Доработана функция СКД_Отбор_Установить
| Добавлена возможность как включать отбор, так и отключать его

| 20160205 Заяш
| Переписана функция Документ_ЕстьРеквизит
| Теперь она осуществляет поиск и в стандартных реквизитах

| 20151229 Заяш
| Доработан механизм ввода по подстроке
| Добавлена процедура для автоподбора текста

| 20151228 Заяш
| Добавлена функция Документ_ПолучитьРеквизитИзБД

| 20151211 Заяш
| Добавлена функция Строка_УдалитьНедопустимыеСимволыXML

| 20151203 Заяш
| Добавлена функция Строка_ЭтоАдресЭлектроннойПочты

| 20151126 Заяш
| Добавлена процедура ГлавныйИнтерфейс_ДобавитьИнтерфейс

| 20151120 Заяш
| Добавлен расширенный механизм ввода по подстроке для обычного интерфейса
| Добавлена функция Форма_ПолучитьИмяОсновногоРеквизита

| 20151112 Заяш
| Добавлена функция Ссылка_ДатаСоздания_Получить

| 20150916 Заяш
| В модуле настроены некоторые области, приведен в порядок текст

| 20150916 Заяш
| Добавлены фунции для преобразования дерева значений в таблицу значений и обратно
| ДеревоЗначений_ВТаблицуЗначений_Рекурсия
| ТаблицаЗначений_ВДеревоЗначений_Рекурсия

| 20140807 Заяш 
| Добавлена процедура УстановитьПустоеЗначение

| 20140625 Заяш
| Добавлены процедуры для проверки параметров, передаваемых в процедуры и функции. Область <<Проверки>>

| 20140411 Заяш
| Добавлена функция ЖурналРегистрации_ПолучитьПоследниеОшибки()

| 20140306 Заяш
| Добавлена функция ДвоичныеДанные_ВМассив()
| и сопутствующие ей функции
| Исправлены директивы препроцессора, чтобы модуль правильно работал в Веб-Клиенте

| 20140304 Заяш
| Добавлена функция Синоним()

| 20140212 Заяш
| Добавлена функция Итоги_Пересчитать()

| 20140128 Заяш
| Добавлена функция ПривестиКТипу

| 20140127 Заяш
| Добавлена процедура Сообщ
| Исправлены директивы препроцессора для совместимости модуля с тонким клиентом

| 20140126 Заяш
| Добавлена процедура ТабличныйДокумент_Колонки_УстановитьШиринуАвтоматически

| 20140122 Заяш
| Поиск ошибок в коде с помощью CodeInspector http://infostart.ru/public/249372/
| Добавлена функция Метаданные_Предопределенные_ЗагрузитьИзТаблицыЗначений

| 20140121 Заяш
| Упорядочены функции
| Добавлена функция Менеджер_Получить
| Добавлена функция КорневойТипКонфигурации_Проверить
| Добавлена функция Тип_ПолучитьПоМетаданным
| Добавлена функция Метаданные_Предопределенные_ВыгрузитьВТаблицуЗначений

| 20140120 Заяш
| Исправлена функция ТабличныйДокумент_ВТаблицуЗначений — добавлена директива Экспорт
| Процедуры и функции работы с табличным документом вынесены в отдельный раздел

| 20140116 Заяш
| Добавлена фунцкция Итоги_УстановитьИспользование

| 20140110 Заяш
| Добавлена фунцкция ЭлементФормы_УстановитьПоложение
| Изменены директивы препроцессора для процедур, управляющих формой
| Изменено положение групп процедур в модуле

| 20131216 Заяш
| Добавлена процедура ВыполнитьУдалениеПомеченныхОбъектов();
| Процедура предназначена для удаления помеченных объектов в фоновом режиме

| 20130929 Заяш
| Добавлена функция ТекстМикрограф

| 20130918 Заяш
| Добавлена функция Объект_ПолучитьСвойства
| Добавлена функция Объект_ПолучитьСтруктуру
| Изменена процедура Объект_СкопироватьРеквизитыВСтруктуру, теперь она является оберткой 
| для функции Объект_ПолучитьСтруктуру;

| 20130722 Заяш 
| Добавлена функция Строка_ВMIME 

| 20130331 Заяш
| Добавлена функция Тип_ПолучитьСтроковоеПредставление
| Исправлены директивы препроцессора и директивы компиляции для правильной работы модуля в тонком клиенте.
| Добавлена функция МенеджерОбъектаПоСсылке из типовой конфигурации

| 20121010 Заяш
| Добавлена функция ТабличныйДокумент_ВТаблицуЗначений
| Функция создает таблицу значений по переданному в нее табличному документу.
| В первой строке содержатся наименования колонок.

| 20120917 Заяш
| Добавлена функция ТаблицаЗначений_ВТабличныйДокумент
| Функция получает на вход таблицу значений, и возвращает табличный документ

| 20120905 Заяш
| Добавлена процедура СКД_Отбор_Установить
| Используется для быстрой програмной установки отбора в динамических списках и СКД.

| 20120723 Заяш
| Добавлена функция Документ_ПолучитьДатуИзБД.
| Функция используется для получения даты документа, записанной в БД. 
| Используется, например, для сравнения дат при перезаписи документа.

| 20120613 Заяш
| Убраны инструкции препроцессора у процедуры ИР_ВыполнитьАлгоритм
| Ранее у процедура компилировалась только на сервере.
| Такой подход несовместим с консолью запросов из подсистемы ИнструментрыРазработчика

| 20120605 Заяш
| Дополнено описание функции Строка_СоединитьСтрокиЧерезРазделитель()

| 20120525 Заяш
| Убраны ссылки на сам модуль в функциях. Те. удален префикс Общ. 
| Так сделано, чтобы при копировании функций в другие модули или обработки не оставалось
| зависимости от данного модуля. Ошибка возникла в обработке конвертации xls2mxl, где
| осталась ссылка на функцию СообщитьОбОшибке. Если бы не было префикса Общ., то
| синтаксический контроль предупредил бы об ошибке на этапе разработки.

| 20120521 Заяш
| Добавлена процедура Объект_Существует для поиска битых ссылок.
| Добавлена процедура Объект_ПолучитьПоСсылке. Если объект существует, будет возвращен он. 
| Если не сущестует, будет создан и возвращен.

| 20120510 Заяш
| Добавлена процедура ОчиститьКэш, для очистки кэша пользователем.

| 20120508 Заяш
| Добавлена процедура УстановитьСостояние, для корректной обработки состояния как на клиенте, так и на сервере.
| Добавлен комментарий к процедуре Предупредить.
| Добавлена процедура ОповеститьОПрогрессе, для корректного и единобразного оповещения о прогрессе как на клиенте, так и на сервере;

| 20120419 Заящ
| Исправлена ошибка в функции Строка_ПреобразоватьВМассив, когда терялся пустой элемент массива,
| если разделителем являлся незначащий символ: пробел или табуляция;
      
| 20120416 Заяш
| Добавлена процедура Документ_ПереключитьРеквизит
| Изменен споб описания изменений модуля (помещены в процедуру)

| 20120412 Заяш
| Добавлена функция Массив_ПреобразоватьВСтроку
| Исравлено описание функции Строка_ПреобразоватьВМассив

| 20111020
| Добавлена функция  ТабличныйДокумент_ПолучитьТекст(ТабДокумент)

| 20111019 
| Добавлена функция для транслитерации русских строк Строка_Транслит(стрРусскоеСлово)

| 20111013
| Добавлена Функция ПараметрСеанса_ПолучитьПоИмени(ИмяПараметраСеанса)

| 20111005
| Добавлена функция Строка_СократитьДвойныеСимволы()

| 20110723
| Добавлена функция Строка_ПодставитьПараметры из БСП. Переименована
| Добавлена функция ТекстНеОпределено
| Исправлены настройки доступности процедур на клиенте/сервере

| 20110720
| 1.Добавлена процедура для управления связанными интервалами диаграммы ганта
| Процедура автоматически исправляет пересечения интервалов.
| 2. Добавлены процедуры для подмены рабочего стола в управляемом интерфейсе.

| 20110715 
| Добавлена процедура ИР_ВыполнитьАлгоритм для использования с регламентными заданиями
| Процедура выполняет алгоритм из справочника Алгоритмы подсистемы инструменты разработчика"

КонецФункции

#Область Разное

// По мотива кода: Гобсек http://help1c.com/faq/view/1518.html
Функция BASE64_Строка_ВМассив(Знач Строка64) Экспорт 
	
	Утверждение_ТипСоответствует(Строка64, Тип("Строка"));
	
	// Подготовить строку
	Строка64 = СтрЗаменить(Строка64, Символ(10), "");
	Строка64 = СтрЗаменить(Строка64, Символ(13), "");
	
	// Проверить длину строки
	Если СтрДлина(Строка64) % 4 <> 0 Тогда
		ВызватьИсключение "Длина строки на входе не кратна 4"; 
	КонецЕсли;
	
	// Создать соответствие символов BASE 64
	// см. http://ru.wikipedia.org/wiki/Base64
	СоответствиеСимволов = Новый Соответствие;
	сч = 0;
	Для чКод = КодСимвола("A") По КодСимвола("Z") Цикл 
		СоответствиеСимволов.Вставить(Символ(чКод), сч);
		сч = сч+1;
	КонецЦикла;
	Для чКод = КодСимвола("a") По КодСимвола("z") Цикл  
		СоответствиеСимволов.Вставить(Символ(чКод), сч);
		сч = сч+1;
	КонецЦикла;
	Для чКод = КодСимвола("0") По КодСимвола("9") Цикл 
		СоответствиеСимволов.Вставить(Символ(чКод), сч);
		сч = сч+1;
	КонецЦикла;
	СоответствиеСимволов.Вставить("+",62);
	СоответствиеСимволов.Вставить("/",63);
	// Знак "=" это спецсимвол в BASE64. Его значение равно 0
	СоответствиеСимволов.Вставить("=",0);
	//
	чКод = Неопределено;
	сч = Неопределено;
	
	КоличествоБайт = 3;
	Делитель = Pow(256,КоличествоБайт-1);
	
	// Разложить строку на отдельные символы
	МассивИзСтроки64 = Новый Массив;
	Для сч = 1 По СтрДлина(Строка64) Цикл
		МассивИзСтроки64.Добавить(Сред(Строка64,сч,1));
	КонецЦикла;
	сч = Неопределено;
	
	МассивБайтНаВозврат = Новый Массив;
	НакопленноеЗначение = 0;
	Сч = 0;
	Для Каждого СимволСтроки64 Из МассивИзСтроки64 Цикл
		ЗначениеСимвола = СоответствиеСимволов[СимволСтроки64];
		Если ЗначениеСимвола = Неопределено Тогда
			ВызватьИсключение "Недопустимый сивол в строке BASE64: "+СимволСтроки64;
		КонецЕсли;
		НакопленноеЗначение = НакопленноеЗначение*64+ЗначениеСимвола;
		Сч = Сч+1;
				
		// Каждые четыре символа надо пересчитать в байты и обнулить накопленное значение
		Если Сч%4 = 0 Тогда
			// Определить значения байтов и записать их в массив
			// Начинаем со старшего байта, вычисляем его значение и добавляем в массив
			// Накопленную сумму при этом уменьшаем на записанное значение
			ТекущийДелитель = Делитель;
			Для НомерБайта = 1 По КоличествоБайт Цикл
				ОстатокНакопленногоЗначения = НакопленноеЗначение%ТекущийДелитель;
				МассивБайтНаВозврат.Добавить((НакопленноеЗначение-ОстатокНакопленногоЗначения)/ТекущийДелитель);
				НакопленноеЗначение = ОстатокНакопленногоЗначения;
				ТекущийДелитель = ТекущийДелитель/256;
			КонецЦикла;
			НомерБайта = Неопределено;
			ОстатокНакопленногоЗначения = Неопределено;
			ТекущийДелитель = Неопределено;
			
			// Обнулить накопленное значение
			НакопленноеЗначение = 0;
			
		КонецЕсли; // Если Сч%4 = 0 Тогда
		
	КонецЦикла;
	СимволСтроки64 = Неопределено;
	ЗначениеСимвола = Неопределено;
	НакопленноеЗначение = Неопределено;
	Сч = Неопределено;
	
	Возврат МассивБайтНаВозврат;

КонецФункции  

// Источник http://infostart.ru/public/99109/
Функция UUIDToGUID(UUID) Экспорт

    Возврат Прав(UUID, 8) + "-" + Сред(UUID, 21, 4) + "-" + Сред(UUID, 17, 4) + "-" + Лев(UUID, 4) + "-" + Сред(UUID, 5, 12);

КонецФункции

// Источник http://infostart.ru/public/99109/
Функция GUIDToUUID(GUID) Экспорт

    Возврат Сред(GUID, 20, 4) + Прав(GUID, 12) + Сред(GUID, 15, 4) + Сред(GUID, 10, 4) + Лев(GUID, 8);

КонецФункции

// Открывает внешнюю обработку
//
// Параметры:
//  мИмяФайла	 - строка 	 - обязательный, полный путь к файлу обработки
//  ОткрытьФорму 	- булево - необязательный, признак необходимости открыть форму
// 
// Возвращаемое значение:
//   - УправляемаяФорма
//	Форма открытой обработки
//
&НаКлиенте
Функция ВнешняяОбработка_Открыть(мИмяФайла, ОткрытьФорму = Истина) Экспорт
	
    мАдресХранилища = "";
    мРезультат = ПоместитьФайл(мАдресХранилища, мИмяФайла, , Ложь, Новый УникальныйИдентификатор);
    мИмяВнешнейОбработки = общ_Сервер.ВнешняяОбработка_Подключить(мАдресХранилища);
    мФорма = ПолучитьФорму("ВнешняяОбработка." + мИмяВнешнейОбработки + ".Форма");
	Если ОткрытьФорму Тогда
		мФорма.Открыть();
	КонецЕсли;
	Возврат мФорма;
	
КонецФункции

// Процедура выполняет поиск помеченных на удаление объектов и их
// рекурсивное удаление
// Может использоваться в фоновом задании
//  
// Взято с http://infostart.ru/public/202693/
//
Процедура ВыполнитьУдалениеПомеченныхОбъектов()   Экспорт
	
	общ_Сервер.ВыполнитьУдалениеПомеченныхОбъектов();
	
КонецПроцедуры // ВыполнитьУдалениеПомеченныхОбъектов()  

#Если ТолстыйКлиентОбычноеПриложение Тогда
// Процедура добавляет видимый интерфейс в обычном приложении
//
//	Параметры:
//		стрИмяИнтерефейса - обязательный, строка
//							Имя интерфейса, которые надо добавить в видимые
//
// 20151126 Заяш
//
Процедура ГлавныйИнтерфейс_ДобавитьИнтерфейс(стрИмяИнтерфейса) Экспорт
	
	ИменаВидимыхИнтерфейсов = "";
	Для Каждого Интерфейс Из ГлавныйИнтерфейс Цикл
		Если Интерфейс.Переключаемый И Интерфейс.Видимость Тогда
			ИменаВидимыхИнтерфейсов = ИменаВидимыхИнтерфейсов+Строка(Интерфейс)+",";
		КонецЕсли;
	КонецЦикла;
	ИменаВидимыхИнтерфейсов = ИменаВидимыхИнтерфейсов+стрИмяИнтерфейса;
	ГлавныйИнтерфейс.ПереключитьИнтерфейс(ИменаВидимыхИнтерфейсов);     
	
КонецПроцедуры
#КонецЕсли //#Если ТолстыйКлиентОбычноеПриложение Тогда

// Функция преобразует двоичные данные в массив целых чисел 0..255
// 
// Параметры:
//  ДвоичныеДанные  - ДвоичныеДанные - Двоичные данные, которые необходимо преобразовать в массив
//                 
Функция ДвоичныеДанные_ВМассив(Знач ДвоичныеДанные) Экспорт
	
	Утверждение_ТипСоответствует(ДвоичныеДанные,Тип("ДвоичныеДанные"));
	
	Строка64 = Base64Строка(ДвоичныеДанные);
	
	Возврат BASE64_Строка_ВМассив(Строка64);
	
КонецФункции

Функция ЕстьРеквизит(Объект, ИмяРеквизита) Экспорт
	
	Проверка_Тип(ИмяРеквизита, "Строка");
	
	Объект_Тип = ТипЗнч(Объект);
	
	Если Объект_Тип = Тип("Структура") Тогда
		Возврат Объект.Свойство(ИмяРеквизита);
		
	ИначеЕсли Объект_Тип = Тип("ДанныеФормыСтруктура") Тогда
		Возврат Объект.Свойство(ИмяРеквизита);
		
	ИначеЕсли Объект_Тип = Тип("ДанныеФормыЭлементКоллекции") Тогда
		Возврат Объект.Свойство(ИмяРеквизита);
		
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	ИначеЕсли Метаданные.НайтиПоТипу(ТипЗнч(Объект)) <> Неопределено Тогда
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(Объект));
		
		Возврат ОбъектМетаданных.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;

	ИначеЕсли ЭтоСсылка(Объект) Тогда
		Возврат Ссылка_ЕстьРеквизит(Объект, ИмяРеквизита);

	#КонецЕсли // Сервер Или ТолстыйКлиентОбычноеПриложение
	
	Иначе
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции 

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент И Не МобильноеПриложениеСервер Тогда
// Функция предназначена для получения текста ошибок журнала регистрации для текущего пользователя
// Используется для отправки отчета об ошибках администратору
// 
// Параметры:
//	МаксимальноеКоличество — обязательный, число, по умолчанию 3
//
// Возвращает 
//	Строка, текст ошибок из журнала регистрации по текущему пользователю
// 	В случае возникновения ошибки чтения журнала регистрации будет возвращено 
// 	описание ошибки этой исключительной ситуации
// 
Функция ЖурналРегистрации_ПолучитьПоследниеОшибки(МаксимальноеКоличество = 3) Экспорт
	
	Попытка
		УстановитьПривилегированныйРежим(Истина);
		тзЖурнала = Новый ТаблицаЗначений;
		Фильтр = Новый Структура;
		Фильтр.Вставить("ДатаНачала", НачалоДня(НачалоДня(ТекущаяДата())-1));
		Фильтр.Вставить("ДатаОкончания", ТекущаяДата());
		Фильтр.Вставить("Уровень", УровеньЖурналаРегистрации.Ошибка);
		Фильтр.Вставить("Пользователь", ПользователиИнформационнойБазы.ТекущийПользователь());
		Колонки = "Комментарий,Дата";
		
		// Журнал регистрации требует прав на доступ
		// поэтому выгружаем его процедурой привелегированного модуля
		общ_ПолныеПрава.ЖурналРегистрации_Выгрузить(
			тзЖурнала,
			Фильтр,
			Колонки,
			, //ИмяВходногоФайла
			МаксимальноеКоличество
			);
		
		стрПоследниеОшибки = "";
		Для Каждого СтрокаТЗ Из тзЖурнала Цикл
			стрПоследниеОшибки = 
			стрПоследниеОшибки + СтрокаТЗ.Дата+"
			|"+СтрокаТЗ.Комментарий +"
			|
			|";
		КонецЦикла;
		
		УстановитьПривилегированныйРежим(Ложь);
		
		Возврат стрПоследниеОшибки;
	Исключение
		Возврат "Журнал регистрации выгрузить не удалось по причине: " + ОписаниеОшибки();
	КонецПопытки;
	
КонецФункции // ЖурналРегистрации_ПолучитьПоследниеОшибки()
#КонецЕсли

// Процедура ищет параметры в тексте запроса, а затем 
// заполняет их из коллекции-источника. Сопоставление параметра и элемента
// коллекции производиться по имени.
// Коллекция источник должна поддерживать обращение к элементам 
// через квадратныескобки Коллекция["имя"] (структура, соответствие, данныеформыструктура)
// 
// Параметры:
//		КоллекцияИсточник - обязательный, структура или соответствие или данныеформыструктура
//		ЗапросПриемник - обязательный, запрос
//
// Примечание:
//		Эта процедура была создана, тк ДанныеФормыСтруктура не позволяет перебирать свои элементы
//		в цикле, поэтому невозможно полное ее копирование в структуру (параметры запроса)
Процедура Запрос_ЗаполнитьПараметры(КоллекцияИсточник,ЗапросПриемник) Экспорт
	
	ОписаниеПараметровЗапроса = ЗапросПриемник.НайтиПараметры();
	
	Для Каждого Описание из ОписаниеПараметровЗапроса Цикл
		ЗапросПриемник.Параметры.Вставить(Описание.Имя,КоллекцияИсточник[Описание.Имя]);		
	КонецЦикла;
	
КонецПроцедуры

Функция ЗначениеНеЗаполнено(Значение) Экспорт

	Результат = Ложь;
	ТипЗначения = ТипЗнч(Значение);

	// Сначала примитивные типы
	Если Значение = Неопределено Тогда
		Результат = Истина;
	ИначеЕсли Значение = NULL Тогда
		Результат = Истина;
	ИначеЕсли ТипЗначения = Тип("Строка") Тогда
		Если СокрЛП(Значение) = "" Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		Если Значение = 0 Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		Если Значение = Дата('00010101') Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Булево") Тогда
		Результат = Ложь; // Булево будем считать не пустым
		
	//Отдельное определение, так как конструкторов данного типа не существует	
	ИначеЕсли ТипЗначения = Тип("РежимПроведенияДокумента") Тогда
		Если Значение = РежимПроведенияДокумента.Неоперативный или Значение = РежимПроведенияДокумента.Оперативный тогда
			Результат = Ложь;
		КонецЕсли;
		
	// Для остальных будем считать значение пустым, если оно равно
	// дефолтному значению своего типа
	Иначе
		Если Значение = Новый(ТипЗначения) Тогда
			Результат = Истина;
		КонецЕсли; 
	КонецЕсли; 

	Возврат Результат;
	
КонецФункции // ЗначениеНеЗаполнено()

#Если Не ВебКлиент И Не МобильныйКлиент И Не МобильноеПриложениеСервер Тогда
Функция Изображение_Сжать(Изображение_ДвоичныеДанные, МаксимальнаяВысота, МаксимальнаяШирина) Экспорт
	
	Если Изображение_ДвоичныеДанные = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Проверка_Тип(Изображение_ДвоичныеДанные, "ДвоичныеДанные");
	Проверка_Тип(МаксимальнаяВысота, "Число");
	Проверка_Тип(МаксимальнаяШирина, "Число");
	
	// Значение на возврат;
	СжатоеИзображение_ДвоичныеДанные = Неопределено;
	
	Изображение_ИсходныйФайл_Имя = ПолучитьИмяВременногоФайла("jpg");
	СжатоеИзображение_ФайлРезультат_Имя = ПолучитьИмяВременногоФайла("jpg");
	Изображение_ДвоичныеДанные.Записать(Изображение_ИсходныйФайл_Имя);

	Попытка
	
		objImageFile = Новый COMОбъект("WIA.ImageFile");//objImageFile
	    objImageProcess = Новый COMОбъект("WIA.ImageProcess");

		objImageFile.LoadFile(Изображение_ИсходныйФайл_Имя);
		
		// Информация об изображении
		//Сообщить("Width "+objImageFile.Width);
		//Сообщить("Height "+objImageFile.Height);
		//Сообщить("PixelDepth "+objImageFile.PixelDepth);
		//Сообщить("HorizontalResolution "+objImageFile.HorizontalResolution);
		//Сообщить("VerticalResolution "+objImageFile.VerticalResolution);
		//Сообщить("FrameCount "+objImageFile.FrameCount);
		//Если objImageFile.IsAnimated Тогда
		//    Сообщить("Анимированная");
		//Иначе
		//    Сообщить("НЕ Анимированная");
		//КонецЕсли;

		objImageProcess.Filters.Add(objImageProcess.FilterInfos("Scale").FilterID);
		
		objImageProcess.Filters.Item(1).Properties.Item("MaximumWidth").Value = 100;
		objImageProcess.Filters.Item(1).Properties.Item("MaximumHeight").Value = 50;
		
		objImageFile = objImageProcess.Apply(objImageFile);
		objImageFile.SaveFile(СжатоеИзображение_ФайлРезультат_Имя);
		
		СжатоеИзображение_ДвоичныеДанные = 
			Новый ДвоичныеДанные(СжатоеИзображение_ФайлРезультат_Имя);
		
	Исключение
		СжатоеИзображение_ДвоичныеДанные = Неопределено;
		
	КонецПопытки;
	
	// Удалить временные файлы
	Попытка
		УдалитьФайлы(Изображение_ИсходныйФайл_Имя);
	Исключение
	КонецПопытки;
	
	Попытка
		УдалитьФайлы(СжатоеИзображение_ФайлРезультат_Имя);
	Исключение
	КонецПопытки;
	
	Возврат СжатоеИзображение_ДвоичныеДанные;
	
КонецФункции
#КонецЕсли // Если Не ВебКлиент И Не МобильныйКлиент Тогда

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция предназначена получения значений из кэша
// В качестве кэша используется соответствие
// Элементами кэша являются пары ключ-значение, где ключ это тип кэшируемого содержимого,
// а значение это соответсвие, хранящее пары строка-ключ/значение ссылка
// 
// 20181218 Заяш: Функция работает с сылками справочников
//
// Параметры:
//  соотвКэш  - Обязательный, соответствие
//				соответсвие, которое используется как хранилище кэшируемых данных
//	Тип_Значение - Обязательный, тип
//					тип ссылки, которую необходимо получить
//	стрКлюч - обязательный, строка
//				наименование элемента справочника, который необходимо получить
//
// Возвращаемое значение:
//   СправочникСсылка 
//
// 20181218 Заяш: Функция создана.
//
Функция Кэш_Получить(соотвКэш, Тип_Значение, стрКлюч) 
	
	РезультатСсылка = Неопределено;
	
	// Проверка входящих параметров
	Проверка_Тип(Тип_Значение, "Тип");
	Проверка_Тип(стрКлюч, "Строка");
	
	// Проверить заполнение и тип входящих параметров
	Если Не ЗначениеЗаполнено(стрКлюч) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	// Если структура кэша не структура, то преобразовать к структуре
	Если ТипЗнч(соотвКэш) <> Тип("Соответствие") Тогда
		соотвКэш = Новый Соответствие;
	КонецЕсли;	
	
	// Если в кэше нет раздела, тодгда добавить раздел
	РазделКэша = соотвКэш.Получить(Тип_Значение);
	Если РазделКэша = Неопределено Или ТипЗНч(РазделКэша) <> Тип("Соответствие") Тогда
		соотвКэш.Вставить(Тип_Значение, Новый Соответствие);
		
	КонецЕсли;
	
	// Искать значение в кэше
	Попытка
		РезультатСсылка = соотвКэш.Получить(Тип_Значение).Получить(стрКлюч);
	Исключение
		РезультатСсылка = Неопределено
	КонецПопытки;
	
	// Проверить тип значения
	Если Не ТипЗнч(РезультатСсылка) = Тип_Значение Тогда
		
		// Если тип неверный, сбросить значение
		РезультатСсылка = Неопределено;
				
	КонецЕсли;
	
	// Если значение найдено в кэше, вернуть его
	Если ТипЗнч(РезультатСсылка) = Тип_Значение И ЗначениеЗаполнено(РезультатСсылка) Тогда
		
		Возврат РезультатСсылка;
		
	Иначе
		РезультатСсылка = Неопределено;
		
	КонецЕсли;
	
	// Искать период планирования в справочнике
	Попытка
		РезультатСсылка = Менеджер_Получить(Тип_Значение).НайтиПоНаименованию(стрКлюч);
	Исключение
		РезультатСсылка = Неопределено;
	КонецПопытки;
	
	// Если период планирования найден, добавить его в кэш
	Если 
			ЗначениеЗаполнено(РезультатСсылка) 
		И	ТипЗнч(РезультатСсылка) = Тип_Значение
	Тогда
		соотвКэш.Получить(Тип_Значение).Вставить(стрКлюч, РезультатСсылка);
		
	КонецЕсли;
	
	Возврат РезультатСсылка;
	
КонецФункции
#КонецЕсли // Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция предназначена для получения описания предопределенных объектов метаданных
// и выгрузки их в таблицу значений.
//
// Параметры:
//  пМетаданные  - ОбъектМетаданных 
//
// Возвращаемое значение:
//   ТаблицаЗначений  - колонки "ИмяПредопределенно", "Наименование, "Код"
//
// 20140121 Заяш 
// Функция была создана, когда понадобилось восстановить коды и наименования 
// предопределенных счетов.
//
Функция Метаданные_Предопределенные_ВыгрузитьВТаблицуЗначений(знач пМетаданные) Экспорт
	
	Менеджер = Общ.Менеджер_Получить(пМетаданные);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"
	|ВЫБРАТЬ
	|	Таблица.Ссылка,
	|	Таблица.Наименование КАК ПредопределенноеИмя,
	|	Таблица.Наименование,
	|	Таблица.Код
	|ИЗ
	|	&Таблица КАК Таблица
	|ГДЕ
	|	Таблица.Предопределенный";
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Таблица", пМетаданные.ПолноеИмя());
	
	тзРезультат = Запрос.Выполнить().Выгрузить();
	
	Для Каждого СтрокаРезультата Из тзРезультат Цикл
		СтрокаРезультата.ПредопределенноеИмя = Менеджер.ПолучитьИмяПредопределенного(СтрокаРезультата.Ссылка);
	КонецЦикла;
	
	тзРезультат.Колонки.Удалить("Ссылка");
	
	Возврат тзРезультат;
	
КонецФункции // Метаданные_Предопределенные_ВыгрузитьВТаблицуЗначений()
#КонецЕсли 

// Процедура загружает описание метаданных из таблицы значений, полученной с помощью
// функции Метаданные_Предопределенные_ВыгрузитьВТаблицуЗначений
//
// Параметры:
//  пМетаданные  - ОбъектМетаданных, 
//				для которого необходимо загрузить предопределенные
//
//	пТЗ — ТаблицаЗначений, обязательный
//		таблица значений, содержащая описание предопределенных элементов
//		объекта метаданных: ИмяПредопределенного, Наименование, Код
//		таблица получается с помощью функции Метаданные_Предопределенные_ВыгрузитьВТаблицуЗначений
//
// 20140122 Заяш 
// Процедура была создана, когда понадобилось восстановить коды и наименования 
// предопределенных счетов.
//
Процедура Метаданные_Предопределенные_ЗагрузитьИзТаблицыЗначений(знач пМетаданные, пТЗ) Экспорт
	
	Менеджер = Общ.Менеджер_Получить(пМетаданные);
	
	Для Каждого СтрокаТЗ Из пТЗ Цикл
		
		Если Не ЗначениеЗаполнено(СтрокаТЗ.ПредопределенноеИмя) Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			ПредопределенныйЭлемент_Ссылка = Менеджер[СтрокаТЗ.ПредопределенноеИмя];
		Исключение
			Сообщить(
				пМетаданные.ПолноеИмя() + "
				|не найден предопределенный элемент " + СтрокаТЗ.ПредопределенноеИмя + "
				|"+ОписаниеОшибки()
				);
			Продолжить;
		КонецПопытки;
			
		Если Не ЗначениеЗаполнено(ПредопределенныйЭлемент_Ссылка)  Тогда
			Продолжить;
		КонецЕсли;
		
		ПредопределенныйЭлемент_Объект = ПредопределенныйЭлемент_Ссылка.ПолучитьОбъект();
		ЗаполнитьЗначенияСвойств(ПредопределенныйЭлемент_Объект, СтрокаТЗ);
		ПредопределенныйЭлемент_Объект.Записать();
	КонецЦикла;
		
КонецПроцедуры // Метаданные_Предопределенные_ЗагрузитьИзТаблицыЗначений()

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент И Не МобильноеПриложениеСервер Тогда
// Функция - Отчет объект получить результат
// Вызывается из кода сервера или толстого клиента
// Выводит результат отчета на СКД в таблицу значений или табличный документ
// Чтобы исползовать далее результат отчета в алгоритмах 
//
// Параметры:
//  ОтчетОбъект	- ОтчетОбъект - обязательный параметр
//		отчет, результат которого необходимо получить
//  РезультатОтчета	- ТабличныйДокумент, ТаблицаЗначений - необязательный параметр
//		в эту переменную можно передать объект, в который будет возвращен результат отчета
// 
// Возвращаемое значение:
//   - ТабличныйДокумент, ТаблицаЗначений
//		результат выполнения отчета.
// 		Если в параметр РезультатОтчета передано значение, то вернется оно
//		Если в параметр РезультатОтчета не передано ничего, будет возращен ТабличныйДокумент
//
Функция ОтчетОбъект_ПолучитьРезультат(ОтчетОбъект, РезультатОтчета = Неопределено) Экспорт
	
	Если РезультатОтчета = Неопределено тогда
		РезультатОтчета = Новый ТабличныйДокумент;
	КонецЕсли;	
	
	МассивДопустимыхТипов = Новый Массив;
	МассивДопустимыхТипов.Добавить(Тип("ТабличныйДокумент"));
	МассивДопустимыхТипов.Добавить(Тип("ТаблицаЗначений"));
	Проверка_Тип(РезультатОтчета,Новый ОписаниеТипов(МассивДопустимыхТипов));		
	
	РезультатОтчета.Очистить();
	
	
	Если ТипЗнч(РезультатОтчета) = Тип("ТабличныйДокумент") Тогда
		ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
		ПроцессорВывода.УстановитьДокумент(РезультатОтчета);
		ТипГенератораМакета = Тип("ГенераторМакетаКомпоновкиДанных");
		
	ИначеЕсли ТипЗнч(РезультатОтчета) = Тип("ТаблицаЗначений") Тогда
		ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
		ПроцессорВывода.УстановитьОбъект(РезультатОтчета);
		ТипГенератораМакета = Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений");

	КонецЕсли;
	
	// Формируем отчет
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = 
		КомпоновщикМакета.Выполнить(
			ОтчетОбъект.СхемаКомпоновкиДанных, 
			ОтчетОбъект.КомпоновщикНастроек.Настройки,
			,
			,
			ТипГенератораМакета
			);
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки, , , Истина);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
	
	Возврат РезультатОтчета;
	
КонецФункции
#КонецЕсли // Если Не ТонкийКлиент

Процедура Пауза(Секунд = 1) Экспорт
	
	общ_Сервер.Пауза(Секунд);
	
КонецПроцедуры

// Процедура для выполнения паузы на линукс/виндовс
// https://www.forum.mista.ru/topic.php?id=686617&page=1#31
Процедура Пауза_ping(Сек = 1) Экспорт
	
	Инфо = Новый СистемнаяИнформация();
    Если 
        Инфо.ТипПлатформы = ТипПлатформы.Windows_x86 ИЛИ 
        Инфо.ТипПлатформы = ТипПлатформы.Windows_x86_64
    Тогда
        ЗапуститьПриложение("ping -n " + Формат(1 + Сек, "ЧДЦ=0; ЧГ=") + " 127.0.0.1", , Истина);// windows

    Иначе
        ЗапуститьПриложение("ping -c " + Формат(1 + Сек, "ЧДЦ=0; ЧГ=") + " 127.0.0.1", , Истина);// linux

	КонецЕсли;
	
КонецПроцедуры

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция возвращает значение параметра сеанса по его имени.
// Создавалась для использования в вычисляемых полях СКД
//
//	Параметры:
//		ИмяПараметраСеанса -	Обязательный, Строка
//								Имя параметра, как оно задано в конфигураторе
//	Возвращает:
//		Произвольное значение, значение параметра сеанса.
//		
Функция ПараметрСеанса_ПолучитьПоИмени(ИмяПараметраСеанса) Экспорт
	
	Возврат ПараметрыСеанса[ИмяПараметраСеанса];
	
КонецФункции
#КонецЕсли

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция пытается привести значение к требуемому типу
//
// Параметры:
//	Значение — произвольный — обязательный
//			Значение, которое необходимо привести
//	ТребуемыйТип — Тип — обязательный
//			Тип, к которому нужно привести значение
//
//	Возвращает
//		Произвольный, значение, приведенное к требуемому типу
//
// 20140126 Заяш
//
Функция ПривестиКТипу(Знач Значение, ТребуемыйТип)
	
	Если ТипЗнч(Значение) = Тип("Строка") Тогда
		Значение = СокрЛП(Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = ТребуемыйТип Тогда
		Возврат Значение;
	КонецЕсли;
	
	НаВозврат = Неопределено;
	
	МенеджерТипа = Менеджер_Получить(ТребуемыйТип);
	
	Если ТребуемыйТип = Тип("Число") Тогда
		Попытка
			НаВозврат = Число(Значение);
		Исключение
			НаВозврат = 0;
		КонецПопытки;
	ИначеЕсли МенеджерТипа <> Неопределено И Не ЗначениеЗаполнено(Значение) Тогда
		Возврат МенеджерТипа.ПустаяСсылка();
	ИначеЕсли МенеджерТипа <> Неопределено Тогда
		Попытка
			НаВозврат = МенеджерТипа.НайтиПоНаименованию(Значение,Истина);
		Исключение
		КонецПопытки;
		Если ЗначениеЗаполнено(НаВозврат) Тогда
			Возврат НаВозврат;
		КонецЕсли;
		
		Попытка
			НаВозврат = МенеджерТипа.НайтиПоКоду(Значение);
		Исключение
		КонецПопытки;
		Если ЗначениеЗаполнено(НаВозврат) Тогда
			Возврат НаВозврат;
		КонецЕсли;

		Попытка
			НаВозврат = МенеджерТипа.НайтиПоНомеру(Значение);
		Исключение
		КонецПопытки;
		Если ЗначениеЗаполнено(НаВозврат) Тогда
			Возврат НаВозврат;
		КонецЕсли;
	Иначе
		Возврат НаВозврат;
	КонецЕсли;
	
	Возврат НаВозврат;
	
КонецФункции
#КонецЕсли

// Чаще всего такая функция может понадобится при работе с динамически формируемыми колонками таблиц значений, 
// которые требуется вывести на форму или в табличный документ. 
// Данную функцию можно поместить в общий модуль или в любое другое удобное место. 
// Также можно заметить, что строчка СуммаСНДС преобразовывается корректно (в конфигураторе это не так). 
// Для этого добавлено исключение, которое при необходимости можно доработать и под другие нестандартные ситуации
//
// http://infostart.ru/public/196681/
Функция Синоним(Знач Имя) Экспорт
 
 НовоеИмя = "";
 Имя = СтрЗаменить(Имя, "СНДС", "_сНДС"); 
 Длина = СтрДлина(Имя);
 Для Индекс = 1 По Длина Цикл
 
    Символ = Сред(Имя, Индекс, 1);
 
    Если Символ = НРег(Символ) И Найти("1234567890", Символ) = 0 Тогда 
       НовоеИмя = НовоеИмя + Символ;
       Продолжить;
    КонецЕсли;
 
    Если Символ = ВРег(Символ) Тогда
 
       Если Индекс > 1 Тогда
          НовоеИмя = НовоеИмя + " "
       КонецЕсли;
 
       Аббревиатура = (Сред(Имя, Индекс, 3) = ВРег(Сред(Имя, Индекс, 3))) И (Длина - Индекс > 1);
       Предлог = (Сред(Имя, Индекс, 2) = ВРег(Сред(Имя, Индекс, 2))) И (Длина > Индекс);
 
       Если Аббревиатура Тогда
          ДлинаАббревиатуры = 3;
 
          Пока Сред(Имя, Индекс, ДлинаАббревиатуры) = ВРег(Сред(Имя, Индекс, ДлинаАббревиатуры)) 
               И  Индекс + ДлинаАббревиатуры <= Длина + 1 Цикл
 
               ДлинаАббревиатуры = ДлинаАббревиатуры + 1
          КонецЦикла;
 
          ДлинаАббревиатуры = ДлинаАббревиатуры - 1;
 
          Если (Индекс + ДлинаАббревиатуры - 1) = Длина Тогда
               НовоеИмя = НовоеИмя + Сред(Имя, Индекс, ДлинаАббревиатуры);
          Иначе
               ДлинаАббревиатуры = ДлинаАббревиатуры - 1;
               НовоеИмя = НовоеИмя + Сред(Имя, Индекс, ДлинаАббревиатуры) + " " + НРег(Сред(Имя, Индекс + ДлинаАббревиатуры, 1));
          КонецЕсли;
 
          Индекс = Индекс + ДлинаАббревиатуры;
          Продолжить;
       КонецЕсли; 
 
 
       Если Предлог Тогда
          НовоеИмя = НовоеИмя + НРег(Символ) + " " + НРег(Сред(Имя, Индекс + 1, 1)) + " ";
          Индекс = Индекс + 1;
          Продолжить;
       КонецЕсли; 
 
 
       НовоеИмя = НовоеИмя + НРег(Символ); 
 
 
    КонецЕсли; 
 
 КонецЦикла;
 
 НовоеИмя = СтрЗаменить(НовоеИмя, "_", " ");
 НовоеИмя = ВРег(Лев(НовоеИмя, 1)) + Прав(НовоеИмя, СтрДлина(НовоеИмя) - 1);
 Возврат НовоеИмя;
 
КонецФункции

#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
// Функция предназначена для определения имени табличной части, которой принадлежит строка
//
// Параметры:
//  ТабличнаяЧастьСтрока  - ТабличнаяЧастьСтрока - Обязательный
//              строка табличной части ссылочного объекта, 
//				для которой надо найти имя родительской табличной части
//
// Возвращаемое значение:
//   Строка - Имя табличной части
//	 Неопределено — если имя табличной части найти не удалось
//
// НА 20171226 Заяш 
//
Функция ТабличнаяЧастьСтрока_ПолучитьИмяТабличнойЧасти(ТабличнаяЧастьСтрока) Экспорт
	
	Возврат Метаданные.НайтиПоТипу(ТипЗнч(ТабличнаяЧастьСтрока)).Имя;

КонецФункции
#КонецЕсли // ТабличнаяЧастьСтрока_ПолучитьИмяТабличнойЧасти //#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда

#Если Не ВебКлиент И Не МобильныйКлиент И Не МобильноеПриложениеСервер Тогда
// Функция предназначена для выполнения произвольных тестов
//
// Параметры:
//	СтруктураТестов - Обязательный, структура
//					Ключи элементов структуры содержать названия тестов
//					Значения элементов структуры содержат выполняемый код тестов
//  Табдок — необязательный, табличный документ
//			табличный документ, в который будут выведены результаты тестов
//
//	Возвращает
//		Булево
//			Истина — тесты прошли
//			Ложь — есть ошибки
//
Функция Тесты_Выполнить(СтруктураТестов, ТабДок = Неопределено) Экспорт
	
	Проверка_Тип(СтруктураТестов, Тип("Структура"));
	Если ТабДок = Неопределено Тогда
		Проверка_Тип(ТабДок, Тип("ТабличныйДокумент"));
	КонецЕсли;
    	
	Отчет = Новый ТекстовыйДокумент;
	Отчет.ДобавитьСтроку("Тестирование");
	Отчет.ДобавитьСтроку(ТекущаяДата()+Символы.ПС+Символы.ПС+Символы.ПС);
	Отчет.ДобавитьСтроку("");
	
	ТестЗеленый = Истина;
	Для Каждого КлючИЗначение Из СтруктураТестов Цикл
		ИмяТеста = КлючИЗначение.Ключ;
		КодТеста = КлючИЗначение.Значение;
		
		# Если ТолстыйКлиентОбычноеПриложение Тогда 	
		ОбработкаПрерыванияПользователя();
		# КонецЕсли

		НачалоТеста = ТекущаяДата();		
		Отчет.ДобавитьСтроку(ИмяТеста+Символы.ПС);
		Попытка
			Выполнить(КодТеста);
		Исключение
			Отчет.ДобавитьСтроку("Ошибка: "+ОписаниеОшибки());
			ТестЗеленый = Ложь;
		КонецПопытки;
		Отчет.ДобавитьСтроку(
			"Выполнен за: "+(ТекущаяДата()-НачалоТеста)+ " сек.
			|
			| // =======
			|
			|
			|"
		);
		Отчет.ДобавитьСтроку(""); // Разрыв между тестами
	КонецЦикла;
	КлючИЗначение = Неопределено;
	ИмяТеста = Неопределено;
	КодТеста = Неопределено;
	
	Отчет.ДобавитьСтроку(ТекущаяДата());	
	
	Если ТабДок <> Неопределено Тогда
		ТабДок.ОтображатьСетку = Ложь;
		ТабДок.ТолькоПросмотр = Истина;
		ТабДок.Область(,1,,1).ШиринаКолонки = 120; // Установить ширину колонки
		
		Для сч=1 По Отчет.КоличествоСтрок() Цикл
			Область = ТабДок.Область(сч,1,сч,1);
			Область.Текст = Отчет.ПолучитьСтроку(сч); 
			Если Найти(Область.Текст,"Ошибка: ") Тогда
				Область.ЦветФона = WebЦвета.ЛососьСветлый;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТестЗеленый;	
		
КонецФункции
#КонецЕсли //Если Не ВебКлиент И Не МобильныйКлиент 

#Если Не ВебКлиент И Не МобильныйКлиент И Не МобильноеПриложениеСервер Тогда
Функция Цвет_HTMLиз1С(Цвет1С) Экспорт
	
	ТабличныйДокумент = Новый ТабличныйДокумент; 
	Область = ТабличныйДокумент.Область(1, 1); 
	Область.ЦветТекста = Цвет1С; 
	ТекстHTML = ТабличныйДокумент_ПолучитьТекстHTML(ТабличныйДокумент);
	ТокенЦветаОбласти11 = "td.R0C0{ color: #"; 
	ПозицияHEXЦветаФонаВыделенияПоля = Найти(ТекстHTML, ТокенЦветаОбласти11); 
	HEXЦветФонаВыделенияПоля = Сред(ТекстHTML, ПозицияHEXЦветаФонаВыделенияПоля + СтрДлина(ТокенЦветаОбласти11), 6); 
	
	Возврат HEXЦветФонаВыделенияПоля;
	
КонецФункции
#КонецЕсли

// Утверждение, проверяет что тип значения соответствует переданному типу
// Если не соответствует, вызывает исключение
// 
// Параметры:
//  Значение  - произвольный - значение, тип, которого необходимо проверить
// 	Тип  - Тип, которому необходимо проверить соответствие значение
//                 
Процедура Утверждение_ТипСоответствует(Значение, Тип) Экспорт
	
	Если ТипЗнч(Тип) <> Тип("Тип") Тогда
		ВызватьИсключение "Неверный тип для сравнения" ;
	КонецЕсли;
	
	Если ТипЗнч(Значение) <> Тип Тогда
		ТекстОшибки = 
			СтрШаблон(
				"Не соответстует тип значения <<%3>>: <<%1>>  вместо <<%2>>",
				ТипЗнч(Значение),
				Тип,
				Значение
				);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
КонецПроцедуры

// Процедура приводит значение к пустому значению такого же типа
Процедура УстановитьПустоеЗначение(Значение) Экспорт
	
	Значение = Тип_ПолучитьПустоеЗначение(ТипЗнч(Значение));
	
КонецПроцедуры

#КонецОбласти

//Разное

#Область Даты

#Область UnixTimeStamp

// Функция - UnixTimeStamp в дату
// Для механизмов обмена с внешними информационными системами
// Преобразует число UnixTimeStamp в дату
// Чтобы использовать в алгоритмах внутри 1С
//
// Параметры:
//  UnixTimeStamp - число - обязательный параметр
//		Этот параметр будет преобразован в дату
// 
// Возвращаемое значение:
//   - Дата 
//
Функция UnixTimeStamp_в_Дату(UnixTimeStamp) Экспорт
	
	Проверка_Тип(UnixTimeStamp, "Число");
	
	Возврат МестноеВремя('19700101' + UnixTimeStamp); 
	
КонецФункции

// Функция - Дата в UnixTimeStamp
// Для механизмов обмена с внешними информационными системами
// Преобразует число дату в UnixTimeStamp
// Чтобы выгружать даты во внешние информационные системы
//
// Параметры:
//  ПараметрДата - дата - обязательный параметр
//		Эта дата будет преобразована в UnixTimeStamp
// 
// Возвращаемое значение:
//   - Число
//		UnixTimeStamp
//
Функция Дата_в_UnixTimeStamp(ПараметрДата) Экспорт
	
	Проверка_Тип(ПараметрДата, "Дата");
	
	Возврат УниверсальноеВремя(ПараметрДата) - '19700101';
	
КонецФункции

#КонецОбласти 
//UnixTimeStamp

#Область СтрокаВДату

// ПРЕОБРАЗОВАНЕИ СТРОКИ В ДАТУ (форматы W3C и GNU)
//
// (с) Влад Косилов
// http://infostart.ru/public/70017/
//
//Функция преобразует дату форматов  
//  1. Submitted to W3C 15 September 1997 http://www.w3.org/TR/NOTE-datetime  
//  2. GNU формат   http://www.gnu.org/software/tar/manual/html_node/Date-input-formats.html#SEC119 
//  в дату 1С.
//GNU поддерживается не полностью:
//  - микросекунды не могут отделять ",", а только "."
//  - зоны только GMT UTC Z 
//  - не поддерживаются форматы в описании  7.6, 7.7, 7.8, 7.9

//  Функция преобразует дату форматов
//  1. Submitted to W3C 15 September 1997 http://www.w3.org/TR/NOTE-datetime
//  2. GNU формат   http://www.gnu.org/software/tar/manual/html_node/Date-input-formats.html#SEC119
//  в дату 1С
// GNU поддерживается не полностью:
//  - микросекунды не могут отделять ",", а только "."
//  - зоны только GMT UTC Z
//  - не поддерживаются форматы в описании  7.6, 7.7, 7.8, 7.9
// Автор: В.Косилов
Функция AnyDateStrToDate(Знач СтрокаДаты) Экспорт
    //  The formats are as follows. Exactly the components shown here must be present, with exactly this punctuation.
    //Note that the "T" appears literally in the string, to indicate the beginning of the time element, as specified in ISO 8601.
    //   Year:
    //    YYYY (eg 1997)
    //   Year and month:
    //    YYYY-MM (eg 1997-07)
    //   Complete date:
    //    YYYY-MM-DD (eg 1997-07-16)
    //   Complete date plus hours and minutes:
    //    YYYY-MM-DDThh:mmTZD (eg 1997-07-16T19:20+01:00)
    //   Complete date plus hours, minutes and seconds:
    //    YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)
    //   Complete date plus hours, minutes, seconds and a decimal fraction of a
    //second
    //    YYYY-MM-DDThh:mm:ss.sTZD (eg 1997-07-16T19:20:30.45+01:00)
    если СтрДлина(СтрокаДаты) = 4 и ПроверкаЧисло(СтрокаДаты)<>неопределено  тогда
        //   Year:
        //    YYYY (eg 1997)
        возврат Дата(СтрокаДаты,1,1);
    иначеесли СтрДлина(СтрокаДаты) = 7 и ПроверкаЧисло(СтрЗаменить(СтрокаДаты,"-",""))<>неопределено и
        ПроверкаЧисло(Лев(СтрокаДаты,4))<>неопределено тогда
        //   Year and month:
        //    YYYY-MM (eg 1997-07)
        СтрокаДаты = СтрЗаменить(СтрокаДаты,"-","");
        СтрокаДаты=СтрокаДаты+"01";
        возврат Дата(СтрокаДаты);
    иначеесли СтрДлина(СтрокаДаты) = 8 и ПроверкаЧисло(СтрокаДаты)<>неопределено тогда
        // YYYYMMDD
        возврат Дата(СтрокаДаты);
    иначеесли СтрДлина(СтрокаДаты) = 10 и ПроверкаЧисло(СтрЗаменить(СтрокаДаты,"-",""))<>неопределено и
        ПроверкаЧисло(лев(СтрокаДаты,4))<>неопределено и ПроверкаЧисло(Сред(СтрокаДаты,6,2))<>неопределено и
        ПроверкаЧисло(Сред(СтрокаДаты,9,2))<>неопределено тогда
        //   Complete date:
        //    YYYY-MM-DD (eg 1997-07-16)
        СтрокаДаты = СтрЗаменить(СтрокаДаты,"-","");
        возврат Дата(СтрокаДаты);
    иначеесли СтрДлина(СтрокаДаты) > 10 и ПроверкаЧисло(СтрЗаменить(Лев(СтрокаДаты,10),"-",""))<>неопределено   // первая часть предположительно дата
            и (Сред(СтрокаДаты,11,1)="T") // Разделитель даты и времени на своем месте
            и (Найти(СтрокаДаты,"Z")>0 или Найти(СтрокаДаты,"+")>0 или Найти(СтрокаДаты,"-")>0) // присутствует TZD
            тогда
            //   Complete date plus hours and minutes:
            //    YYYY-MM-DDThh:mmTZD (eg 1997-07-16T19:20+01:00)
            //   Complete date plus hours, minutes and seconds:
            //    YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)
            //   Complete date plus hours, minutes, seconds and a decimal fraction of a
            //second
            //    YYYY-MM-DDThh:mm:ss.sTZD (eg 1997-07-16T19:20:30.45+01:00)
            // Выделим Дату в формат YYYYMMDD
            ТолькоДата = СтрЗаменить(Лев(СтрокаДаты,10),"-","");
            // Выделим Время в форматы hh:mm или hh:mm:ss или hh:mm:ss.s
            СимвZ = Найти(Сред(СтрокаДаты,12,20),"Z");
            СимвПлюс = Найти(Сред(СтрокаДаты,12,20),"+");
            СимвМинус = Найти(Сред(СтрокаДаты,12,20),"-");
            ДлинаВремени = ?(СимвZ>0,СимвZ, ?(СимвПлюс>0, СимвПлюс, СимвМинус))-1;
            ТолькоВремя =  Сред(СтрокаДаты,12, ДлинаВремени);
            Часы = Лев(ТолькоВремя,2);
            Минуты = Сред(ТолькоВремя,4,2);
            Секунды = Сред(ТолькоВремя,7,2);

            // Дыделим добавку часового пояса
            если СимвZ>0 тогда
                ДобавкаЧасов = 0;
                ДобавкаМинут = 0;
            иначеесли СимвПлюс>0 тогда
                ДобавкаЧасов = ПроверкаЧисло(Сред(СтрокаДаты,СимвПлюс+12,2));
                ДобавкаМинут = ПроверкаЧисло(Сред(СтрокаДаты,СимвПлюс+15,2));
            иначе
                ДобавкаЧасов = -ПроверкаЧисло(Сред(СтрокаДаты,СимвМинус+12,2));
                ДобавкаМинут = -ПроверкаЧисло(Сред(СтрокаДаты,СимвМинус+15,2));
            конецесли;

            ДатаЗнч = Дата(ТолькоДата+Часы+Минуты+Секунды);
            ДатаЗнч = ДатаЗнч + (ДобавкаМинут*60 + ДобавкаЧасов*60*60);
            возврат ДатаЗнч;

        иначе
            // Пробуем формат GNU
            // Сначала разобъем на блоки по пробелу
            МассивБлоков = новый Массив;
            ИщемНачало = истина;
            ТекБлок = "";
            СтрокаДаты = нрег(СтрокаДаты);
            Для НомерСимволаСтроки=1 по СтрДлина(СтрокаДаты) цикл
                ТекСимвол =  Сред(СтрокаДаты,НомерСимволаСтроки,1);
                если Не (ТекСимвол=" " или ТекСимвол=",") тогда
                    ТекБлок = ТекБлок + ТекСимвол;
                    ИщемНачало = ложь;
                    продолжить;
                иначеесли ИщемНачало тогда
                    продолжить;
                иначе
                    МассивБлоков.Добавить(ТекБлок);
                    ТекБлок = "";
                    ИщемНачало = истина;
                конецесли;
            конеццикла;
            если Не ИщемНачало тогда
                МассивБлоков.Добавить(ТекБлок);
            конецесли;
            // Теперь МассивБлоков содержит блоки строки даты

            // Добавим литералы днейнедели и месяце (можно добавлять еще языки)
            Мес = новый Соответствие;
            Мес.Вставить("jan",1);
            Мес.Вставить("feb",2);
            Мес.Вставить("mar",3);
            Мес.Вставить("apr",4);
            Мес.Вставить("may",5);
            Мес.Вставить("jun",6);
            Мес.Вставить("jul",7);
            Мес.Вставить("aug",8);
            Мес.Вставить("sep",9);
            Мес.Вставить("sept",9);
            Мес.Вставить("oct",10);
            Мес.Вставить("nov",11);
            Мес.Вставить("dec",12);

            Мес.Вставить("jan.",1);
            Мес.Вставить("feb.",2);
            Мес.Вставить("mar.",3);
            Мес.Вставить("apr.",4);
            Мес.Вставить("may.",5);
            Мес.Вставить("jun.",6);
            Мес.Вставить("jul.",7);
            Мес.Вставить("aug.",8);
            Мес.Вставить("sep.",9);
            Мес.Вставить("sept.",9);
            Мес.Вставить("oct.",10);
            Мес.Вставить("nov.",11);
            Мес.Вставить("dec.",12);

            Мес.Вставить("january",1);
            Мес.Вставить("february",2);
            Мес.Вставить("febr",2);
            Мес.Вставить("march",3);
            Мес.Вставить("april",4);
            Мес.Вставить("may",5);
            Мес.Вставить("june",6);
            Мес.Вставить("july",7);
            Мес.Вставить("august",8);
            Мес.Вставить("september",9);
            Мес.Вставить("sept",9);
            Мес.Вставить("october",10);
            Мес.Вставить("november",11);
            Мес.Вставить("december",12);

            Мес.Вставить("январь",1);
            Мес.Вставить("февраль",2);
            Мес.Вставить("март",3);
            Мес.Вставить("апрель",4);
            Мес.Вставить("май",5);
            Мес.Вставить("июнь",6);
            Мес.Вставить("июль",7);
            Мес.Вставить("август",8);
            Мес.Вставить("сентябрь",9);
            Мес.Вставить("октябрь",10);
            Мес.Вставить("ноябрь",11);
            Мес.Вставить("декабрь",12);

            Мес.Вставить("янв",1);
            Мес.Вставить("фев",2);
            Мес.Вставить("мар",3);
            Мес.Вставить("апр",4);
            Мес.Вставить("май",5);
            Мес.Вставить("июн",6);
            Мес.Вставить("июл",7);
            Мес.Вставить("авг",8);
            Мес.Вставить("сен",9);
            Мес.Вставить("окт",10);
            Мес.Вставить("ноя",11);
            Мес.Вставить("дек",12);

            Мес.Вставить("янв.",1);
            Мес.Вставить("фев.",2);
            Мес.Вставить("мар.",3);
            Мес.Вставить("апр.",4);
            Мес.Вставить("май.",5);
            Мес.Вставить("июн.",6);
            Мес.Вставить("июл.",7);
            Мес.Вставить("авг.",8);
            Мес.Вставить("сен.",9);
            Мес.Вставить("окт.",10);
            Мес.Вставить("ноя.",11);
            Мес.Вставить("дек.",12);


            ДНед = новый Массив;
            ДНед.Добавить("monday");
            ДНед.Добавить("tuesday");
            ДНед.Добавить("wednesday");
            ДНед.Добавить("thursday");
            ДНед.Добавить("friday");
            ДНед.Добавить("saturday");
            ДНед.Добавить("sunday");
            ДНед.Добавить("mon");
            ДНед.Добавить("tue");
            ДНед.Добавить("wed");
            ДНед.Добавить("thu");
            ДНед.Добавить("fri");
            ДНед.Добавить("sat");
            ДНед.Добавить("sun");


            ДНед.Добавить("понедельник");
            ДНед.Добавить("вторник");
            ДНед.Добавить("среда");
            ДНед.Добавить("четверг");
            ДНед.Добавить("пятница");
            ДНед.Добавить("суббота");
            ДНед.Добавить("воскресенье");
            ДНед.Добавить("пн");
            ДНед.Добавить("вт");
            ДНед.Добавить("ср");
            ДНед.Добавить("чт");
            ДНед.Добавить("пт");
            ДНед.Добавить("сб");
            ДНед.Добавить("вс");

            // Текущие данные
            День = неопределено;
            Месяц = неопределено;
            Год = неопределено;
            Часов = неопределено;
            Минут = неопределено;
            Секунд = неопределено;

            ЗнакДобавки = 1;
            ДобавкаЧасов = неопределено;
            ДобавкаМинут = неопределено;
            ЧасовойПояс = неопределено;

            БлокВремени = неопределено;

            БлокВремениСЧасовымПоясом = неопределено;
            БлокДатыСРазделителем = неопределено;

            ЧислаХ = новый массив; // для неопределенных числовых значений

            Для каждого Блок из МассивБлоков цикл
                если Найти(Блок,":")>0 и Найти(Блок,"+")=0 и Найти(Блок,"-")=0 тогда
                    // Это блок времени (исключили часовой пояс вида +hh:mm и -hh:mm)
                    // 20:02:00.000000
                    // 20:02
                    // 8:02pm
                    БлокВремени = Блок;
                иначеесли ДНед.Найти(Блок)<>неопределено тогда
                    // Это блок дня недели - просто опускаем (его необходимо исключить, чтобы не мешал)
                    //продолжить;
                иначеесли isset(Мес[Блок]) тогда
                    // Нашли месяц
                    Месяц = Мес[Блок];
                    // продолжить;
                иначеесли Найти(Блок, "gmt")>0 или Найти(Блок, "z")>0 или Найти(Блок, "utc")>0 тогда
                    // Нашли блок часового пояса для варианто UTC, UTC+hhmm, UTC-hh:mm
                    ЧасовойПояс = Блок;
                иначеесли Лев(Блок,1) = "-" или Лев(Блок,1) = "+" и
                    ПроверкаЧисло(СтрЗаменить(Блок,":","")<>неопределено) тогда
                    // Это должен быть только часовой пояс  вида +hhmm, -hhmm, +hh:mm, -hh:mm
                    ЧасовойПояс = "" + ЧасовойПояс + Блок;
                иначеесли Найти(Блок,":")>0 и (Найти(Блок, "-")>0 или Найти(Блок, "+")>0) тогда
                    // Это время вместе с добавкой вида 20:02-0500 # In EST (U.S. Eastern Standard Time).
                    БлокВремениСЧасовымПоясом = Блок;
                    если Найти(БлокВремениСЧасовымПоясом,"-") тогда
                        ЗнакДобавки = -1;
                    конецесли;
                    МассивВремениИДобавки = split("+-",БлокВремениСЧасовымПоясом);
                    БлокВремени = МассивВремениИДобавки[0];
                    ЧасовойПояс = "" + ?(ЗнакДобавки>0,"+","-")+МассивВремениИДобавки[1];

                иначеесли (Найти(Блок,"-")>0 и ПроверкаЧисло(СтрЗаменить(Блок,"-",""))<>неопределено)
                    или (Найти(Блок,"/")>0 и ПроверкаЧисло(СтрЗаменить(Блок,"/",""))<>неопределено)
                    или (Найти(Блок,"\")>0 и ПроверкаЧисло(СтрЗаменить(Блок,"\",""))<>неопределено)
                    или (Найти(Блок,".")>0 и ПроверкаЧисло(СтрЗаменить(Блок,".",""))<>неопределено) тогда
                    // Это дата формата
                    //                  1972-09-24     # ISO 8601.
                    //72-9-24        # Assume 19xx for 69 through 99,
                    //             # 20xx for 00 through 68.
                    //72-09-24       # Leading zeros are ignored.
                    //9/24/72        # Common U.S. writing.
                    // 01.05.02  -  тоже возможно проверить
                    // 9/24 - без года - день в конце, но с разделителем


                    БлокДатыСРазделителем = Блок;
                иначеесли ПроверкаЧисло(Блок)<>неопределено тогда
                    // остались день месц год - день должен быть первым при этом
                    // если месяц числовой то порядок следования год-месяц-день или месяц-день
                    // а если прописью то допустимы
                    // day month year
                    // day month
                    // month day year
                    // day-month-year
                    //
                    //Or, omitting the year:
                    //  month day
                    // С этим разберемся потом
                    ЧислаХ.Добавить(Число(Блок));
                иначеесли (Найти(Блок,"-")>0)
                    или (Найти(Блок,"/")>0)
                    или (Найти(Блок,"\")>0)
                    или (Найти(Блок,".")>0)  тогда
                    // может такое  24-sep-72 24/sep/72 24\sep\72 24.sep.72
                    БлокДатыСРазделителем = Блок;
                конецесли;
            КонецЦикла;
            // Теперь можно смотреть что есть.

            // Сначала дата
            если БлокДатыСРазделителем<>неопределено тогда
                если (Найти(Блок,"/")>0 и ПроверкаЧисло(СтрЗаменить(Блок,"/",""))<>неопределено) тогда
                    // Амеркианский стандарт 9/24/72        # Common U.S. writing.

                    МассивДаты = split("/.\", БлокДатыСРазделителем);
                    КвоЭл = МассивДаты.Количество();
                    если КвоЭл>2 тогда
                        Год = МассивДаты[2];
                        Месяц = МассивДаты[0];
                        День = МассивДаты[1];
                    иначе
                        Год = Год(ТекущаяДата());
                        Месяц = МассивДаты[0];
                        День = МассивДаты[1];
                    конецесли;
                иначе
                МассивДаты = split("-.", БлокДатыСРазделителем);
                если МассивДаты.Количество()>2 тогда
                    // Дата с годом
                    если ПроверкаЧисло(МассивДаты[1])=неопределено тогда
                        //месяц прописью -формат день-месц-год
                        Месяц=Мес[МассивДаты[1]];
                        Год = МассивДаты[2];
                        День = МассивДаты[0];
                    иначе
                        // месяц числом - формат год-месяц-день
                        Год = МассивДаты[0];
                        Месяц = МассивДаты[1];
                        День = МассивДаты[2];
                    конецесли;
                иначе
                    // Дата без года
                    если isset(Мес[МассивДаты[1]]) тогда
                        // месяц прописью на втором месте - на первом день
                        Месяц = Мес[МассивДаты[1]];
                        День = МассивДаты[0];
                        Год = Год(ТекущаяДата());
                    иначеесли isset(Мес[МассивДаты[0]])  тогда
                        Месяц = Мес[МассивДаты[0]];
                        День = МассивДаты[1];
                        Год = Год(ТекущаяДата());
                    иначе // месяц числом без года
                        Год = Год(ТекущаяДата());
                        Месяц = МассивДаты[0];
                        День = МассивДаты[1];
                    КонецЕсли;
                конецесли;
             конецесли;
            иначеесли Месяц<>Неопределено тогда
                // Месяц прописью - ищем день и год в ЧислаХ
                День = ЧислаХ[0];
                если ЧислаХ.Количество()>1 тогда
                    Год = ЧислаХ[1];
                иначе
                    Год = Год(ТекущаяДата());
                конецесли;
            иначе // День месяц и годв числаХ
                КвоЧисел =  ЧислаХ.Количество();
                если КвоЧисел>2 тогда
                    // Год месяц день - хотя такого недолжно быть
                    Год = ЧислаХ[0];
                    Месяц = ЧислаХ[1];
                    День = ЧислаХ[2];
                иначеесли КвоЧисел>1 тогда
                    // Год опущен Месяц - день
                    Год = Год(ТекущаяДата());
                    Месяц = ЧислаХ[0];
                    День = ЧислаХ[1];
                иначеесли КвоЧисел>0 тогда
                    // Опущен год и месяц - тоже не должно быть
                    День = ЧислаХ[0];
                    Год = Год(ТекущаяДата());
                    Месяц = Месяц(ТекущаяДата());
                иначе
                    // Опущена вся дата
                    День = День(ТекущаяДата());
                    Год = Год(ТекущаяДата());
                    Месяц = Месяц(ТекущаяДата());
                конецесли;
            КонецЕсли;

            // Теперь время
            если БлокВремени<>Неопределено тогда
                БлокВремени = СтрЗаменить(БлокВремени, "z", "");
                БлокВремени = СтрЗаменить(БлокВремени, "gmt", "");
                БлокВремени = СтрЗаменить(БлокВремени, "utc", "");

                МассивВремени = split(":",БлокВремени,3);
                КвоЭлементов = МассивВремени.Количество();
                если КвоЭлементов>2 тогда
                    // часы минуты секунды
                    Часов = МассивВремени[0];
                    СекТекст = Сред(МассивВремени[2],3,4);
                    если Найти(СекТекст,"am")>0 или Найти(СекТекст,"a.m.")>0 тогда
                        Часов = ?(Число(Часов)=12, 0, Число(Часов));
                    иначеесли Найти(СекТекст,"pm")>0 или Найти(СекТекст,"p.m.")>0 тогда
                        Часов = ?(Число(Часов)=12, 12, Число(Часов)+12);
                    конецесли;
                        Минут = МассивВремени[1];
                        Секунд = Лев(МассивВремени[2],2);

                иначеесли КвоЭлементов>1 тогда
                    Часов =  МассивВремени[0];
                    СекТекст = Сред(МассивВремени[1],3,4);
                    если Найти(СекТекст,"am")>0 или Найти(СекТекст,"a.m.")>0 тогда
                        Часов = ?(Число(Часов)=12, 0, Число(Часов));
                    иначеесли Найти(СекТекст,"pm")>0 или Найти(СекТекст,"p.m.")>0 тогда
                        Часов = ?(Число(Часов)=12, 12, Число(Часов)+12);
                    конецесли;
                    Минут = Лев(МассивВремени[1],2);
                    Секунд = 0;
                иначе
                    // только часы - не может быть, но пробуем
                    Часов = МассивВремени[0];
                    Минут = 0;
                    Секунд = 0;
                конецесли;
            иначе
                // время опущено - ставим 0
                Часов = 0;
                Минут = 0;
                Секунд = 0;

            конецесли;

            // Теперь часовой пояс
            ЧасовойПояс = СтрЗаменить(ЧасовойПояс,"gmt","");
            ЧасовойПояс = СтрЗаменить(ЧасовойПояс,"utc","");
            ЧасовойПояс = СтрЗаменить(ЧасовойПояс,"z","");
            ЧасовойПояс = СтрЗаменить(ЧасовойПояс,":","");
            Если СтрДлина(ЧасовойПояс)<5 тогда
                // неизвестный формат пояса
                ДобавкаЧасов = 0;
                ДобавкаМинут = 0;
            иначе
                если Лев(ЧасовойПояс,1)="+" тогда
                    ЗнакДобавки = 1;
                иначеесли Лев(ЧасовойПояс,1)="-" тогда
                    ЗнакДобавки = -1;
                иначе
                    // неверный формат добавки
                    ДобавкаЧасов = 0;
                    ДобавкаМинут = 0;
                конецесли;
                ДобавкаЧасов = Число(Сред(ЧасовойПояс,2,2))*ЗнакДобавки;
                ДобавкаМинут = Число(Сред(ЧасовойПояс,4,2))*ЗнакДобавки;
            конецесли;

            если Число(год)<=68 тогда
                Год = Число(Год) + 2000;
            иначеесли Число(год)<100 тогда
                Год = Число(Год) + 1900;
            конецесли;
            ДатаЗнч = Дата(Год,Месяц,День,Часов,Минут,Секунд);
            ДатаЗнч = ДатаЗнч + (ДобавкаМинут*60 + ДобавкаЧасов*60*60);
            возврат ДатаЗнч;

    //where:
    //   YYYY = four-digit year
    //   MM   = two-digit month (01=January, etc.)
    //   DD   = two-digit day of month (01 through 31)
    //   hh   = two digits of hour (00 through 23) (am/pm NOT allowed)
    //   mm   = two digits of minute (00 through 59)
    //   ss   = two digits of second (00 through 59)
    //   s    = one or more digits representing a decimal fraction of a second
    //   TZD  = time zone designator (Z or +hh:mm or -hh:mm)

    //This profile does not specify how many digits may be used to represent the decimal fraction of a second. An adopting standard that permits fractions of a second must specify both the minimum number of digits (a number greater than or equal to one) and the maximum number of digits (the maximum may be stated to be "unlimited").

    //This profile defines two ways of handling time zone offsets:
    //Times are expressed in UTC (Coordinated Universal Time), with a special UTC designator ("Z").
    //Times are expressed in local time, together with a time zone offset in hours and minutes. A time zone offset of "+hh:mm" indicates that the date/time uses a local time zone which is "hh" hours and "mm" minutes ahead of UTC. A time zone offset of "-hh:mm" indicates that the date/time uses a local time zone which is "hh" hours and "mm" minutes behind UTC.

    //A standard referencing this profile should permit one or both of these ways of handling time zone offsets.
конецесли;
 возврат неопределено;
КонецФункции

Функция split(СимволыРазделители, строка, лимит = неопределено) экспорт

МассивСлов = новый Массив;
ИщемНачало = истина;
ТекСлово = "";

Для НомерСимволаСтроки=1 по СтрДлина(Строка) цикл
    ТекСимвол =  Сред(Строка,НомерСимволаСтроки,1);
    если Найти(СимволыРазделители, ТекСимвол)=0  тогда
        ТекСлово = ТекСлово + ТекСимвол;
        ИщемНачало = ложь;
        продолжить;
    иначеесли ИщемНачало тогда
        МассивСлов.Добавить("");
        если МассивСлов.Количество()=лимит тогда
            возврат МассивСлов;
        конецесли;
        продолжить;
    иначе
        МассивСлов.Добавить(ТекСлово);
        если МассивСлов.Количество()=лимит тогда
            возврат МассивСлов;
        конецесли;
        ТекСлово = "";
        ИщемНачало = истина;
    конецесли;
конеццикла;
если Не ИщемНачало тогда
    МассивСлов.Добавить(ТекСлово);
конецесли;
возврат МассивСлов;
конецфункции

Функция isset(Парам)
    возврат ?(Парам=неопределено, ложь,истина);
конецфункции

Функция ПроверкаЧисло(Чс)
    попытка
        Ло = Число(Чс);
    исключение
        возврат неопределено;
    конецпопытки;
    возврат Ло;
КонецФункции

#КонецОбласти 
//СтрокаВДату

#КонецОбласти 
// Даты

#Область ДеревоЗначений
# Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда

// Дополнительный конструктор дерева значений
// Создает таблицу значений по переданной таблице значений, дереву значений
// или строке описания колонок. 
// Строка описания колонок должна содержать имена колонок, разделенные запятыми.
//
Функция ДеревоЗначений_Создать(ОписаниеКолонок) Экспорт
	
	//Для отладки
	Если Ложь Тогда
		ОписаниеКолонок = Новый ТаблицаЗначений;
	КонецЕсли;
	
	МассивДопустимыхТипов = Новый Массив;
	МассивДопустимыхТипов.Добавить(Тип("ДеревоЗначений"));
	МассивДопустимыхТипов.Добавить(Тип("ТаблицаЗначений"));
	МассивДопустимыхТипов.Добавить(Тип("Строка"));
	
	Проверка_Тип(ОписаниеКолонок, Новый ОписаниеТипов(МассивДопустимыхТипов));
	
	ДеревоЗначенийРезультат = Новый ДеревоЗначений;
	
	Если ТипЗнч(ОписаниеКолонок) = Тип("Строка") Тогда
		МассивИменКолонок = СтрРазделить(ОписаниеКолонок,",");
		
		Для Каждого ИмяКолонки Из МассивИменКолонок Цикл
			Попытка
				ДеревоЗначенийРезультат.Колонки.Добавить(СокрЛП(ИмяКолонки));
			Исключение
			КонецПопытки;
		КонецЦикла;
		
	Иначе
		Для Каждого ИсходнаяКолонка Из ОписаниеКолонок.Колонки Цикл
			ДеревоЗначенийРезультат.Колонки.Добавить(ИсходнаяКолонка.Имя, ИсходнаяКолонка.ТипЗначения, ИсходнаяКолонка.Заголовок, ИсходнаяКолонка.Ширина);
		КонецЦикла;
		ИсходнаяКолонка = Неопределено;
	КонецЕсли;
		
	Возврат ДеревоЗначенийРезультат;
	
КонецФункции
	
// Функция проверяет, находиться ли строка дерева в иерархии
// Другой строки
// 
//	Параметры:
//		Потомок - обязательный
//				строка дерева значенией;
//				строка, принадлежность которой надо проверить
//		Предок - Обязательный
//				Строка дерева значений;
//				Предполагаемый родитель;
//
//	Возвращает:
//		Истина - Если потомок находиться в иерархиии предка
//		Ложь - В противном склучае
//
Функция ДеревоЗначений_СтрокаДереваПринадлежитСтроке(Потомок,Предок) Экспорт
	
	// Если потомок не имеет предков, возвращаем ложь
	Если Потомок.Родитель = Неопределено Тогда
		Возврат Ложь;
		
	// Если предок является родителем потомка вернем истина
	ИначеЕсли  Потомок.Родитель = Предок Тогда
		Возврат Истина;
		
	// Иначе рекурсивно проверим родителя
	Иначе 
		Возврат ДеревоЗначений_СтрокаДереваПринадлежитСтроке(Потомок.Родитель,Предок);
	КонецЕсли;
	
КонецФункции

// Функция для преобазования дерева значений в таблицу значений
// Для работы процедуры, необходимо чтобы в таблице были колонки "Родитель" и "ГУИД"
//
// Параметры: 
//	Дерево - обязательный, дерево значений, исходное дерево
//	Таблица - обязательный, таблица значений, таблица результата
//	ГУИД - необязательный, уникальный идентификатор. Нужен для обеспечения рекурсии
//			в коде параметр не заполнять
//
// Возвращает:
//	Таблица значений, преобразованная из дерева значений
//
Функция ДеревоЗначений_ВТаблицуЗначений_Рекурсия(ДеревоЗначенийИсточник, ТаблицаЗначенийПриемник = Неопределено, Знач ГУИД = Неопределено)
	
	// Для отладки
	Если Ложь Тогда
		ДеревоЗначенийИсточник = Новый ДеревоЗначений;
		ТаблицаЗначенийПриемник = Новый ТаблицаЗначений;
	КонецЕсли;
	
	Если ГУИД = Неопределено Тогда
		Проверка_Тип(ДеревоЗначенийИсточник, Тип("ДеревоЗначений"));
		
		Если ТаблицаЗначенийПриемник = Неопределено Тогда
			ТаблицаЗначенийПриемник = ТаблицаЗначений_Создать(ДеревоЗначенийИсточник);
			ТаблицаЗначенийПриемник.Колонки.Добавить("Родитель", Новый ОписаниеТипов("УникальныйИдентификатор"));
			ТаблицаЗначенийПриемник.Колонки.Добавить("ГУИД", Новый ОписаниеТипов("УникальныйИдентификатор"));
		КонецЕсли;
		
		Проверка_Тип(ТаблицаЗначенийПриемник, Тип("ТаблицаЗначений"));
		ГУИД = Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000");
	КонецЕсли;
	
	Для Каждого СтрокаДерева Из ДеревоЗначенийИсточник.Строки Цикл
		СтрокаТаблицы = ТаблицаЗначенийПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, СтрокаДерева);
		СтрокаТаблицы.Родитель = ГУИД;
		СтрокаТаблицы.ГУИД = Новый УникальныйИдентификатор();
		
		Если СтрокаДерева.Строки.Количество()>0 Тогда
			ДеревоЗначений_ВТаблицуЗначений_Рекурсия(СтрокаДерева, ТаблицаЗначенийПриемник, СтрокаТаблицы.ГУИД);
		КонецЕсли;
	КонецЦикла;
	СтрокаДерева = Неопределено;
	
КонецФункции

#КонецЕсли // Не тонкий клиент и не Веб-клиент

#КонецОбласти
// ДеревоЗначений

#Область ДиаграммаГанта

// Процедура смещает интервалы диаграммы ганта, чтобы исключить их пересечение
// Параметры:
//		ВедущийИнтервал - 	Обязательный, ИнтервалДиаграммыГанта
//							Интрервал, относительно которого будут проверены все связанные
//							с ним интервалы.
//
Процедура ДиаграммаГанта_РекурсивноИсправитьИнтервалы(ВедущийИнтервал) Экспорт
	
	Для Каждого Связь Из ВедущийИнтервал Цикл
		НачалоСвязи = Связь.Начало;
		КонецСвязи = Связь.Конец;
		
		// Наш интервал источник связи
		Если НачалоСвязи.Значение = ВедущийИнтервал.Значение Тогда
			ИсточникСвязи = ВедущийИнтервал;
			ПриемникСвязи = КонецСвязи;
			ВедомыйИнтервал = ПриемникСвязи;
			Направление = 1;
			
		// Наш интервал приемник связи	
		ИначеЕсли КонецСвязи.Значение = ВедущийИнтервал.Значение Тогда
			ИсточникСвязи = НачалоСвязи;
			ПриемникСвязи = ВедущийИнтервал;
			ВедомыйИнтервал = ИсточникСвязи;
			Направление = -1;			
			
		// Исключительная ситуация, прервать выполнение	
		Иначе 
			Продолжить;
		КонецЕсли;
		
		// Вычисляем смещение (пересечение интервалов)
		// Если Пересечение меньше либо равно нуля, прерываем
		Смещение = ИсточникСвязи.Конец-ПриемникСвязи.Начало;
		Если Смещение <= 0 Тогда 
			Продолжить;
		КонецЕсли;
		
		// Применяем к ведомому смещение со знаком;
		ВедомыйИнтервал.Начало = ВедомыйИнтервал.Начало+Смещение*Направление;
		ВедомыйИнтервал.Конец = ВедомыйИнтервал.Конец+Смещение*Направление;
		
		// Позовем рекурсивно процедуру
		ДиаграммаГанта_РекурсивноИсправитьИнтервалы(ВедомыйИнтервал);
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти 
//ДиаграммаГанта

#Область Документы

// Функция Документ_ЕстьРеквизит(ИмяРеквизита, МетаданныеДокумента)
Функция Документ_ЕстьРеквизит(ИмяРеквизита, МетаданныеДокумента) Экспорт
	
	Если МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) <> Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	Для Каждого СтандартныйРеквизит Из МетаданныеДокумента.СтандартныеРеквизиты Цикл
		Если СтандартныйРеквизит.Имя = ИмяРеквизита Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	СтандартныйРеквизит = Неопределено;
	
	Возврат Ложь;

КонецФункции 

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
Функция Документ_Обработать(ДокументСсылка, ВидОбработки) Экспорт
	
	// Проверить вид обработки
	Если Не Документы_ВидОбработки_Проверить(ВидОбработки) Тогда
		Возврат "";
		
	КонецЕсли;
	
	// Проверить корневой тип конфигурации, чтобы это был документ
	КорневойТипКонфигурации = КорневойТипКонфигурации_Получить(ДокументСсылка);
	
	// Если это не документ, тогда сообщить об этом
	Если КорневойТипКонфигурации <> "Документ" Тогда
		Возврат 
			СтрШаблон(
				"""%1"" не является ссылкой на документ",
				ДокументСсылка
				);
		
	КонецЕсли;
	
	// Далее выполняем все через попытку
	Попытка
		
		// Получить объект документа
		ДокументОбъект = ДокументСсылка.ПолучитьОбъект();
		
		// Проверить вид обработки
		Если ВидОбработки = "Проведение" Тогда
			ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
			
		ИначеЕсли ВидОбработки = "ОтменаПроведения" Тогда
			ДокументОбъект.Записать(РежимЗаписиДокумента.ОтменаПроведения);
			
		ИначеЕсли ВидОбработки = "УстановитьПометкуУдаления" Тогда
			ДокументОбъект.УстановитьПометкуУдаления(Истина);
			ДокументОбъект.Записать(РежимЗаписиДокумента.Запись);
			
		ИначеЕсли ВидОбработки = "СнятьПометкуУдаления" Тогда
			ДокументОбъект.УстановитьПометкуУдаления(Ложь);
			ДокументОбъект.Записать(РежимЗаписиДокумента.Запись);
			
		КонецЕсли;

	Исключение
		// Вернуть описание ошибки при проведении документа
		Возврат
			СтрШаблон(
				"Ошибка при обработке документа ""%1"" по причине:
				|%2",
				ДокументСсылка,
				ОписаниеОшибки()
				);
		
	КонецПопытки;

	// Если все хорошо, вернуть пустую строку
	Возврат "";
	
КонецФункции
#КонецЕсли // #Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда

// Процедура для изменения состояния реквизитов типа "Булево" на противоположное
// Можно передавать ссылку или объект. Если передан объект, то реквизит будет изменен,
// но объект записан не будет. Если передана ссылка, будет получен объет, изменен реквизит,
// а затем объет будет записан.
//
// Параметры:
//		ДокументСсылка - обязательный, ссылка на документ или объект документа;
//		ИмяРеквизита - обязательный, строка, имя документа как оно задано в конфигураторе
//
// 20120416 Заяш
//
Процедура Документ_ПереключитьРеквизит(Документ,ИмяРеквизита) Экспорт
	
	ЭтоОбъект = Не(Документ=Документ.Ссылка);
	
	Попытка
		Если ЭтоОбъект Тогда
			ДокументОбъект = Документ;
		Иначе
			ДокументОбъект = Документ.ПолучитьОбъект();
		КонецЕсли;
		ДокументОбъект[ИмяРеквизита] = Не ДокументОбъект[ИмяРеквизита];
		Если Не ЭтоОбъект Тогда
			ДокументОбъект.Записать();
		КонецЕсли;
	Исключение
		стрСообщение = 
			СтрШаблон(
				"Не удалось изменить реквизит ""%1""
				|для документа %2
				|по причине: %3",
				ИмяРеквизита,
				Документ.Ссылка,
				ОписаниеОшибки()
				);
		СообщитьОбОшибке(стрСообщение,,,СтатусСообщения.Важное);	
	КонецПопытки;
	
КонецПроцедуры

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция предназначена для получения даты документа, записанной в БД
// Используется, например, когда нужно сравнить дату отредактированного документа
// с датой базы данных.
//
// Параметры:
//		Документ - обязательный, ДокументОбъект или ДокументСсылка
//
// 20120723 Заяш
//
Функция Документ_ПолучитьДатуИзБД(Документ) Экспорт
	
	// Если документ еще не записан, вернем пустую дату
	Если Не ЗначениеЗаполнено(Документ.Ссылка) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ 
	|Дата 
	|ИЗ Документ." + Документ.Метаданные().Имя + "
	|ГДЕ Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Документ.Ссылка);
	Выборка = Запрос.Выполнить().Выбрать();

	Если Выборка.Следующий() Тогда
		Возврат Выборка.Дата;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
		

КонецФункции
#КонецЕсли // Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция предназначена для получения реквизита документа, записанного в БД
// Используется, например, когда нужно сравнить значение реквизита отредактированного документа
// со значением реквизита в базе данных данных.
//
// Параметры:
//		Документ - обязательный, ДокументОбъект или ДокументСсылка
//		Имяреквизита — обязательный, строка
//
// 20151228 Заяш
//
Функция Документ_ПолучитьРеквизитИзБД(Документ, ИмяРеквизита = "") Экспорт
	
	// Если документ еще не записан, вернем пустую дату
	Если Не ЗначениеЗаполнено(Документ.Ссылка) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Проверка_Тип(ИмяРеквизита, Тип("Строка"));
	
	// Если имя реквизита не заполнено, вернем неопределено
	Если ПустаяСтрока(ИмяРеквизита) Тогда 
		Возврат Неопределено;
	КонецЕсли;
	
	// Если у документа нет реквизита, вернем неопределено
	Если Не Документ_ЕстьРеквизит(ИмяРеквизита, Документ.Метаданные()) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ 
	|"+ИмяРеквизита+" КАК ЗначениеРеквизита 
	|ИЗ Документ." + Документ.Метаданные().Имя + "
	|ГДЕ Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Документ.Ссылка);
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ЗначениеРеквизита;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции
#КонецЕсли // Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент

// Проверяет правильность заполнения шапки документа.
// 
// Если какой-то из реквизтов шапки, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  ДокументОбъект             - объект проводимого документа, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура Документ_ПроверитьЗаполнениеШапки(ДокументОбъект, СтруктураОбязательныхПолей, Отказ, Заголовок) Экспорт
	
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;
	СообщениеОбОшибке = "";
	Таб = Символы.Таб+Символы.Таб;
	
	Для Каждого  КлючЗначение Из СтруктураОбязательныхПолей Цикл

		Значение = ДокументОбъект[КлючЗначение.Ключ];
		Если ЗначениеНеЗаполнено(Значение) Тогда // надо ругаться

			Если ЗначениеНеЗаполнено(КлючЗначение.Значение) Тогда //стандартное ругательство
				ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
			Иначе
				ПредставлениеРеквизита = КлючЗначение.Значение;
			КонецЕсли;
			СообщениеОбОшибке 
				= СообщениеОбОшибке+Таб+Таб+""""+ СокрЛП(ПредставлениеРеквизита)+ """;"+Символы.ПС;
		КонецЕсли;

	КонецЦикла;
	
	Если ЗначениеЗаполнено(СообщениеОбОшибке) Тогда
		
		СообщениеОбОшибке 
			= " не заполнены значения реквизитов:"+Символы.ПС+СообщениеОбОшибке;
		
		СообщитьОбОшибке
				(СообщениеОбОшибке,Отказ,Заголовок);
			
	КонецЕсли;

КонецПроцедуры // Документ_ПроверитьЗаполнениеШапки()

Функция Документы_ВидыОбработки()
	
	ВидыОбработки = Новый Структура;
	
	ВидыОбработки.Вставить("Проведение", "Проведение"); 
	ВидыОбработки.Вставить("ОтменаПроведения", "ОтменаПроведения"); 
	ВидыОбработки.Вставить("УстановитьПометкуУдаления", "УстановитьПометкуУдаления"); 
	ВидыОбработки.Вставить("СнятьПометкуУдаления", "СнятьПометкуУдаления"); 
	
	Возврат ВидыОбработки;
	
КонецФункции

Функция Документы_ВидОбработки_Представление_Получить(ВидОбработки) Экспорт
	
	// Проверить вид обработки
	Если ВидОбработки = "Проведение" Тогда
		Возврат "Проведение";
		
	ИначеЕсли ВидОбработки = "ОтменаПроведения" Тогда
		Возврат "Отмена проведения";
		
	ИначеЕсли ВидОбработки = "УстановитьПометкуУдаления" Тогда
		Возврат "Пометка на удаление";
		
	ИначеЕсли ВидОбработки = "СнятьПометкуУдаления" Тогда
		Возврат "Снятие пометки на удаление";
		
	Иначе
		Возврат "Обработка";
		
	КонецЕсли;
	
КонецФункции

Функция Документы_ВидОбработки_Проверить(ВидОбработки) Экспорт
	
	// Проверить вид обработки
	Если ВидОбработки = "Проведение" Тогда
		Возврат Истина;
		
	ИначеЕсли ВидОбработки = "ОтменаПроведения" Тогда
		Возврат Истина;
		
	ИначеЕсли ВидОбработки = "УстановитьПометкуУдаления" Тогда
		Возврат Истина;
		
	ИначеЕсли ВидОбработки = "СнятьПометкуУдаления" Тогда
		Возврат Истина;
		
	Иначе
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
Функция Документы_Массив_СортироватьПоДате(МассивСсылокДокументов, ЗНАЧ стрНаправлениеСортировки = "ВОЗР") Экспорт
	
	Проверка_Тип(МассивСсылокДокументов, "Массив");
	Проверка_Тип(стрНаправлениеСортировки, "Строка");
	
	стрНаправлениеСортировки = ВРЕГ(НаправлениеСортировки);
	
	Если стрНаправлениеСортировки = "ВОЗР" Тогда 
		// ОК
		
	ИначеЕсли стрНаправлениеСортировки = "УБЫВ" Тогда
		// ОК
		
	Иначе
		стрНаправлениеСортировки = "ВОЗР";
		
	КонецЕсли;
	
	ТаблицаДляСортировки = Новый ТаблицаЗначений;
	ТаблицаДляСортировки.Колонки.Добавить("Ссылка");
	ТаблицаДляСортировки.Колонки.Добавить("Дата", Новый ОписаниеТипов("Дата",,,Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя)));
	ТаблицаДляСортировки.Колонки.Добавить("МоментВремени", Новый ОписаниеТипов("МоментВремени"));
	
	СоответствиеСсылок = Новый Соответствие;
		
	Для Каждого ДокументСсылка Из МассивСсылокДокументов Цикл
		
		// Проверить что документ ссылка насамом деле является ссылкой на документ
		
		// Проверить корневой тип конфигурации, чтобы это был документ
		КорневойТипКонфигурации = КорневойТипКонфигурации_Получить(ДокументСсылка);
		
		// Если это не документ, тогда сообщить об этом
		Если КорневойТипКонфигурации <> "Документ" Тогда
			Продолжить;
			
		КонецЕсли;
		
		// Если Ссылка уже есть в соответствии, не нужно добавлять ее в таблицу еще раз
		ДокументСсылка_УжеДобавлено = Не СоответствиеСсылок.Получить(ДокументСсылка.Ссылка) = Неопределено;
		Если ДокументСсылка_УжеДобавлено Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаТаблицы = ТаблицаДляСортировки.Добавить();
		СтрокаТаблицы.Ссылка = ДокументСсылка.Ссылка;
		СтрокаТаблицы.Дата = ДокументСсылка.Дата;
		СтрокаТаблицы.МоментВремени = ДокументСсылка.МоментВремени();
		
		// Добавить ссылку в соответствие
		СоответствиеСсылок.Вставить(ДокументСсылка.Ссылка, ДокументСсылка.Ссылка);
		
	КонецЦикла;
	
	ТаблицаДляСортировки.Сортировать(
		СтрШаблон(
			"Дата %1, МоментВремени %1",
			стрНаправлениеСортировки
			)
		);
		
	МассивНаВозврат = ТаблицаДляСортировки.ВыгрузитьКолонку("Ссылка");
	
	Проверка_Тип(МассивНаВозврат, "Массив");
		
	Возврат МассивНаВозврат;
	
КонецФункции
#КонецЕсли // #Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда

Процедура Документы_ОбработатьУведомитьПользователя(массивСсылокДокументовКОбработке, ВидОбработки, УведомитьОРезультате = Ложь) Экспорт
	
	// Проверить вид обработки
	Если Не Документы_ВидОбработки_Проверить(ВидОбработки) Тогда
		Возврат;
		
	КонецЕсли;
	
	// Сортировать массив документов
	массивСсылокДокументовКОбработке = 
		общ_Сервер.Документы_Массив_СортироватьПоДате(
			массивСсылокДокументовКОбработке, 
	       	?(ВидОбработки = "ОтменаПроведения", "Убыв", "Возр")
			);
	
	ВсегоДокументов = массивСсылокДокументовКОбработке.Количество();
	ОбработаноДокументов = 0;
	КоличествоОшибок = 0;
	стрРезультатПроведения = "";
	
	Для Каждого ДокументСсылка Из массивСсылокДокументовКОбработке Цикл
		
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли
		
		// Сбросить описание ошибки
		стрОписаниеОшибки = "";

		стрОписаниеОшибки = общ_Сервер.Документ_Обработать(ДокументСсылка, ВидОбработки);
		
		Если ЗначениеЗаполнено(стрОписаниеОшибки) Тогда
			Сообщить(стрОписаниеОшибки);
			
		КонецЕсли;
		
		ОбработаноДокументов = ОбработаноДокументов + 1;
		
		стрРезультатПроведения = 
			СтрШаблон(
				"%1: %2 из %3 документов.%4",
				Документы_ВидОбработки_Представление_Получить(ВидОбработки),
				ОбработаноДокументов, // %2
				ВсегоДокументов, // %3
				?(КоличествоОшибок = 0, "", " Ошибок " + КоличествоОшибок) // %4
				);
				
		#Если Клиент Тогда
		Состояние(стрРезультатПроведения);
		#КонецЕсли

	КонецЦикла;
	ДокументСсылка = Неопределено;
	
	// Сообщить результат проведения
	Если ЗначениеЗаполнено(стрРезультатПроведения) И УведомитьОРезультате Тогда
		Сообщить(стрРезультатПроведения);
	КонецЕсли;
	
КонецПроцедуры

#Если Клиент Тогда
Процедура Документы_ПровестиУведомитьПользователя(массивСсылокДокументовКПроведению) Экспорт 
	
	Документы_ОбработатьУведомитьПользователя(
		массивСсылокДокументовКПроведению,
		Документы_ВидыОбработки().Проведение
		);
	
КонецПроцедуры
#КонецЕсли // Если Клиент

Функция ДокументТабличнаяЧасть_ЕстьРеквизит(ИмяТабличнойЧасти,ИмяРеквизита, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции

// Процедура ДокументТабличнаяЧасть_ПроверитьЗаполнение
// 
// Проверяет правильность заполнения строк табличной части документа.
// Если какой-то из реквизтов, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
//
// Параметры:
//  ДокументОбъект             - объект проводимого документа, 
//  ИмяТабличнойЧасти          - табличная часть документа,
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ДокументТабличнаяЧасть_ПроверитьЗаполнение
			(
			ДокументОбъект, 
			ИмяТабличнойЧасти, 
			СтруктураОбязательныхПолей, 
            Отказ,
			знач Заголовок
							) Экспорт

	ПредставлениеТабличнойЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление();
	ТабличнаяЧасть = ДокументОбъект[ИмяТабличнойЧасти];
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты;
	СообщениеОбОшибке = "";
	ОшибкиВСтроке ="";
	Таб = Символы.Таб+Символы.Таб;

	// Цикл по строкам табличной части.
	Для Каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
		
		// Цикл по проверяемым полям
		Для Каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

			Значение = СтрокаТаблицы[КлючЗначение.Ключ];
			Если НЕ ЗначениеЗаполнено(Значение) Тогда // надо ругаться
				
				Если Не ЗначениеЗаполнено(КлючЗначение.Значение) Тогда //стандартное ругательство
					ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
				Иначе
					ПредставлениеРеквизита = КлючЗначение.Значение;
				КонецЕсли;
				ОшибкиВСтроке = ОшибкиВСтроке +	""""+ СокрЛП(ПредставлениеРеквизита)+"""; ";
			КонецЕсли;
			
		КонецЦикла;
		
		// Если в строке обнаружены ошибки - дописать их к сообщению
		Если ЗначениеЗаполнено(ОшибкиВСтроке) Тогда
			СообщениеОбОшибке = 
					СообщениеОбОшибке + Таб +
					"В строке "+ СтрокаТаблицы.НомерСтроки + ": "+ОшибкиВСтроке+Символы.ПС;
			ОшибкиВСтроке = "";
		КонецЕсли;

	КонецЦикла;
	
	Если ЗначениеЗаполнено(СообщениеОбОшибке) Тогда;
		СообщениеОбОшибке 
			= "Не заполнены реквизиты в табличной части "
			+ """"+ПредставлениеТабличнойЧасти+""":"+Символы.ПС
			+ СообщениеОбОшибке;
		СообщитьОбОшибке(СообщениеОбОшибке,Отказ,Заголовок);
	КонецЕсли;

КонецПроцедуры 

// Процедура ДокументТабличнаяЧасть_ПроверитьЗаполнениеСтроки
//
//Проверяет правильность заполнения строки табличной части документа.
// Если какой-то из реквизтов, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
//
// Параметры:
//  ДокументОбъект             - объект проводимого документа, 
//  ИмяТабличнойЧасти          - табличная часть документа,
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  СтрокаТаблицы			   - строка табличной части, которую необходимо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ДокументТабличнаяЧасть_ПроверитьЗаполнениеСтроки
				(	
				ДокументОбъект, 
				ИмяТабличнойЧасти, 
				СтруктураОбязательныхПолей,
				СтрокаТаблицы, 
                Отказ, 
				Заголовок
																) Экспорт

	ПредставлениеТабличнойЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление();
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты;
	СтрокаСообщения = "";
	
	// Цикл по проверяемым полям
	Для Каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл
		Значение = СтрокаТаблицы[КлючЗначение.Ключ];
		Если Не ЗначениеЗаполнено(Значение) Тогда // надо ругаться
			Если ЗначениеНеЗаполнено(КлючЗначение.Значение) Тогда //стандартное ругательство
				ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
				СтрокаСообщения  
					= СтрокаСообщения
					+ Символы.Таб
					+ Символы.Таб 
					+ СокрЛП(ПредставлениеРеквизита) 
					+ Символы.ПС;
			Иначе
				СтрокаСообщения = СтрокаСообщения + КлючЗначение.Значение;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Если были ошибки, надо предупредить о них
	Если ЗначениеЗаполнено(СтрокаСообщения) Тогда
		ОшибкаПриПроведении
			(
			"В строке """	+ СокрЛП(СтрокаТаблицы.НомерСтроки)	
			+ """ табличной части """ + ПредставлениеТабличнойЧасти 
			+ """ не заполнены реквизиты"+Символы.ПС
			+ СтрокаСообщения, 
			Отказ, 
			Заголовок
			);
		
	КонецЕсли;
													
КонецПроцедуры 

#КонецОбласти 
//Документы

#Область ИнформационнаяБаза

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
Функция ЕстьПравоАдминистрирования() Экспорт
	
	Возврат ПравоДоступа("Администрирование",Метаданные);
	
КонецФункции
#КонецЕсли

#Если Не МобильноеПриложениеСервер Тогда
// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
// Взята из модуля "ОбщегоНазанчения" БСП 1.0.7.5
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции
#КонецЕсли // Не МобильноеПриложениеСервер

// Получить представление информационной базы для отображения пользователю.
//
// Возвращаемое значение:
//   Строка      - Представление информационной базы
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
//
#Если Не МобильноеПриложениеСервер Тогда
Функция ИнформационнаяБаза_ПолучитьПредставление() Экспорт
	
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		ПутьКБД = Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	Иначе
		// надо к имени сервера прибавить имя пути информационной базы
		ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "SRVR=");
		
		Если ПозицияПоиска <> 1 Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
		НачальнаяПозицияКопирования = 6 + 1;
		КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
		
		ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
		
		СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
		
		// позиция имени сервера
		ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "REF=");
		
		Если ПозицияПоиска <> 1 Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		НачальнаяПозицияКопирования = 6;
		ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
		КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
		
		ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
		
		ПутьКБД = ИмяСервера + "/" + ИмяИБНаСервере;
		
	КонецЕсли;
	
	Возврат ПутьКБД;
	
КонецФункции
#КонецЕсли // Не МобильноеПриложениеСервер

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент И Не МобильноеПриложениеСервер Тогда
// Процедура включает и отключает использование итогов для всех типов регистров
//
// Параметры:
//  ИспользованиеИтогов  - Булево - Истина по умолчанию. Признак, который будет установлен использованию итогов.
//
Процедура Итоги_УстановитьИспользование(ИспользованиеИтогов = Истина) Экспорт
	
	
	Для Каждого метРег Из Метаданные.РегистрыБухгалтерии Цикл
		#Если Клиент Тогда
		Состояние(метРег.Имя);
		#КонецЕсли
		РегистрыБухгалтерии[метРег.Имя].УстановитьИспользованиеИтогов(ИспользованиеИтогов);
	КонецЦикла;
	Для Каждого метРег Из Метаданные.РегистрыНакопления Цикл
		#Если Клиент Тогда
		Состояние(метРег.Имя);
		#КонецЕсли
		РегистрыНакопления[метРег.Имя].УстановитьИспользованиеИтогов(ИспользованиеИтогов);
	КонецЦикла;
	Для Каждого метРег Из Метаданные.РегистрыСведений Цикл
		#Если Клиент Тогда
		Состояние(метРег.Имя);
		#КонецЕсли
		РегистрыСведений[метРег.Имя].УстановитьИспользованиеИтогов(ИспользованиеИтогов);
	КонецЦикла;
	
КонецПроцедуры // Итоги_УстановитьИспользование()
#КонецЕсли

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент И Не МобильноеПриложениеСервер Тогда
// Процедура пересчитывает итоги регистров накопления и бухгалтерии
// 
Процедура Итоги_Пересчитать() Экспорт
	
	
	Для Каждого Рег из Метаданные.РегистрыНакопления Цикл
		Если Рег.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
			Сообщить(Рег.Имя);
			РегистрыНакопления[Рег.Имя].ПересчитатьТекущиеИтоги();
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Рег из Метаданные.РегистрыБухгалтерии Цикл
		Сообщить(Рег.Имя);
		РегистрыБухгалтерии[Рег.Имя].ПересчитатьТекущиеИтоги();
	КонецЦикла;
	
КонецПроцедуры // Итоги_УстановитьИспользование()
#КонецЕсли

// 20180920 Заяш 
Функция ТекущийПользователь_РольДоступна(ИмяРоли) Экспорт
	
	Возврат общ_кэш.ТекущийПользователь_РольДоступна(ИмяРоли);
	
КонецФункции

Функция ТекущееСоединение_ИмяПриложения_Получить() Экспорт
	
	Возврат общ_кэш.ТекущееСоединение_ИмяПриложения_Получить();
	
КонецФункции // ТекущееСоединение_ИмяПриложения_Получить

Функция ТекущийСеанс_ИмяПриложения_Получить() Экспорт
	
	Возврат общ_кэш.ТекущийСеанс_ИмяПриложения_Получить();
	
КонецФункции // ТекущийСеанс_ИмяПриложения_Получить

Функция ТекущийСеанс_ЭтоМобильныйКлиент() Экспорт
	
	Возврат общ_кэш.ТекущийСеанс_ЭтоМобильныйКлиент()
	
КонецФункции // ТекущийСеанс_ЭтоМобильныйКлиент

#Если Клиент Тогда
Процедура ОчиститьКэш() Экспорт 
   
   Текст = "Ваш сеанс работы с 1С будет перезапущен, все несохраненные данные при этом будут утеряны. Продолжить?";
   Ответ = Вопрос(Текст, РежимДиалогаВопрос.ОКОтмена,,КодВозвратаДиалога.Отмена, "Очистка кэша");
   
   Если Ответ = КодВозвратаДиалога.ОК Тогда 
      ПрекратитьРаботуСистемы(Истина, "/ClearCache");
   КонецЕсли;
   
КонецПроцедуры
#КонецЕсли

#КонецОбласти 
// Информационная база

#Область Справочники

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
	
// Функция возвращает массив вышестоящих групп указанного элемента.
//
// Параметры:
//  Элемент      - Элемент справочника, для которого ищется родитель
//
// Возвращаемое значение
//  Массив вышестоящих групп
//
Функция Справочник_ПолучитьМассивРодителей(ЭлементСправочника) Экспорт

	Результат = Новый Массив;

	Если НЕ ЗначениеЗаполнено(ЭлементСправочника) Тогда
		Возврат Результат;
	КонецЕсли;

	МетаданныеСправочника = ЭлементСправочника.Метаданные();
	Если НЕ МетаданныеСправочника.Иерархический Тогда
		Возврат Результат;
	КонецЕсли;
	ИмяСправочника = МетаданныеСправочника.Имя;
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Справочник1.Родитель КАК Родитель1,
	|	Справочник2.Родитель КАК Родитель2,
	|	Справочник3.Родитель КАК Родитель3,
	|	Справочник4.Родитель КАК Родитель4,
	|	Справочник5.Родитель КАК Родитель5
	|ИЗ
	|	Справочник." + ИмяСправочника + " КАК Справочник1
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник2
	|		ПО (Справочник2.Ссылка = Справочник1.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник3
	|		ПО (Справочник3.Ссылка = Справочник2.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник4
	|		ПО (Справочник4.Ссылка = Справочник3.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник5
	|		ПО (Справочник5.Ссылка = Справочник4.Родитель)
	|ГДЕ
	|	Справочник1.Ссылка = &Ссылка";

	ТекущийЭлемент = ЭлементСправочника;

	Пока ЗначениеЗаполнено(ТекущийЭлемент) Цикл
		Запрос.УстановитьПараметр("Ссылка", ТекущийЭлемент);
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			Для Индекс = 1 по 5 Цикл
				ТекущийЭлемент = Выборка["Родитель" + Индекс];
				Если ЗначениеЗаполнено(ТекущийЭлемент) Тогда
					Результат.Добавить(ТекущийЭлемент);
				Иначе
					Прервать;
				КонецЕсли;
			КонецЦикла;
		Иначе
			ТекущийЭлемент = Неопределено;
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции

// Функция возвращает массив вышестоящих групп указанного элемента.
//
// Параметры:
//  МассивЭлементовСправочника      - Массив элементов справочника, для которого ищются родители
//                                    Все элементы массива должны быть одного вида!
//
// Возвращаемое значение
//  Соответствие массивов вышестоящих групп
//
Функция Справочник_ПолучитьРодителейДляМассиваЭлементов(МассивЭлементовСправочника) Экспорт

	Результат = Новый Соответствие;
	
	Если МассивЭлементовСправочника.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	Для Каждого ЭлементСправочника Из МассивЭлементовСправочника Цикл
		Результат.Вставить(ЭлементСправочника, Новый Массив);
	КонецЦикла;
	
	МетаданныеСправочника = МассивЭлементовСправочника[0].Метаданные();
	Если НЕ МетаданныеСправочника.Иерархический Тогда
		Возврат Результат;
	КонецЕсли;
	
	ИмяСправочника = МетаданныеСправочника.Имя;
	
	Запрос = Новый Запрос;
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	Справочник1.Ссылка КАК Элемент,
	|	Справочник1.Родитель КАК Родитель1,
	|	Справочник2.Родитель КАК Родитель2,
	|	Справочник3.Родитель КАК Родитель3,
	|	Справочник4.Родитель КАК Родитель4,
	|	Справочник5.Родитель КАК Родитель5
	|ИЗ
	|	Справочник.Номенклатура КАК Справочник1
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Номенклатура КАК Справочник2
	|		ПО (Справочник2.Ссылка = Справочник1.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Номенклатура КАК Справочник3
	|		ПО (Справочник3.Ссылка = Справочник2.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Номенклатура КАК Справочник4
	|		ПО (Справочник4.Ссылка = Справочник3.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Номенклатура КАК Справочник5
	|		ПО (Справочник5.Ссылка = Справочник4.Родитель)
	|ГДЕ
	|	Справочник1.Ссылка В(&МассивСсылок)";
	
	Запрос.Текст = СтрЗаменить(ТекстЗапроса, "Номенклатура", ИмяСправочника);
	
	//	Таблица соответствия групп и элементов (начальной точки иерархии):
	//		Родитель - группа справочника
	//		Элемент - элемент справочника, для которого строится иерархия
	СоответствиеГруппИЭлементов = Новый ТаблицаЗначений;
	СоответствиеГруппИЭлементов.Колонки.Добавить("Родитель",	Новый ОписаниеТипов("СправочникСсылка." + ИмяСправочника));
	СоответствиеГруппИЭлементов.Колонки.Добавить("Элемент",		Новый ОписаниеТипов("СправочникСсылка." + ИмяСправочника));
	СоответствиеГруппИЭлементов.Индексы.Добавить("Родитель");
	Для Каждого ЭлементСправочника Из МассивЭлементовСправочника Цикл
		НовоеСоответствие = СоответствиеГруппИЭлементов.Добавить();
		НовоеСоответствие.Родитель	= ЭлементСправочника;
		НовоеСоответствие.Элемент	= ЭлементСправочника;
	КонецЦикла;
	
	Отбор	= Новый Структура("Родитель");
	
	ТекущийМассивСсылок = МассивЭлементовСправочника;
	
	Пока ТекущийМассивСсылок.Количество() > 0 Цикл
		
		Запрос.УстановитьПараметр("МассивСсылок", Массив_УдалитьПовторяющиесяЭлементы(ТекущийМассивСсылок));
		Выборка = Запрос.Выполнить().Выбрать();
		
		ТекущийМассивСсылок	= Новый Массив;
		
		Пока Выборка.Следующий() Цикл
			
			Отбор.Родитель = Выборка.Элемент;
			
			НайденныеСтроки = СоответствиеГруппИЭлементов.НайтиСтроки(Отбор);
			Для Каждого СоответствиеГруппыИЭлемента Из НайденныеСтроки Цикл
				
				ЭлементСправочника	= СоответствиеГруппыИЭлемента.Элемент;
				
				МассивВышеСтоящихГруп	= Результат.Получить(ЭлементСправочника);
				
				Для Индекс = 1 по 5 Цикл
					
					Родитель = Выборка["Родитель" + Индекс];
					Если ЗначениеЗаполнено(Родитель) Тогда
						
						МассивВышеСтоящихГруп.Добавить(Родитель);
						Если Индекс = 5 Тогда
							ТекущийМассивСсылок.Добавить(Родитель);
							НовоеСоответствие = СоответствиеГруппИЭлементов.Добавить();
							НовоеСоответствие.Родитель	= Родитель;
							НовоеСоответствие.Элемент	= ЭлементСправочника;
						КонецЕсли;
						
					Иначе
						Прервать;
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Результат;

КонецФункции

// Функция получает элемент справочника по коду 
// Если элемента нет в базе, то он создается и возвращается ссылка
//
// Параметры:
//  МетаданныеСправочника - Обязательный, ОбъектМетаданных. 
//		Метаданные спраочника, для которых нужно получитьэлемент
//
//	стрКодЭлемента — Обязательный, Строка. 
//		Код искомого элемента справочника
//
//	стрНаименованиеЭлемента — Необязательный, Строка. 
//		Наименование элемента. Если элемент создается, то ему будет присвоено это наименование
//
// Возвращаемое значение
//  СправочникСсылка
//	ИнформацияОбОшибке при неудачном завершении
//
Функция Справочник_ПолучитьСсылкуПоКодуЭлемента(
		МетаданныеСправочника, 
		Знач стрКодЭлемента, 
		стрНаименованиеЭлемента = ""
		) Экспорт
		
	Если стрКодЭлемента = Неопределено  ИЛИ ПустаяСтрока(стрКодЭлемента)Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Проверка_Тип(стрКодЭлемента, "Строка,Число");
	Проверка_Тип(МетаданныеСправочника, Тип("ОбъектМетаданных"));
	КорневойТипКонфигурации = КорневойТипКонфигурации_Получить(МетаданныеСправочника);
	Если 
			Не КорневойТипКонфигурации = "Справочник" 
		И 	Не КорневойТипКонфигурации = "ПланОбмена"
	Тогда
		ВызватьИсключение "Недопустимые метаданные. Должны быть метаданные справочника или плана обмена.";
	КонецЕсли;
	
	стрКодЭлемента = СокрЛП(стрКодЭлемента);
	
	Если Не ЗначениеЗаполнено(стрКодЭлемента) Тогда
		Возврат Неопределено;
	КонецЕсли;

	СсылкаНаЭлементСправочника = Неопределено;
	
	МенеджерСправочника = Менеджер_Получить(МетаданныеСправочника);
	
	СсылкаНаЭлементСправочника = МенеджерСправочника.НайтиПоКоду(стрКодЭлемента);
	
	Если Не ЗначениеЗаполнено(СсылкаНаЭлементСправочника) Тогда
		
		Если КорневойТипКонфигурации = "Справочник" Тогда
			ОбъектЭлементаСправочника = МенеджерСправочника.СоздатьЭлемент();
			
		ИначеЕсли КорневойТипКонфигурации = "ПланОбмена" Тогда
			ОбъектЭлементаСправочника = МенеджерСправочника.СоздатьУзел();
			
		КонецЕсли;

		ОбъектЭлементаСправочника.Код = стрКодЭлемента;
		
		Если Не ЗначениеЗаполнено(ОбъектЭлементаСправочника.Наименование) 
			И ЗначениеЗаполнено(стрНаименованиеЭлемента)
		Тогда
			ОбъектЭлементаСправочника.Наименование = стрНаименованиеЭлемента;
			
		Иначе
			ОбъектЭлементаСправочника.Наименование = стрКодЭлемента;
			
		КонецЕсли;
		
		Попытка
			ОбъектЭлементаСправочника.Записать();
			СсылкаНаЭлементСправочника = ОбъектЭлементаСправочника.Ссылка;
			ОбъектЭлементаСправочника = Неопределено;
			
		Исключение
			Возврат ИнформацияОбОшибке();
			
		КонецПопытки;
		
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(СсылкаНаЭлементСправочника) Тогда
		СсылкаНаЭлементСправочника = Неопределено;
	КонецЕсли;
	
	Возврат СсылкаНаЭлементСправочника;
		
КонецФункции
	
// Функция получает элемент справочника по наименованию 
// Если элемента нет в базе, то он создается и возвращается ссылка
//
// Параметры:
//  МетаданныеСправочника - Обязательный, ОбъектМетаданных. 
//		Метаданные спраочника, для которых нужно получитьэлемент
//
//	стрНаименованиеЭлемента — Обязательный, Строка. 
//		Наименование элемента.
//
//  ЭтоГруппа — необязательный, булево
//		Если истина, то будет создана группа справочника. 
//		Иначе будет создан элемент справочника
//
//   стрНаименованиеРодителя — необязательный, строка
//		Если заполнено, то создаваемый элемент будет помещен в указанную папку
//
//   СтруктураЗначенийРеквизитов — необязательный, структура
//		Содержит значения дополнительных реквизитов справочника, которые будут 
//		присвоены реквизитам нового объекта.
//
// Возвращаемое значение
//  СправочникСсылка
//	ИнформацияОбОшибке при неудачном завершении
//
Функция Справочник_ПолучитьСсылкуПоНаименованиюЭлемента(
		МетаданныеСправочника, 
		Знач стрНаименованиеЭлемента,
		ЭтоГруппа = Ложь,
		Знач Родитель = "",
		СтруктураЗначенийРеквизитов = Неопределено
		) Экспорт

	Проверка_Тип(стрНаименованиеЭлемента, "Строка");
	Если ПустаяСтрока(стрНаименованиеЭлемента)Тогда
		ВызватьИсключение "Пустое наименование элемента справочника.";
	КонецЕсли;
	
	Проверка_Тип(МетаданныеСправочника, Тип("ОбъектМетаданных"));
	стрНаименованиеЭлемента = СокрЛП(стрНаименованиеЭлемента);
	Если Не КорневойТипКонфигурации_Получить(МетаданныеСправочника) = "Справочник" Тогда
		ВызватьИсключение "Недопустимые метаданные. Должны быть метаданные справочника.";
	КонецЕсли;
	
	Проверка_Тип(ЭтоГруппа, "Булево");
	
	МенеджерСправочника = Менеджер_Получить(МетаданныеСправочника);
	
	МассивДопустимыхТиповРодителя = Новый Массив;
	МассивДопустимыхТиповРодителя.Добавить(Тип("Строка"));
	МассивДопустимыхТиповРодителя.Добавить(ТипЗнч(МенеджерСправочника.ПустаяСсылка()));
	Проверка_Тип(Родитель, Новый ОписаниеТипов(МассивДопустимыхТиповРодителя));
	
	Если СтруктураЗначенийРеквизитов <> Неопределено Тогда
		Проверка_Тип(СтруктураЗначенийРеквизитов, "Структура");
	КонецЕсли;
	
	СсылкаНаЭлементСправочника = Неопределено;

	СсылкаНаРодителя = МенеджерСправочника.ПустаяСсылка();
	Если ТипЗнч(Родитель) = Тип("Строка") И ЗначениеЗаполнено(Родитель) Тогда
		СсылкаНаРодителя = 
			Справочник_ПолучитьСсылкуПоНаименованиюЭлемента(
				МетаданныеСправочника,
				Родитель,
				Истина // ЭтоГруппа
				);
				
	ИначеЕсли МетаданныеСправочника.Иерархический
			И ТипЗнч(Родитель) = ТипЗнч(МенеджерСправочника.ПустаяСсылка())
			И ЗначениеЗаполнено(Родитель)
			И Родитель.ЭтоГруппа
				Тогда
				
			СсылкаНаРодителя = Родитель;
			
	Иначе
			СсылкаНаРодителя = Неопределено;
			
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НаименованиеЭлемента", стрНаименованиеЭлемента);
	Запрос.УстановитьПараметр("Родитель", СсылкаНаРодителя);
	Запрос.УстановитьПараметр("ЭтоГруппа", ЭтоГруппа);
	Запрос.УстановитьПараметр("Иерархический", МетаданныеСправочника.Иерархический); 
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	Спр.Ссылка,
	|	ВЫБОР
	|		КОГДА НЕ &Иерархический
	|			ТОГДА 0
	|		КОГДА Спр.Родитель = &Родитель
	|			ТОГДА 0
	|		КОГДА Спр.Родитель В ИЕРАРХИИ (&Родитель)
	|			ТОГДА 1
	|		ИНАЧЕ 2
	|	КОНЕЦ КАК Порядок
	|ИЗ
	|	Справочник.Номенклатура КАК Спр
	|ГДЕ
	|	Спр.Наименование = &НаименованиеЭлемента
	|	И ВЫБОР
	|			КОГДА &Иерархический
	|				ТОГДА Спр.ЭтоГруппа = &ЭтоГруппа
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ
	|
	|УПОРЯДОЧИТЬ ПО
	|	Порядок";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "Справочник.Номенклатура", МетаданныеСправочника.ПолноеИмя());
	Если Не МетаданныеСправочника.Иерархический Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "Спр.ЭтоГруппа", "НЕОПРЕДЕЛЕНО");
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "Спр.Родитель", "НЕОПРЕДЕЛЕНО"); 
	КонецЕсли;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		СсылкаНаЭлементСправочника = Выборка.Ссылка;
	КонецЕсли;

	Если Не ЗначениеЗаполнено(СсылкаНаЭлементСправочника) Тогда
		Если МетаданныеСправочника.Иерархический И ЭтоГруппа Тогда 
			ОбъектЭлементаСправочника = МенеджерСправочника.СоздатьГруппу();
		Иначе
			ОбъектЭлементаСправочника = МенеджерСправочника.СоздатьЭлемент();
		КонецЕсли;
		ОбъектЭлементаСправочника.Наименование = стрНаименованиеЭлемента;
		
		Если ЗначениеЗаполнено(СсылкаНаРодителя) Тогда
			ОбъектЭлементаСправочника.Родитель = СсылкаНаРодителя;
		КонецЕсли;
		
		Если СтруктураЗначенийРеквизитов <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(ОбъектЭлементаСправочника, СтруктураЗначенийРеквизитов);
		КонецЕсли;
		
		Попытка
			ОбъектЭлементаСправочника.Записать();
			СсылкаНаЭлементСправочника = ОбъектЭлементаСправочника.Ссылка;
			ОбъектЭлементаСправочника = Неопределено;
			
		Исключение
			Возврат ИнформацияОбОшибке();
			
		КонецПопытки;
		
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(СсылкаНаЭлементСправочника) Тогда
		СсылкаНаЭлементСправочника = Неопределено;
	КонецЕсли;
	
	Возврат СсылкаНаЭлементСправочника;
		
КонецФункции

#КонецЕсли //Не ТонкийКлиент и Не ВебКлиент И Не МобильныйКлиент

#КонецОбласти 
//Справочники

#Область Коллекции

// Процедура служит для заполнения коллекции (структуры или соответствия)
// Из источника (коллекции, поддерживающей обращение по имени.
// Заполняются тольк те поля, которые есть в коллеции
Процедура Коллекция_ЗаполнитьИзИсточника(Коллекция,Источник) Экспорт
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		Коллекция.Вставить(КлючИЗначение.Ключ, Источник[КлючИЗначение.Ключ]);
	КонецЦикла
	
КонецПроцедуры

// Функция преобразует входящую массив в строку с разделителями
//
// Параметры:
//	МассивИсходный - обязательный, массив, исходный массив,
//				который надо преобразовать в строку;
//	стрРазделитель - необязательный, строка, по умолчанию ","
//				разделитель результирующей строки;
//
// Возвращает:
//		Строка;
//
Функция Массив_ПреобразоватьВСтроку(Знач МассивИсходный, стрРазделитель = ",") Экспорт 

	СтрокаРезультат = "";
	
	Для Каждого ЭлементМассива Из МассивИсходный Цикл 
		СтрокаРезультат = 
			СтрокаРезультат +
			?(ЗначениеЗаполнено(СтрокаРезультат), стрРазделитель, "") +
			Строка(ЭлементМассива)
			;
			
	КонецЦикла;
	
	Возврат СтрокаРезультат;
	
КонецФункции

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
//Удаляет повторяющиеся элементы массива.
Функция Массив_УдалитьПовторяющиесяЭлементы(Массив, НеИспользоватьНеопределено = Ложь) Экспорт

	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки();
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки();
	
	#Если Не МобильноеПриложениеСервер Тогда
	ОписаниеТиповПВХ = ПланыВидовХарактеристик.ТипВсеСсылки();
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки();
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки();
	#КонецЕсли

	Если ТипЗнч(Массив) = Тип("Массив") Тогда

		УжеВМассиве = Новый Соответствие;
		БылоНеопределено = Ложь;

		КолвоЭлементовВМассиве = Массив.Количество();

		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс];
			ТипЭлемента = ТипЗнч(ЭлементМассива);
			Если ЭлементМассива = Неопределено Тогда
				Если БылоНеопределено или НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс);
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				Продолжить;
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента)
				ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента)
				
				#Если Не МобильноеПриложениеСервер Тогда
				ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента)
				ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента)
				ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента)
				#КонецЕсли

			Тогда

				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор());

			Иначе

				ИДЭлемента = ЭлементМассива;

			КонецЕсли;

			Если УжеВМассиве[ИДЭлемента] = Истина Тогда
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс);
			Иначе
				УжеВМассиве[ИДЭлемента] = Истина;
			КонецЕсли;
		КонецЦикла;

	КонецЕсли;

	Возврат Массив;

КонецФункции
#КонецЕсли // Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент

//Процедура копирует реквизиты одного объекта в другой объект
//Передаваемые параметры:
//	Источник - обязательный, объект конфигурации (документ или справочник), источник данных;
//	Приемник - обязательный, объект конфигурации (документ или справочник), приемник данных;
//
// Происхождение: ИТ
//
Процедура СкопироватьРеквизиты(Источник,Приемник) Экспорт
	
	Для каждого Реквизит Из Источник.Метаданные().Реквизиты Цикл
		Попытка 
			Приемник[Реквизит.Имя]	= Источник[Реквизит.Имя];
		Исключение
		КонецПопытки;
	КонецЦикла;
	
	Для Каждого ТабличнаяЧасть Из Источник.Метаданные().ТабличныеЧасти Цикл
		Попытка
			Приемник[ТабличнаяЧасть.имя].Загрузить(Источник[ТабличнаяЧасть.Имя].Выгрузить());
		Исключение
		КонецПопытки;
	КонецЦикла

КонецПроцедуры

// Функция предназначена для поиска элемента списка значений по представлению
// Если поиск успешен, возвращается элемент списка значенией
// Если неудачно, возвращается "Неопределено"
Функция СписокЗначений_НайтиПоПредставлению(СписокЗначений,Представление) Экспорт
	
	Результат = Неопределено;
	
	Для Каждого Элемент Из СписокЗначений Цикл
		Если Элемент.Представление = Представление Тогда
			Результат = Элемент;
			Прервать;
		КонецЕсли;		
	КонецЦикла;	
		
	Возврат Результат;
		
КонецФункции

// Процедура ищет в представлениях списка значений строку поиска и выделяет ее
// Применяется для обработчиков процедур получения данных выбора, чтобы пользователь
// видел, по какой части была найден объект при выборе из списка
//
// Параметры:
//  СписокЗначений  - СписокЗначений - обязательный
//                 Список значений, в котором необходимо отметить вхождения в представлениях элементов
//  СтрокаВхождения  - Строка - обязательный
//  				Строка, по которой будет выделяться часть представления элемента списка значений
//					равная ей
//
// Процедура превращает представления элементов списка значений в форматированную строку
//
Процедура СписокЗначений_ВыделитьВхожденияВПредставлении(СписокЗначений, СтрокаВхождения) Экспорт
	
	Проверка_Тип(СписокЗначений, Тип("СписокЗначений"));
	Проверка_Тип(СтрокаВхождения, Тип("Строка"));
	
	Для Каждого ЭлементСпискаЗначений Из СписокЗначений Цикл
		
		ИсходноеПредставление = Строка(ЭлементСпискаЗначений.Представление);
		
		ИсходноеПредставлениеЗаканчиваетсяНаСтрокуВхождения = 
			(ЭлементСпискаЗначений.Представление = 
				СтрЗаменить(ЭлементСпискаЗначений.Представление, СтрокаВхождения, "") + СтрокаВхождения);
		
		// Убрать переводы строки на пробел
		ИсходноеПредставление = СтрЗаменить(ИсходноеПредставление, Символы.ПС, " ");
		
		// Заменить вхождения строки поиска на плейсхолдер — перево строки
		ИсходноеПредставление = СтрЗаменить(ИсходноеПредставление, СтрокаВхождения, Символы.ПС); 
		
		// Разбить исходное представление на части по строке поиска
		ИсходноеПредставление_МассивЧастей = 
			СтрРазделить(ИсходноеПредставление, Символы.ПС, Ложь);
			
		Если ИсходноеПредставлениеЗаканчиваетсяНаСтрокуВхождения Тогда
			ИсходноеПредставление_МассивЧастей.Добавить("");
		КонецЕсли;
		
		// Из этого массива будет создана форматированная строка
		Представление_МассивЧастей = Новый Массив;
		Для Каждого ЧастьПредставления Из ИсходноеПредставление_МассивЧастей Цикл
			
			// Если в массиве частей уже есть что-то, добавить разделитель
			Если Представление_МассивЧастей.Количество() > 0 Тогда
				Представление_МассивЧастей.Добавить(
					Новый ФорматированнаяСтрока(
						СтрокаВхождения,
						Новый Шрифт(,,Истина),
						Новый Цвет(255, 0, 0)
						)
					);
					
			КонецЕсли;

			Представление_МассивЧастей.Добавить(Новый ФорматированнаяСтрока(ЧастьПредставления));
			
		КонецЦикла;
		ЭлементСпискаЗначений.Представление = 
			Новый ФорматированнаяСтрока(Представление_МассивЧастей);
		
	КонецЦикла;
	ЭлементСпискаЗначений = Неопределено;
	
КонецПроцедуры


// Процедура копирует одну структуру в другую.
// Это нужно например при  заполнении параметров запросов
// Т.к. параметры запроса нельзя заменить.
// Параметры:
//		Источник - обязательный, структура
//		Приемник - обязательный, структура
//
Процедура Структура_Скопировать(Источник, Приемник) Экспорт
	
	Для Каждого КлючИЗначение из Источник Цикл
		Приемник.Вставить(КлючИЗначение.Ключ,КлючИЗначение.Значение);
	КонецЦикла;
	
КонецПроцедуры

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
Функция СоответствиеВТаблицуЗначений(
			пСоответствие, 
			пОписаниеТиповКлюча = Неопределено, 
			пОписаниеТиповЗначения = Неопределено
			) Экспорт
	
	Проверка_Тип(пСоответствие, Тип("Соответствие"));
	
	Если пОписаниеТиповКлюча <> Неопределено Тогда
		Проверка_Тип(пОписаниеТиповКлюча, Тип("ОписаниеТипов"));
	КонецЕсли;
	
	Если пОписаниеТиповЗначения <> Неопределено Тогда
		Проверка_Тип(пОписаниеТиповЗначения, Тип("ОписаниеТипов"));
	КонецЕсли;
	
	ТЗ = Новый ТаблицаЗначений;
	
	Если пОписаниеТиповКлюча = Неопределено Тогда
		ТЗ.Колонки.Добавить("Ключ");
	Иначе
		ТЗ.Колонки.Добавить("Ключ", пОписаниеТиповКлюча);
	КонецЕсли;
	
	Если пОписаниеТиповЗначения = Неопределено Тогда
		ТЗ.Колонки.Добавить("Значение");
	Иначе
		ТЗ.Колонки.Добавить("Значение", пОписаниеТиповЗначения)
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из пСоответствие Цикл
		СтрокаТЗ = ТЗ.Добавить();
		СтрокаТЗ.Ключ = КлючИЗначение.Ключ;
		СтрокаТЗ.Значение = КлючИЗначение.Значение;
		
	КонецЦикла;
	КлючИЗначение = Неопределено;
	
	Возврат ТЗ;
	
КонецФункции
#КонецЕсли // #Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда

#КонецОбласти
//Коллекции

#Область Настройки

#Если Не ВебКлиент И Не МобильныйКлиент И Не ТонкийКлиент И Не МобильноеПриложениеСервер Тогда
Функция Настройка_Получить(КлючОбъекта) Экспорт
	
	Настройка = Неопределено;
	
	Попытка 
		Настройка = общ_ПолныеПрава.Настройка_Получить(КлючОбъекта);
		
	Исключение
		Настройка = Неопределено;
		ЗаписьЖурналаРегистрации(
			"общ",
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			"Не удалось получить общую настройку: " + ОписаниеОшибки(),
			РежимТранзакцииЗаписиЖурналаРегистрации.Независимая
			);
		
	КонецПопытки;
		
	Возврат Настройка; 
	
КонецФункции
	
Процедура Настройка_Сохранить(КлючОбъекта, ЗначениеНастройки) Экспорт
	
	общ_ПолныеПрава.Настройка_Сохранить(КлючОбъекта, ЗначениеНастройки);
	
КонецПроцедуры

#КонецЕсли // Если Не ВебКлиент И Не МобильныйКлиент и не ТонкийКлиент Тогда

#КонецОбласти 

//Настройки

#Область ОповещениеПользователя

// Функция ЗаголовокСообщения_Получить
//
// Функция предназначена для получения текста заголовка сообщения, который
// Выводиться в консоли при ошибках работы модуля (проведение, печать и тд).
// Параметры:
//		ОбъектСсылка - Обязательный, строка, объект или ссылка на объект
//		стрДо 	- необязательный, строка
//				по умолчанию пустая строка
//		стрПосле 	- необязательный, строкеа
//					по умолчанию ": "
Функция ЗаголовокСообщения_Получить(ОбъектСсылка,стрДо = "",стрПосле = ":") Экспорт
	
	Возврат 
		Формат(ТекущаяДата(), "ДЛФ=T") + 
		Символы.НПП +
		стрДо +
		Символы.НПП +
		""""+строка(ОбъектСсылка) + """" + Символы.НПП+ 
		стрПосле + Символы.НПП;

КонецФункции

// Процедура управляет индикатором прогресса.
// При выполнении на сервере раз в минуту сообщает о состоянии процесса обработки данных
// Нужна как замена индикатора для фонового задания - сообщения можно получить с помощью метода
// ПолучитьСообщенияПользователю() фонового задания
//
//	Параметры:
//		Выполнено  - обязательный, число;
//					 этот параметр увеличивается на 1 при каждом вызове процедуры;
//		ВсегоНадоВыполнить - обязательный, число;
//		КратностьОповещения - необязательный, число, по умолчанию 0
//			                  Этот параметр позволяет не выводить каждое сообщение.
//							  Выводятся только сообщения, кратные этому параметру
//		Индикатор - Необязательный, число, по умолчанию 0.
//					Сюда можно передавать индикатор, который может использоваться на форме;
//		ВыводитьСостояние - Необязательный, булево, по умолчанию ложь
//							признак необходимости выводить прогресс в строку состояния.
//							На сервере прогресс будет выводиться в сообщениях.
//		Текст - необязательный, строка, по умолчанию пустая строка
//				текст, который будет выводиться в строке состояния вместе с числами
//				формат сообщения будет выглядеть так: Текст Выполнено/ВсегоНадоВыполнить=Отношение%;
// 
// 20120508 Заяш
//
Процедура ОповеститьОПрогрессе(
			Выполнено,
			ВсегоНадоВыполнить, 
			КратностьОповещения = 0, 
			Индикатор = 0, 
			ВыводитьСостояние = Ложь,
			Текст = ""
			) Экспорт
			
	Выполнено = Выполнено+1;
	
	// Проверка, чтобы не частить с выводом сообщений. 
	// Выводятся только кратные сообщения
	Если КратностьОповещения > 0  И Не Выполнено%КратностьОповещения = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Для использования индикации на форме
	Индикатор = Выполнено/ВсегоНадоВыполнить*100;
	
	Если Не ВыводитьСостояние Тогда
		#Если Клиент Тогда
			ОбработкаПрерыванияПользователя();
		#КонецЕсли   			
		Возврат;
	КонецЕсли;
	
	ТекстОповещения = 
		СтрШаблон(
			"%3 %1/%2=%4",
			Формат(Выполнено,"ЧДЦ=0; ЧГ=0"),
			Формат(ВсегоНадоВыполнить,"ЧДЦ=0; ЧГ=0"),
			?(ЗначениеЗаполнено(Текст),Текст,"Выполнено"),
			Формат(Индикатор,"ЧЦ=5; ЧДЦ=2; ЧГ=0")
			)+"%";
	
	УстановитьСостояние(ТекстОповещения);
	
КонецПроцедуры

// Процедура ОшибкаПриПроведении
//
// Формирует сообщение при ошибках проведения документов.
//
// Параметры: 
//  	ТекстСообщения - Исходный текст, выводимого сообщения,
//  	Отказ          - Флаг отказа в проведении докумета,
//  	Заголовок      - Заголовок начала серии сообщений об ошибках проведения (не обязательный)
//
Процедура ОшибкаПриПроведении(ТекстСообщения, Отказ=Ложь, Заголовок="",Статус=Неопределено) Экспорт

	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок,Статус);

КонецПроцедуры // ОшибкаПриПроведении()

// Процедура для вывода предупреждения. Корректно работает как на клиенте, так и на сервере.
// На клиенте выводится предупреждение, на сервере сообщение
// 
// Параметры:
//		ТекстСообщения - 
//			обязательный, строка, передается по значению
//			текст, который будет выведен в предупреждении
//
Процедура Предупредить(Знач ТекстСообщения) Экспорт
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);

	#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		Предупреждение(ТекстСообщения);
	#Иначе
		Сообщить(Формат(ТекущаяДата(),"ДФ='yyyyMMdd hh:mm:ss'")+Символы.НПП+ТекстСообщения, СтатусСообщения.Важное);
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

Процедура Сообщ(ТекстСообщения, Статус = Неопределено) Экспорт
	
	Если Статус <> Неопределено Тогда
		Проверка_Тип(Статус, Тип("СтатусСообщения"));;
	КонецЕсли;
	
	Сообщить(
		СтрШаблон(
			 "
			 |%1 
			 |%2",
			Формат(ТекущаяДата(),"ДЛФ=T"),
			ТекстСообщения
			),
			Статус
		);
	
КонецПроцедуры

// Процедура делает запись в журнале регистрации и выводит сообщение в консоль
// Используется для фоновых заданий
//
// 20180117 Заяш
//
#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент И Не МобильноеПриложениеСервер Тогда
Процедура СообщитьИЗаписатьВЖурнал(ИмяСобытия, ТекстСообщения, Знач УровеньЖурнала = Неопределено) Экспорт
	
	Если УровеньЖурнала = Неопределено Тогда
		УровеньЖурнала = УровеньЖурналаРегистрации.Информация;
		стСообщ = СтатусСообщения.Информация;
		
	ИначеЕсли УровеньЖурнала = УровеньЖурналаРегистрации.Ошибка Тогда
		стСообщ = СтатусСообщения.ОченьВажное;
		
	ИначеЕсли УровеньЖурнала = УровеньЖурналаРегистрации.Предупреждение Тогда
		стСообщ = СтатусСообщения.Внимание;
		
	ИначеЕсли УровеньЖурнала = УровеньЖурналаРегистрации.Примечание Тогда
		стСообщ = СтатусСообщения.Обычное;
		
	ИначеЕсли УровеньЖурнала = УровеньЖурналаРегистрации.Информация Тогда
		стСообщ = СтатусСообщения.Информация;
		
	Иначе 
		УровеньЖурнала = УровеньЖурналаРегистрации.Информация;
		стСообщ = СтатусСообщения.Информация;
	КонецЕсли;

	ЗаписьЖурналаРегистрации(
		ИмяСобытия,
		УровеньЖурнала,
		,
		,
		ТекстСообщения,
		РежимТранзакцииЗаписиЖурналаРегистрации.Независимая
		);
		
	Сообщ(СтрШаблон("%1: %2", ИмяСобытия, ТекстСообщения), стСообщ);
	
КонецПроцедуры
#КонецЕсли // Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения 	- обязательный, строка, текст сообщения.
//  Отказ          	- необязательный, булево, признак отказа (необязательный).
//  Заголовок      	- необязательный, строка, необязательный, выводится перед сообщением об ошибке
//  Статус			- необязательный, тип СтатусСообщения, необязательный
//	ОписаниеОшибки  - необязательный, строка, описание ошибки
//
Процедура СообщитьОбОшибке(
				Знач ТекстСообщения, 
				Отказ = Ложь, 
				Заголовок = "", 
				Статус = Неопределено, 
				ОписаниеОшибки = ""
											) Экспорт

	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);

	Отказ = Истина;
	
	Если ЗначениеЗаполнено(Заголовок) Тогда
		ТекстСообщения = Заголовок +Символы.ПС+ ТекстСообщения;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ОписаниеОшибки) Тогда
		ТекстСообщения 
			= ТекстСообщения + "
			|	по причине:
			|		" + ОписаниеОшибки;
	КонецЕсли;

	общ_Сервер.ОшибкаВЖурналРегистрации("общ_Ошибка",  ТекстСообщения);
	
	#Если ВнешнееСоединение Тогда
		ВызватьИсключение (ТекстСообщения);
	#Иначе
		Сообщить(ТекстСообщения, Статус);
	#КонецЕсли

КонецПроцедуры // СообщитьОбОшибке()

// Функция убирает из текста сообщения слущебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции // ()

// Служебная функция, возвращающая текст "<не определено>" с локализацией.
// Используется для целей локализации
//
Функция ТекстНеОпределено() Экспорт
	
	Возврат НСтр("ru = '<не определено>'");
	
КонецФункции

// Процедура устанавливает состояние на клиенте и выводит сообщение на сервере.
// Для корректной работы в любом контексте
//
// Параметры:
//		Сообщение - обязательный, строка, текст который надо установить для состояния
//
// 20120508 Заяш
Процедура УстановитьСостояние(Сообщение) Экспорт
	
	#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		Состояние(Сообщение);
	#Иначе
		Сообщить(Формат(ТекущаяДата(),"ДФ='yyyyMMdd hh:mm:ss'")+Символы.НПП+Сообщение, СтатусСообщения.Информация);		
	#КонецЕсли
	
КонецПроцедуры

#КонецОбласти 
//ОповещениеПользователя

#Область ПланыСчетов

// Процедура предназначена для контроля правильности заполнения записи регистра бухгалтерия
// бывает необходимо когда запись заполняется алгоритмами, не выполняющими контроля.
// Например, если при заполнении неизвестны счета Дт и Кт, и заполняются все возможные субконто.
// Или движение заполнеятся в конвертации данных, в другой базе
//
// 20190704 Заяш 
//
Процедура РегистрБухгалтерииЗапись_КонтрольЗаполнения(Движение) Экспорт
	
	// Проверить заполнение субконто
	// Необходимо, чтобы типы субконто совпадали с типами, установленными у счета
	массивДтКт = Новый Массив;
	массивДтКт.Добавить("Дт");
	массивДтКт.Добавить("Кт");
	Для Каждого ДтКт Из массивДтКт Цикл
		
		Движение_Счет = Движение["Счет" + ДтКт];
		Движение_Субконто_Коллекция = Движение["Субконто"+ДтКт]; 
		
		МассивВидовСубконтоДляУдаления = Новый Массив;
		
		Для Каждого Движение_Субконто_Элемент Из Движение_Субконто_Коллекция Цикл
			
			ВидСубконто = Движение_Субконто_Элемент.Ключ;
			
			Движение_Счет_ИмеетВидСубконто = Не (Движение_Счет.ВидыСубконто.Найти(ВидСубконто) = Неопределено);
			
			// Если у счета нет такого субконто, его необходимо удалит
			Если Не Движение_Счет_ИмеетВидСубконто Тогда
				МассивВидовСубконтоДляУдаления.Добавить(ВидСубконто);
			КонецЕсли;
			
		КонецЦикла;
		Движение_Субконто_Элемент = Неопределено;
		
		// Удалить ненужные субконто из движения
		Для Каждого ВидСубконто Из МассивВидовСубконтоДляУдаления Цикл
			Движение_Субконто_Коллекция.Удалить(ВидСубконто);
			
		КонецЦикла;
		ВидСубконто = Неопределено;
		
		//// Если счет не валютный, сбросить валюту и валютную сумму
		//Если Не Движение_Счет.Валютный Тогда
		//	Движение["Валюта"+ДтКт] = Неопределено;
		//	Движение["СуммаВал"+ДтКт] = Неопределено;
		//КонецЕсли;
		//
		//// Если счет не валютный, сбросить валюту и валютную сумму
		//Если Не Движение_Счет.Количественный Тогда
		//	Движение["Количество"+ДтКт] = Неопределено;
		//КонецЕсли;

	КонецЦикла;
	ДтКт = Неопределено;
	
КонецПроцедуры

#КонецОбласти 
// ПланыСчетов

#Область ПолеТабличногоДокумента

#Если ТолстыйКлиентОбычноеПриложение Тогда
Процедура ТабличноеПоле_Колонки_Настройки_Загрузить(КоллекцияКолонок, ИмяНастройки) Экспорт
	
	НастройкиКолонок = ХранилищеОбщихНастроек.Загрузить(ИмяНастройки);
	
	Если НастройкиКолонок = Неопределено Тогда
		Возврат;
		
	КонецЕсли;
	
	Если ТипЗнч(НастройкиКолонок) <> Тип("ТаблицаЗначений") Тогда
		Возврат;
		
	КонецЕсли;
	
	Для Каждого СтрокаНастроек Из НастройкиКолонок Цикл
		
		Попытка
			ОбрабатываемаяКолонка = КоллекцияКолонок[СтрокаНастроек.ИмяКолонки];
			ОбрабатываемаяКолонка.Видимость = СтрокаНастроек.Видимость;
			ОбрабатываемаяКолонка.Ширина = СтрокаНастроек.Ширина;
			ТекущаяПозицияКолонки = КоллекцияКолонок.Индекс(ОбрабатываемаяКолонка);
			КоллекцияКолонок.Сдвинуть(ТекущаяПозицияКолонки,СтрокаНастроек.Позиция-ТекущаяПозицияКолонки);
			
		Исключение
			
		КонецПопытки;
		
	КонецЦикла; 
	СтрокаНастроек = Неопределено;
	
КонецПроцедуры
#КонецЕсли //#Если ТолстыйКлиентОбычноеПриложение Тогда

#Если ТолстыйКлиентОбычноеПриложение Тогда
Процедура ТабличноеПоле_Колонки_Настройки_Сохранить(КоллекцияКолонок, ИмяНастройки) Экспорт

	НастройкиКолонок = Новый ТаблицаЗначений;
	НастройкиКолонок.Колонки.Добавить("ИмяКолонки");
	НастройкиКолонок.Колонки.Добавить("Позиция");
	НастройкиКолонок.Колонки.Добавить("Видимость");
	НастройкиКолонок.Колонки.Добавить("Ширина");
	
	Для каждого Колонка Из КоллекцияКолонок Цикл
		СтрокаНастройки = НастройкиКолонок.Добавить();
		СтрокаНастройки.ИмяКолонки = Колонка.Имя;
		СтрокаНастройки.Позиция = КоллекцияКолонок.Индекс(Колонка);
		СтрокаНастройки.Видимость = Колонка.Видимость;
		СтрокаНастройки.Ширина = Колонка.Ширина;
	КонецЦикла;
	Колонка = Неопределено;
	
	НастройкиКолонок.Сортировать("Позиция");
	
	ХранилищеОбщихНастроек.Сохранить(ИмяНастройки, , НастройкиКолонок);

КонецПроцедуры
#КонецЕсли //#Если ТолстыйКлиентОбычноеПриложение Тогда

#Если Клиент Тогда
Функция ТабличноеПоле_СуммироватьВыделенныеЯчейки(ТабличноеПоле) Экспорт
	
	МоментНачала = ТекущаяДата();
	ЭтоУправляемаяФорма = (ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы"));
		
	Результат = Новый Структура ("Сумма,Максимум,Минимум,ВыделеноЯчеек,Среднее,ДлительностьВыполения,Представление",0,0,0,0,0,0,"");
	
	ИмяДанныхКолонки = "";
	Если ЭтоУправляемаяФорма Тогда
		ИмяДанныхКолонки = ТабличноеПоле.ТекущийЭлемент.Имя;
	Иначе
		ИмяДанныхКолонки = ТабличноеПоле.ТекущаяКолонка.Данные;
	КонецЕсли;
	
	Результат.Минимум = 99999999999999999999999999999999999999;
	Результат.Максимум = -Результат.Минимум;
	
	Для Каждого СтрокаТЧ Из ТабличноеПоле.ВыделенныеСтроки Цикл 
		
		// Если выделена строка группировки динамического списка, надо пропустить 
		Если ТипЗнч(СтрокаТЧ) = Тип("СтрокаГруппировкиДинамическогоСписка") Тогда
			СуммаВЯчейке = 0;
        Иначе
			// Для того чтобы работало и с управляемыми формами (ТаблицыФормы),
			// и с неуправляемыми (ТабличноеПоле), получать сумму в ячейке надо  
			// через метод "ДанныеСтроки", а не прямым обращением к реквизитам строки
			СуммаВЯчейке = ТабличноеПоле.ДанныеСтроки(СтрокаТЧ)[ИмяДанныхКолонки];
			// СуммаВЯчейке = СтрокаТЧ[ИмяДанныхКолонки];
		КонецЕсли;
		
		Если ТипЗнч(СуммаВЯчейке) = Тип("Число") Тогда
			Результат.Сумма = Результат.Сумма+СуммаВЯчейке;
		Иначе 
			СуммаВЯчейке = 0;
		КонецЕсли;
		Если Результат.Максимум < СуммаВЯчейке Тогда Результат.Максимум = СуммаВЯчейке КонецЕсли;
		Если Результат.Минимум > СуммаВЯчейке Тогда Результат.Минимум = СуммаВЯчейке КонецЕсли;
		Результат.ВыделеноЯчеек = Результат.ВыделеноЯчеек + 1;
	КонецЦикла; 
	Если Результат.ВыделеноЯчеек = 0 Тогда
		Результат.Среднее = 0;
	Иначе
		Результат.Среднее = Окр(Результат.Сумма/Результат.ВыделеноЯчеек,3);
	КонецЕсли;
	Результат.ДлительностьВыполения = ТекущаяДата() - МоментНачала;
	Результат
		.Представление 
	        = "? "+Результат.Сумма+"; " +Символы.ПС
	        + "среднее "+Результат.Среднее+"; " +Символы.ПС
	        + "минимум "+Результат.Минимум+"; " +Символы.ПС
	        + "максимум "+Результат.Максимум+"; " +Символы.ПС
	        + "выделено "+Результат.ВыделеноЯчеек + " ячеек ";
	Возврат Результат;	
КонецФункции

// Функция вычисляет сумму, минимальное, максимальное и среднее значения выделенных ячеек табличного документа;
// Возвращает структуру с полями:
//		"Сумма,Максимум,Минимум,ВыделеноЯчеек,Среднее,ДлительностьВыполения,Представление" — числа
//
Функция ПолеТабличногоДокумента_СуммироватьВыделенныеЯчейки(ПолеТабличногоДокумента) Экспорт 
	
	МоментНачала = ТекущаяДата();
	
	Результат = Новый Структура ("Сумма,Максимум,Минимум,ВыделеноЯчеек,Среднее,ДлительностьВыполения,Представление",0,0,0,0,0,0,"");
	Результат.Минимум = 99999999999999999999999999999999999999;
	Результат.Максимум = -Результат.Минимум;
	
	Для Каждого Область Из ПолеТабличногоДокумента.ВыделенныеОбласти Цикл 
		Если ТипЗнч(Область) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда 
			Для ИндексСтрока = Область.Верх По Область.Низ Цикл 
				Для ИндексКолонка = Область.Лево По Область.Право Цикл 
					Попытка 
						СуммаВЯчейке = Число(СтрЗаменить(ПолеТабличногоДокумента.Область("R" + Формат(ИндексСтрока, "ЧГ=0") + "C" + Формат(ИндексКолонка, "ЧГ=0")) .Текст, " ", ""));
						Результат.Сумма = Результат.Сумма + СуммаВЯчейке;
						Если Результат.Максимум < СуммаВЯчейке Тогда Результат.Максимум = СуммаВЯчейке КонецЕсли;
						Если Результат.Минимум > СуммаВЯчейке Тогда Результат.Минимум = СуммаВЯчейке КонецЕсли;
						Результат.ВыделеноЯчеек = Результат.ВыделеноЯчеек + 1;
					Исключение 
					КонецПопытки; 
				КонецЦикла; 
			КонецЦикла; 
		КонецЕсли; 
	КонецЦикла;
	Если Результат.ВыделеноЯчеек = 0 Тогда
		Результат.Среднее = 0;
	Иначе
		Результат.Среднее = Окр(Результат.Сумма/Результат.ВыделеноЯчеек,3);
	КонецЕсли;
	Результат.ДлительностьВыполения = ТекущаяДата() - МоментНачала;
	Результат
		.Представление 
	        = "? "+Результат.Сумма+"; " +Символы.ПС
	        + "среднее "+Результат.Среднее+"; " +Символы.ПС
	        + "минимум "+Результат.Минимум+"; " +Символы.ПС
	        + "максимум "+Результат.Максимум+"; " +Символы.ПС
	        + "выделено "+Результат.ВыделеноЯчеек + " ячеек ";
	Возврат Результат; 
	
КонецФункции

#КонецЕсли //Если Клиент Тогда

#КонецОбласти

#Область СКД

#Если Клиент Тогда
// Процедура устанавливает группировку динамического списка в управляемой форме
// Все существующие группировки при этом очищаются
// Параметры:
//		Список - Обязательный, Динамический список
//		ИмяПоляГруппировки - Обязательный, строка. Имя доступного поля сортировки
//		ТипГруппировки - Необязательный, тип группировки, который будет применен для списка.
//
// ВНИМАНИЕ! Директиву не менять
// Иначе для сортировки список будет отправлятся из формы на сервер.
Процедура ДинамическийСписок_УстановитьГруппировкуВФорме(Список, ИмяПоляГруппировки, ТипГруппировки = Неопределено) Экспорт
	
	// Приведем тип группировки к правильному значению.
	Если ТипГруппировки = Неопределено Или ТипЗнч(ТипГруппировки) <> Тип("ТипГруппировкиКомпоновкиДанных") Тогда
		ТипГруппировки = ТипГруппировкиКомпоновкиДанных.Элементы;
	КонецЕсли;
	
	// Очистить группировки списка
	Список.Группировка.Элементы.Очистить();

	// Найти доступное поле группировки
	ДоступноеПолеГруппировки 
		=  Список.Группировка.ДоступныеПоляПолейГруппировок.Элементы.Найти(ИмяПоляГруппировки);
		
	// Если поле не найдено, прервать процедуру
	Если ДоступноеПолеГруппировки =  Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	// Установить новую группировку
	ЭлементГруппировки = Список.Группировка.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));
	ЭлементГруппировки.Поле = ДоступноеПолеГруппировки.Поле;
	ЭлементГруппировки.ТипГруппировки = ТипГруппировки;
	
КонецПроцедуры
#КонецЕсли

// Процедура устанавливает отбор СКД. Используется для СКД и отборов динамических списков
//
// Параметры:
//		ОтборСКД
//			Обязательный, отбор СКД или группа элементов отбора компоновки данных
//			Отбор, в котором необходимо установить элемент
//		ЛевоеЗначение
//			Обязательный, Строка или ПолеКомпоновкиДанных
//			Поле, по которому будет происходить отбор
//		ПравоеЗначение
//			Обязательный, произвольный
//			Значение для отбора
//		ВидСравненияСКД
//			Необязательный, ВидСравненияКомпоновкиДанных
//			По умолчанию неопределено
//			Если значение не заполнено, будет взят вид сравнения "Равно".
//		Использование
//			Необязательный, Булево
//			По умолчанию Истина
//			Признак, использовать параметр или нет
// 		ЭлементОтбораДанных
//			Необязательный, не заполнять
//			Нужен для рекурсивной работы процедуры
//
// 20120905103206 Заяш
// 
Процедура СКД_Отбор_Установить(
		ОтборСКД, 
		знач ЛевоеЗначение, 
		знач ПравоеЗначение, 
		ВидСравненияСКД = Неопределено, 
		Использование = Истина, 
		ЭлементОтбораДанных = Неопределено
		) Экспорт
	
	Проверка_Тип(Использование, Тип("Булево"));
	
	Если ТипЗнч(ЛевоеЗначение) = Тип("Строка") Тогда
		ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ЛевоеЗначение);
	КонецЕсли;
	   
	Если ВидСравненияСКД = Неопределено Тогда
		ВидСравненияСКД = ВидСравненияКомпоновкиДанных.Равно;
	КонецЕсли;
	
	ЭлементыОтбора = ОтборСКД.Элементы;
	
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			// Вызвать рекурсивно эту процедуру
			СКД_Отбор_Установить(ЭлементОтбора, ЛевоеЗначение, ПравоеЗначение, ВидСравненияСКД, Использование, ЭлементОтбораДанных);
			Продолжить;
		КонецЕсли;
		
		Если ЭлементОтбора.ЛевоеЗначение = ЛевоеЗначение Тогда
			Если ЭлементОтбораДанных = Неопределено Тогда
				ЭлементОтбораДанных = ЭлементОтбора;
				ЭлементОтбораДанных.ВидСравнения = ВидСравненияСКД;
				ЭлементОтбораДанных.ПравоеЗначение = ПравоеЗначение;
				ЭлементОтбораДанных.Использование = Использование;
			Иначе
				ЭлементОтбора.Использование = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Если элемент отбора не найден, добавить новый в корень и установить ему значения
	Если ЭлементОтбораДанных = Неопределено И ТипЗнч(ОтборСКД) = Тип("ОтборКомпоновкиДанных") Тогда
		ЭлементОтбораДанных = ЭлементыОтбора.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбораДанных.ЛевоеЗначение = ЛевоеЗначение;
		ЭлементОтбораДанных.ВидСравнения = ВидСравненияСКД;
		ЭлементОтбораДанных.ПравоеЗначение = ПравоеЗначение;
		ЭлементОтбораДанных.Использование = Использование;
	КонецЕсли;
	
КонецПроцедуры

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Выполняет компоновку СКД по переданным настройкам
// Взято на https://infostart.ru/public/1082944
//
// Параметры:
//  Результат               - ТабличныйДокумент,ТаблицаЗначений,ДеревоЗначений                      - результат выполнения
//  СхемаКомпоновкиДанных   - СхемаКомпоновкиДанных                                                 - выполняемая СКД
//  НастройкиКомпоновки     - НастройкиКомпоновкиДанных,КомпоновщикНастроекКомпоновкиДанных,Строка  - выполняемые настройки или адрес временного хранилища или компоновщик с настройками
//  ДанныеРасшифровки       - ДанныеРасшифровкиКомпоновкиДанных, Неопределено                       - данные расшифровки
//  ВнешниеНаборыДанных     - Структура, Неопределено                                               - коллекция внешних наборов данных
//  ДополнительныеПараметры - Структура, Неопределено                                               - коллекция внешних наборов данных
//       * МакетОформления              - МакетОформленияКомпоновкиДанных   - Макет оформления, в соответствии с которым необходимо оформлять макет компоновки данных.
//       * ПроверятьДоступностьПолей    - Булево - Определяет, выполнять ли проверку прав на просмотр полей и проверку доступности поля во включенных функциональных возможностях.
//       * ПараметрыФункциональныхОпций - Булево - Содержит параметры функциональных опций, используемые при исполнении отчета.
//       * ВозможностьИспользованияВнешнихФункций - Булево - Указывает возможность использования функции общих модулей конфигурации в выражениях компоновки данных.
//
Процедура СКД_СкомпоноватьРезультатОтчета(Результат, СхемаКомпоновкиДанных, НастройкиКомпоновки, 
    ДанныеРасшифровки = Неопределено, ВнешниеНаборыДанных = Неопределено, ДополнительныеПараметры = Неопределено) Экспорт
           
    
    //Инициализируем настройки
    Если ТипЗнч(НастройкиКомпоновки) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
        ВыполняемыеНастройки    = НастройкиКомпоновки.ПолучитьНастройки();
    ИначеЕсли ТипЗнч(НастройкиКомпоновки) = Тип("Строка") И ЭтоАдресВременногоХранилища(НастройкиКомпоновки) Тогда
        ВыполняемыеНастройки    = ПолучитьИзВременногоХранилища(НастройкиКомпоновки);
    Иначе 
        ВыполняемыеНастройки    = НастройкиКомпоновки;   
    КонецЕсли;
    
    Если НЕ ТипЗнч(ВыполняемыеНастройки) = Тип("НастройкиКомпоновкиДанных") Тогда
        Возврат;
    КонецЕсли;
    

    //Инициализируем дополнительные параметры вывода
    ПараметрыВывода    = Новый Структура;
    ПараметрыВывода.Вставить("МакетОформления"                        , Неопределено);
    ПараметрыВывода.Вставить("ПроверятьДоступностьПолей"              , Истина);
    ПараметрыВывода.Вставить("ПараметрыФункциональныхОпций"           , Новый Структура);
    ПараметрыВывода.Вставить("ВозможностьИспользованияВнешнихФункций" , Ложь);
    
    Если НЕ ДополнительныеПараметры = Неопределено Тогда
        ЗаполнитьЗначенияСвойств(ПараметрыВывода, ДополнительныеПараметры);
    КонецЕсли;
    
    //Определяем тип генератора
    Если ТипЗнч(Результат) = Тип("ТаблицаЗначений") ИЛИ ТипЗнч(Результат) = Тип("ДеревоЗначений") Тогда
        ВыводВКоллекциюЗначений = Истина;
        ТипГенератораВывода     = Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений");
    Иначе
        ВыводВКоллекциюЗначений = Ложь;
        ТипГенератораВывода     = Тип("ГенераторМакетаКомпоновкиДанных");
    КонецЕсли;
    
    //Формируем макет, с помощью компоновщика макета
    КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
    
    //Передаем в макет компоновки схему, настройки и данные расшифровки
    МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, ВыполняемыеНастройки, 
    ДанныеРасшифровки, ПараметрыВывода.МакетОформления, ТипГенератораВывода, 
    ПараметрыВывода.ПроверятьДоступностьПолей, ПараметрыВывода.ПараметрыФункциональныхОпций);
    
    //Выполним компоновку с помощью процессора компоновки
    ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
    ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки, ВнешниеНаборыДанных, 
    ДанныеРасшифровки, ПараметрыВывода.ВозможностьИспользованияВнешнихФункций);
    
    //Выводим результат
    Если ВыводВКоллекциюЗначений Тогда
        ПроцессорВывода    = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
        ПроцессорВывода.УстановитьОбъект(Результат);
    Иначе
        ПроцессорВывода    = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
        ПроцессорВывода.УстановитьДокумент(Результат);
    КонецЕсли;
    
    ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);

КонецПроцедуры
#КонецЕсли // Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда


#КонецОбласти 
//СКДиДинамическийСписок //КонецОбласти

#Область СсылкиИОбъекты

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция возвращает менеджер объекта по переданному значению
// Значение может быть типом или ссылкой
//
// Параметры:
//  пОбъект  - Тип, Ссылка - Обязательный параметр
//           Объект, для которого необходимо определить менеджер
//
// Возвращаемое значение:
//   Произвольный   
//		- менеджер объетка при успешном выполнении (ДокументМенеджер, СправочникМенеджер и т.д.)
//	    или Неопределено, если получение менеджера для переданного значения невозможно
//
// 20140121 Заяш 
//
Функция Менеджер_Получить(Знач пОбъект) Экспорт

	Если ТипЗнч(пОбъект) = Тип("Тип") Тогда
		ТипОбъекта = пОбъект;
	ИначеЕсли ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда
		ТипОбъекта = Тип_ПолучитьПоМетаданным(пОбъект);
	Иначе
		ТипОбъекта = ТипЗнч(пОбъект);
	КонецЕсли;
	
	Если Не Тип_ЭтоСсылка(ТипОбъекта) Тогда
		Попытка
			ТипОбъекта = ТипЗнч(пОбъект.Ссылка);
		Исключение
		КонецПопытки;
		
	КонецЕсли;
	
	Если Не Тип_ЭтоСсылка(ТипОбъекта) Тогда
		Возврат Неопределено;
	КонецЕсли;
		
	ИмяОбъекта = Метаданные.НайтиПоТипу(ТипОбъекта).Имя;
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат Справочники[ИмяОбъекта];
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат Документы[ИмяОбъекта];
		
	#Если Не МобильноеПриложениеСервер Тогда		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат Задачи[ИмяОбъекта];
	#КонецЕсли	
	
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат Перечисления[ИмяОбъекта];
	Иначе
		Возврат НеОпределено;
	КонецЕсли;

КонецФункции
#КонецЕсли

#КонецЕсли

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция определяет наличение движения по регистрам для документа
//
Функция ОпределитьНаличиеДвиженийПоРегистратору(ДокументСсылка) Экспорт
	ТекстЗапроса = "";	
	// для исключения падения для документов, проводящимся более чем по 256 таблицам
	счетчик_таблиц = 0;
	
	МетаданнныеДокумента = ДокументСсылка.Метаданные();
	
	Если МетаданнныеДокумента.Движения.Количество() = 0 Тогда
		Возврат Новый ТаблицаЗначений;
	КонецЕсли;
	
	Для Каждого Движение ИЗ МетаданнныеДокумента.Движения Цикл
		// в запросе получаем имена регистров, по которым есть хотя бы одно движение
		// например,
		// ВЫБРАТЬ Первые 1 «РегистрНакопления.ТоварыНаСкладах»
		// ИЗ РегистрНакопления.ТоварыНаСкладах
		// ГДЕ Регистратор = &Регистратор
		
		// имя регистра приводим к Строка(200), см. ниже
		ТекстЗапроса = ТекстЗапроса + "
		|" + ?(ТекстЗапроса = "", "", "ОБЪЕДИНИТЬ ВСЕ ") + "
		|ВЫБРАТЬ ПЕРВЫЕ 1 ВЫРАЗИТЬ(""" + Движение.ПолноеИмя() 
		+  """ КАК Строка(200)) КАК Имя ИЗ " + Движение.ПолноеИмя() 
		+ " ГДЕ Регистратор = &Регистратор";
		
		// если в запрос попадает более 256 таблиц – разбиваем его на две части
		// (вариант документа с проведением по 512 регистрам считаем нежизненным)
		счетчик_таблиц = счетчик_таблиц + 1;
		Если счетчик_таблиц = 256 Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	ЗАпрос.УстановитьПараметр("Регистратор", ДокументСсылка);
	// при выгрузке для колонки «Имя» тип устанавливается по самой длинной строке из запроса
	// при втором проходе по таблице новое имя может не «влезть», по этому сразу в запросе
	// приводится к строка(200)
	ТаблицаЗапроса = Запрос.Выполнить().Выгрузить();
	
	// если количество таблиц не превысило 256 – возвращаем таблицу
	Если счетчик_таблиц = МетаданнныеДокумента.Движения.Количество() Тогда
		Возврат ТаблицаЗапроса;			
	КонецЕсли;
	
	// таблиц больше чем 256, делаем доп. запрос и дополняем строки таблицы.
	
	ТекстЗапроса = "";
	Для Каждого Движение ИЗ МетаданнныеДокумента.Движения Цикл
		
		Если счетчик_таблиц > 0 Тогда
			счетчик_таблиц = счетчик_таблиц - 1;
			Продолжить;
		КонецЕсли;
		
		ТекстЗапроса = ТекстЗапроса + "
		|" + ?(ТекстЗапроса = "", "", "ОБЪЕДИНИТЬ ВСЕ ") + "
		|ВЫБРАТЬ ПЕРВЫЕ 1 """ + Движение.ПолноеИмя() +  """ КАК Имя ИЗ " 
		+ Движение.ПолноеИмя() + " ГДЕ Регистратор = &Регистратор";	
		
		
	КонецЦикла;
	Запрос.Текст = ТекстЗапроса;
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		СтрокаТаблицы = ТаблицаЗапроса.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, Выборка);
	КонецЦикла;
	
	Возврат ТаблицаЗапроса;
	
КонецФункции
#КонецЕсли

// Функция определяет дату создания переменной ссылочного типа по ее уникальному идентификатору
// текст функции взят на  https://helpf.pro/faq/view/1099.html
//
// Параметры
//	Ссылка — обязательный, ссылка. Ссылка, дату создания которой необходимо определить
//
// Возвращает
//	Дата, дата создания ссылки
//
//
Функция Ссылка_ДатаСоздания_Получить(Ссылка) Экспорт
	
	#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
	Если Не ЭтоСсылка(Ссылка) Тогда
		ВызватьИсключение "Входящий параметр есть не ссылка";
	КонецЕсли;
	#КонецЕсли
	
	ГУИД = Ссылка.УникальныйИдентификатор();
	Строка16 = Сред(ГУИД, 16, 3) + Сред(ГУИД, 10, 4) + Сред(ГУИД, 1, 8);
	Разрядность = СтрДлина(Строка16);
	ЧислоСек = 0;
	Для Позиция = 1 По Разрядность Цикл
		ЧислоСек = ЧислоСек + Найти("123456789abcdef",Сред(Строка16,Позиция,1))*Pow(16,Разрядность - Позиция);
	КонецЦикла;
	ЧислоСек = ЧислоСек / 10000000;
	Возврат Дата(1582, 10, 15, 04, 00, 00) + ЧислоСек;
	
КонецФункции  

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция проверяет, есть ли у переданной ссылки нужный реквизит 
Функция Ссылка_ЕстьРеквизит(Ссылка, знач ИмяРеквизита = "") Экспорт
	
	ИмяРеквизита = СокрЛП(ИмяРеквизита);		
	
	Если Не ЭтоСсылка(Ссылка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Ссылка_Метаданные = Ссылка.Метаданные();
	
	Если Ссылка_Метаданные.Реквизиты.Найти(ИмяРеквизита) <> Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	Для Каждого СтандартныйРеквизит Из Ссылка_Метаданные.СтандартныеРеквизиты Цикл
		Если СтандартныйРеквизит.Имя = ИмяРеквизита Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	СтандартныйРеквизит = Неопределено;
	
	Возврат Ложь;

КонецФункции

Функция Ссылка_ЕстьТабличнаяЧасть(Ссылка, знач ИмяТабличнойЧасти = "") Экспорт
	
	Если Не ЭтоСсылка(Ссылка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Ссылка_Метаданные = Ссылка.Метаданные();
	
	ИмяТабличнойЧасти = СокрЛП(ИмяТабличнойЧасти);		

	Возврат Не Ссылка_Метаданные.ТабличныеЧасти.Найти(ИмяТабличнойЧасти) = Неопределено; 

КонецФункции // Ссылка_ЕстьТабличнаяЧасть()

Функция Ссылка_ЕстьРеквизитТабличнойЧасти(Ссылка, ИмяТабличнойЧасти, ИмяРеквизита) Экспорт
	
	Если Не ЭтоСсылка(Ссылка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Ссылка_Метаданные = Ссылка.Метаданные();
	
	ИмяТабличнойЧасти = СокрЛП(ИмяТабличнойЧасти);		

	ТабЧасть = Ссылка_Метаданные.ТабличныеЧасти.Найти(ИмяТабличнойЧасти);

	Если ТабЧасть = Неопределено Тогда // Нет такой таб. части в документе
		Возврат Ложь;

	Иначе
		Возврат НЕ ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено;

	КонецЕсли;

КонецФункции // ЕстьРеквизитТабЧастиДокумента()

#КонецЕсли //#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда

Функция Ссылка_ИмяТаблицы(СсылкаНаОбъект) Экспорт
	
	Возврат СтрЗаменить(СериализаторXDTO.XMLТипЗнч(СсылкаНаОбъект).ИмяТипа,"Ref.",".");
	
КонецФункции

#Если Клиент И Не ТолстыйКлиентОбычноеПриложение Тогда
//Функция предназначена для поиска открытой формы ссылки в управляемом интерфейсе
//
//Параметры: 
//		ИдентификаторСсылка -	обязательный, Ссылка 
// 								для которой будет выполнен поиск формы
//		
//Возвращает:
//		УправляемаяФорма
//		Если форма не найдена, возвращает неопределено
//
Функция Ссылка_НайтиФорму(ИдентификаторСсылка)
	
	// Искать окно объекта в открытых окнах
	Окна = ПолучитьОкна();
	
	ОбъектФормы = Неопределено;

	Для Каждого Окно1 из Окна Цикл
		
		Если Окно1.Основное Тогда
			Продолжить;
		КонецЕсли;
		
		Форма1 = Окно1.ПолучитьСодержимое();
		
		Попытка
			ОбъектФормы = Форма1.Объект;
			Если ОбъектФормы = Неопределено 
				ИЛИ ОбъектФормы.Ссылка <> ИдентификаторСсылка Тогда
				Продолжить;
			КонецЕсли;
		Исключение
			Продолжить;
		КонецПопытки;
		
		Возврат Форма1;
		
	КонецЦикла;	

	Возврат Неопределено;	
	
КонецФункции
#КонецЕсли // Если Клиент И Не ТолстыйКлиентОбычноеПриложение

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция Ссылка_ПроверитьУчастиеВДвижениях
//
//Функция для определения участвует ли номенклатура (можно любое другое измерение) в движениях
//Описание:
//		Необходима для контроля редактирования реквизитов справочника номенклатура
//		Движения проверяются по всей базе, вне зависимости от периода
//Параметры: 
//		СсылкаНаОбъект				-	обязательный, Ссылка или Объект
//										для которой будет проверятся участие в движенях;
//		ПроверятьРегистрыНакопления	-	необязательный, булево, по умолчанию истина
//										признак для осуществления поиска по регистрам накопления;
//		ПроверятьРегистрыСведений	-	необязательный, булево, по умолчанию истина
//										признак для осуществления поиска по регистрам сведений;
//		ПроверятьИзмерения			-	необязательный, булево, по умолчанию истина
//										признак для осуществления поиска по измерениям регистров;
//		ПроверятьРесурсы			-	необязательный, булево, по умолчанию истина
//										признак для осуществления поиска по реквизитам регистров.
//Возвращает
//		БылоДвижение	-	булево
//							было ли движение номенклатуры или нет
//
Функция Ссылка_ПроверитьУчастиеВДвижениях	(СсылкаНаОбъект, 
											ПроверятьРегистрыНакопления	=	Истина,
											ПроверятьРегистрыСведений	=	Истина,
											ПроверятьИзмерения			=	Истина,
											ПроверятьРесурсы			=	Истина
										) Экспорт;

	БылоДвижение	=	ложь; //Эта переменная которую возвращает функция
	МассивРегистров	=	Новый Массив();//Здесь будут храниться регистры по которым будет производится поиск движения
	
//Заполнить МассивРегистров

	Если ПроверятьРегистрыНакопления Тогда 
		Для Каждого Регистр из Метаданные.РегистрыНакопления Цикл 
			 МассивРегистров.Добавить(Регистр);
		КонецЦикла;
	КонецЕсли;
	Если ПроверятьРегистрыСведений Тогда 
		Для Каждого Регистр из Метаданные.РегистрыСведений Цикл 
			 МассивРегистров.Добавить(Регистр);
		КонецЦикла;
	КонецЕсли;

//Цикл поиска по регистрам

	Для Каждого Регистр Из МассивРегистров Цикл
		
		//Получим регистры и измерения по которым следует искать
		МассивИзмеренийИРесурсов	=	Новый Массив();
		//Добавим измерения
		Если ПроверятьИзмерения Тогда
			Для Каждого Измерение из Регистр.Измерения Цикл
				//Если в регистре есть измерение с такимже типом как переданное в функцию значение добавим его текстовое адрес в массив
				Если Измерение.Тип.СодержитТип(ТипЗнч(СсылкаНаОбъект.Ссылка)) Тогда
					МассивИзмеренийИРесурсов.Добавить(Измерение);	
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		//Добавим ресурсы
		Если ПроверятьРесурсы Тогда
			Для Каждого Ресурс из Регистр.Ресурсы Цикл
				//Если в регистре есть реквизит с такимже типом как переданное в функцию значение добавим его текстовый адрес в массив
				Если Ресурс.Тип.СодержитТип(ТипЗнч(СсылкаНаОбъект.Ссылка)) Тогда
					МассивИзмеренийИРесурсов.Добавить(Ресурс);	
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		//Запускаем цикл запросов по найденным реквизитам и измерениям. Если находим движение сразу прерываем функцию
		Для Каждого ИзмерениеИлиРесурс из МассивИзмеренийИРесурсов Цикл 
				
				Запрос	=	Новый Запрос;
				Запрос.Текст	= 	"ВЫБРАТЬ ПЕРВЫЕ 1"
								+ 	Символы.ПС
								+	"	1 КАК ПОЛЕ1" 
								+	Символы.ПС
								+ 	" 	ИЗ " 	+	Регистр.ПолноеИмя()	+	" КАК регистр"
								+	Символы.ПС
								+	"	ГДЕ регистр."	+	ИзмерениеИлиРесурс.Имя	+	" В (&Номенклатура)";
								
				Запрос.УстановитьПараметр("Номенклатура",СсылкаНаОбъект.Ссылка);
				
				//Если результат запроса не пустой - значит движения были
				//Вернем значение истина
				
				Если Не Запрос.Выполнить().Пустой() Тогда
					БылоДвижение	=	Истина;
					Возврат БылоДвижение;
				КонецЕсли;
							
		КонецЦикла; //Для Каждого ИзмерениеИлиРеквизит из МассивИзмеренийИРеквизитов Цикл 
		                
	КонецЦикла; //Для Каждого Регистр Из МассивРегистров Цикл
	
//Если функция закончила проверки и не нашла движений вернем ложь
	
	Возврат БылоДвижение;
	
КонецФункции //Ссылка_ПроверитьУчастиеВДвижениях
#КонецЕсли

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
//Функция Ссылка_ПроверитьНаличиеВДокументах (Ссылка) Экспорт
//
//Функция для определения есть ли ссылка на элемент справочника в документах
//Описание:
//		Необходима при проверки допустимости изменения реквизита справочника
//		Например нельзя менять коэффициент ЕИ если она внесена в один из документов
//Параметры:
//		Ссылка		- 	тип СправочникСсылка. Обязательный. 
//						Будет проверено наличие этой ссылки в документах
//Возвращает:
//		ЕстьСсылка	- 	булево, признак есть ли ссылка в документах
Функция Ссылка_ПроверитьНаличиеВДокументах (Ссылка) Экспорт

	ЕстьСсылка = Ложь;
	МассивДокументов = Новый Массив();//Здесь будут храниться документы по которым будет производится поиск движения
	
	//Заполняем документов и их табличных частей
	
	Для Каждого Документ из Метаданные.Документы Цикл 
		МассивДокументов.Добавить(Документ);
		Для Каждого ТЧ из Документ.ТабличныеЧасти Цикл
			МассивДокументов.Добавить(ТЧ);
		КонецЦикла;
	КонецЦикла;
	
	//Цикл поиска по документам и их табличным частям
	
	Для Каждого ДокументИлиТЧ Из МассивДокументов Цикл
		
		//Получим реквизиты по которым следует искать
		МассивРеквизитов	=	Новый Массив();
		//Добавим измерения
			Для Каждого Реквизит из ДокументИлиТЧ.Реквизиты Цикл
				//Если в регистре есть измерение с такимже типом как переданное в функцию значение добавим его текстовое адрес в массив
				Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
					МассивРеквизитов.Добавить(Реквизит);	
				КонецЕсли;
			КонецЦикла;
		
		//Запускаем цикл запросов по найденным реквизитам. Если находим ссылку сразу прерываем функцию
		Для Каждого Реквизит из МассивРеквизитов Цикл 
			
			Запрос	=	Новый Запрос;
				Запрос.Текст	= 	"ВЫБРАТЬ ПЕРВЫЕ 1"
								+ 	Символы.ПС
								+	"	1 КАК ПОЛЕ1" 
								+	Символы.ПС;
			Если ТипЗнч(ДокументИлиТЧ.Родитель()) = тип("ОбъектМетаданныхКонфигурация") Тогда//если это документ тогда
				Запрос.Текст 	= 	Запрос.Текст
								+ 	" 	ИЗ " 	+	ДокументИлиТЧ.ПолноеИмя()	+	" КАК ДокументИлиТЧ"
								+	Символы.ПС
								+	"	ГДЕ ДокументИлиТЧ."	+	Реквизит.Имя	+	" В (&Ссылка)";
			ИначеЕсли ТипЗнч(ДокументИлиТЧ.Родитель()) = тип("ОбъектМетаданных") Тогда//Если это ТЧ
				Запрос.Текст 	= 	Запрос.Текст
								+ 	" 	ИЗ " 	+	ДокументИлиТЧ.Родитель().ПолноеИмя() + "." + ДокументИлиТЧ.Имя +	" КАК ДокументИлиТЧ"
								+	Символы.ПС
								+	"	ГДЕ ДокументИлиТЧ."	+	Реквизит.Имя	+	" В (&Ссылка)";
			КонецЕсли;
			
			Запрос.УстановитьПараметр("Ссылка",Ссылка);
			
			//Если результат запроса не пустой - значит движения были
			//Вернем значение истина                                                 
			
			Если Не Запрос.Выполнить().Пустой() Тогда
				ЕстьСсылка	=	Истина;
				Возврат ЕстьСсылка;
			КонецЕсли;
			
		КонецЦикла; //Для Каждого Реквизит из МассивРеквизитов Цикл 
		
	КонецЦикла; //Для Каждого ДокументИлиТЧ Из МассивДокументов Цикл
	
	//Если функция закончила проверки и не нашла движений вернем ложь
	
	
	Возврат ЕстьСсылка;
	
КонецФункции
#КонецЕсли

Функция Ссылка_Реквизит_ПолучитьИзБД(Ссылка, ИмяРеквизита = "") Экспорт
	
	#Если ТонкийКлиент ИЛИ ВебКлиент ИЛИ МобильныйКлиент Тогда
		
	Возврат общ_Сервер.Ссылка_Реквизит_ПолучитьИзБД(Ссылка, ИмяРеквизита);
	
	#Иначе

	Если Не ЭтоСсылка(Ссылка) Тогда
		ВызватьИсключение "Параметр #1 должен иметь ссылочный тип";
	КонецЕсли;
	
	// Если ссылка не записана, вернуть неопределено
	Если Не ЗначениеЗаполнено(Ссылка.Ссылка) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Проверка_Тип(ИмяРеквизита, Тип("Строка"));
	
	// Если имя реквизита не заполнено, вернем неопределено
	Если ПустаяСтрока(ИмяРеквизита) Тогда 
		Возврат Неопределено;
	КонецЕсли;
	
	// Если у документа нет реквизита, вернем неопределено
	Если Не Ссылка_ЕстьРеквизит(Ссылка, ИмяРеквизита) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		СтрШаблон(
		"ВЫБРАТЬ 
		|%1 КАК ЗначениеРеквизита 
		|ИЗ %2.%3
		|ГДЕ Ссылка = &Ссылка",
		ИмяРеквизита, // %1
		Общ.КорневойТипКонфигурации_Получить(Ссылка), // %2
		Ссылка.Метаданные().Имя // %3
		);
	Запрос.УстановитьПараметр("Ссылка", Ссылка.Ссылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ЗначениеРеквизита;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	#КонецЕсли // #Если ТонкийКлиент ИЛИ ВебКлиент ИЛИ МобильныйКлиент Тогда
	
КонецФункции

Функция СсылкаСуществует(СсылкаНаОбъект) Экспорт
    
    Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СсылкаНаОбъект", СсылкаНаОбъект);
	Запрос.Текст = 
		СтрШаблон(
			"Выбрать Таб.Ссылка ИЗ %1 КАК Таб ГДЕ Таб.Ссылка = &СсылкаНаОбъект",
			Ссылка_ИмяТаблицы(СсылкаНаОбъект),
			);
			
	УстановитьПривилегированныйРежим(Истина);
	
	Результат = Не Запрос.Выполнить().Пустой();
	Запрос = Неопределено;

	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат Результат;
    
КонецФункции

// Процедура заполняет реквизит объекта если он пустой
// Иначе реквизит остается неизменным
//
// Параметры:
//  РеквизитОбъекта  - 	Произвольный - Обязательный
//						Реквизит объекта, который необходимо заполнить
//                 
//  ЗначениеРеквизита - Произвольный - Обязательный
//                 		Новое значение реквизита объекта
// 
// 20170801 Заяш 
//
Процедура Объект_ЗаполнитьРеквизитЕслиПустой(РеквизитОбъекта, ЗначениеРеквизита) Экспорт
	
	Если ЗначениеЗаполнено(РеквизитОбъекта) Тогда
		Возврат;
	КонецЕсли;
	
	Если РеквизитОбъекта <> ЗначениеРеквизита Тогда
		РеквизитОбъекта = ЗначениеРеквизита;
	КонецЕсли;
	
КонецПроцедуры

// Процедура обновляет реквизит объекта
// Процедура необходима чтобы не включалась модифицированность объекта
// т.е. если реквизит совпадает с переданным значением, то он не будет перезаписан 
//
// Параметры:
//  РеквизитОбъекта  - 	Произвольный - Обязательный
//						Реквизит объекта, который необходимо обновить
//                 
//  ЗначениеРеквизита - Произвольный - Обязательный
//                 		Новое значение реквизита объекта
// 
// 20170801 Заяш 
//
Процедура Объект_ОбновитьРеквизит(РеквизитОбъекта, ЗначениеРеквизита, ОбновлятьТолькоНезаполненныйРеквизитОбъекта = Ложь) Экспорт
	
	Проверка_Тип(ОбновлятьТолькоНезаполненныйРеквизитОбъекта, "Булево");

	// Если значение не заполнено, то ничего не реквизит объекта не меняем
	Если Не	ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
		Отказ = Истина;
	КонецЕсли;
	
	// Если реквизит объекта уже равен переданному значениею, то обновлять его не надо
	// Выйти
	Если РеквизитОбъекта = ЗначениеРеквизита Тогда
		Возврат;
	КонецЕсли;
	
	// Если надо обновлять только незаполненный реквизит объекта, 
	// а он уже заполнен, то выйти
	Если ОбновлятьТолькоНезаполненныйРеквизитОбъекта И ЗначениеЗаполнено(РеквизитОбъекта) Тогда
		Возврат;
	КонецЕсли;
	
	// Если все условия соблюдены, обновить реквизит
	РеквизитОбъекта = ЗначениеРеквизита;

КонецПроцедуры

// Функция для проверки существования объекта.
// Используется для поиска битых ссылок <Объект не найден>, а также для 
// определения, существует ли объект для ссылки, полученной по GUID
//
// Параметры:
//		ТестоваяСсылка - Обязательный, произвольная ссылка, для которой надо найти объект
//		
// Возвращает:
//		Булево, результат поиска объекта по ссылке
//
// 20120521 Заяш
// Взято отсюда: http://www.forum.mista.ru/topic.php?id=423487
//
// 20161121 Заяш
// Перенесено в модуль с полными правами
//
Функция Объект_Существует(ТестоваяСсылка) Экспорт
	
	Возврат общ_ПолныеПрава.Объект_Существует(ТестоваяСсылка);
	
КонецФункции  

// Процедура копирует реквизиты и табличные части объекта в структуру
//
// Параметры:
//		Объект — обязательный, справочник или документ или обработка
//		Структура — обязательный, структура
//
// Происхождение: ИТ
//
Процедура Объект_СкопироватьРеквизитыВСтруктуру(Ссылка,Структура) Экспорт
	
	Структура = общ_ПолныеПрава.Объект_ПолучитьСтруктуру(Ссылка);
	
КонецПроцедуры

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Процедура восстанавливает из структуры объект. 
// Сопоставление табличных частей и реквизитов происходит по имени.
//
// Происхождение: ИТ
//
Процедура Объект_ВосстановитьРеквизитыИзСтруктуры(Объект,Структура) Экспорт
	
	Для Каждого Реквизит Из Объект.Метаданные().Реквизиты Цикл
		Если Структура.Свойство(Реквизит.Имя) Тогда
			Объект[Реквизит.Имя]=Структура[Реквизит.Имя];
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ТабличнаяЧасть Из Объект.Метаданные().ТабличныеЧасти Цикл
		Если Структура.Свойство(Реквизит.Имя) Тогда
			Объект[ТабличнаяЧасть.Имя].Загрузить(Структура[ТабличнаяЧасть.Имя]);
		КонецЕсли;
	КонецЦикла
	
КонецПроцедуры
#КонецЕсли

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция получает объект БД по ссылке. 
// Если объект есть, то возвращает его, если нет, создает новый.
// Также функция может управлять параметром ПризнакНового (Булево), в который передается
// признак того, это новый объект, или он уже был в базе.
// 
// Параметры:
//		Ссылка - обязательный, ссылка на справочник, по которой нужно получить объект
//		ПризнакНововго - необязательный, булево. Признак нового объекта
//
// 20120515 Заяш
Функция Объект_ПолучитьПоСсылке(Ссылка,ПризнакНового = Ложь) Экспорт
	
	// Попытка получить объект.
	// Если попытка успешна, вернуть объект, установить признак нового Ложь
	Объект = Ссылка.ПолучитьОбъект();
	Если Объект <> Неопределено Тогда
		Объект.Разблокировать();
		ПризнакНового = Ложь;
		Возврат Объект;
	КонецЕсли;
	
	// Если объет неопределено, создадим новый и вернем его.
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Объект = Справочники[ИмяОбъекта].СоздатьЭлемент();
		Объект.УстановитьНовыйКод();
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Объект = Документы[ИмяОбъекта].СоздатьДокумент();
		
    #Если Не МобильноеПриложениеСервер Тогда
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Объект = ПланыВидовХарактеристик[ИмяОбъекта].СоздатьЭлемент();
		Объект.УстановитьНовыйКод();
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Объект = ПланыСчетов[ИмяОбъекта].СоздатьСчет();
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Объект = ПланыВидовРасчета[ИмяОбъекта].СоздатьВидРасчета();
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Объект = БизнесПроцессы[ИмяОбъекта].СоздатьБизнесПроцесс();
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Объект = Задачи[ИмяОбъекта].СоздатьЗадачу();
	#КонецЕсли // Не МобильноеПриложениеСервер 
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Объект = ПланыОбмена[ИмяОбъекта].СоздатьУзел();
		Объект.УстановитьНовыйКод();
   	Иначе
		Возврат Неопределено; // Если ничего не найдено, вернуть неопределено
	КонецЕсли;	
	Объект.УстановитьСсылкуНового(Ссылка);
	Объект.ОбменДанными.Загрузка = Истина;
	ПризнакНового = Истина;
	Возврат Объект;
	
КонецФункции
#КонецЕсли

// Данная функция предназначена для получения значений свойств объектов любого типа. 
// 
// В функцию передается сам объект и список свойств, значения которых требуется получить. 
// Если список не заполнен, то возвращаются все свойства. 
// 
// Возвращаемое значение является структурой, в которой наименования ключей совпадают с именами реквизитов объекта. 
//
// 20130918 Заяш. Функция взята из http://infostart.ru/public/201114/. Автор nick-max
//
Функция Объект_ПолучитьСвойства(Объект, Знач Свойства = "") Экспорт 	
	Попытка 		
		КоллекцияРеквизитов = Объект.Метаданные().Реквизиты;
		КоллекцияСтандартныхРеквизитов = Объект.Метаданные().СтандартныеРеквизиты;
		
		Если Свойства = "" Тогда 			
			Для каждого Реквизит из КоллекцияРеквизитов Цикл
 				Свойства = ?(Свойства = "", Реквизит.Имя, Свойства + ", " + Реквизит.Имя);
			КонецЦикла;
			
			Для каждого СтандартныйРеквизит из КоллекцияСтандартныхРеквизитов Цикл
 				Свойства = ?(Свойства = "", СтандартныйРеквизит.Имя, Свойства + ", " + СтандартныйРеквизит.Имя);
			КонецЦикла;
			
		КонецЕсли;
		
		Структура = Новый Структура(Свойства);
		ЗаполнитьЗначенияСвойств(Структура, Объект);
		Возврат Структура;
		
	Исключение
		Возврат Ложь
 	КонецПопытки 	
	
КонецФункции 

// Функция возвращает структуру, содержащую реквизиты и табличные части объекта.
// Табличные части выгружены в виде массивов структур.
// Сопоставление полей идет по именам.
// 
// Параметры:
//      Ссылка - обязательный, произвольная ссылка на объект информационной базы.
//		
// 20130227 Заяш
// Функция используется, если надо получить данные объекта без получения самого объекта.
// 20130918 Заяш
// Дописано получение стандартных реквизитов
// Функция работает с любыми ссылочными данными
// 20161121 Заяш
// Перенесено в модуль с полными правами
//
Функция Объект_ПолучитьСтруктуру(Ссылка) Экспорт
	 
	Возврат общ_ПолныеПрава.Объект_ПолучитьСтруктуру(Ссылка);
	
КонецФункции	

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
Функция ЭтоСсылка(пЗначение) Экспорт
	
	Если ТипЗнч(пЗначение) = Тип("Тип") Тогда	
		Возврат Тип_ЭтоСсылка(пЗначение);
	Иначе 
		Возврат Тип_ЭтоСсылка(ТипЗнч(пЗначение));
	КонецЕсли;

КонецФункции
#КонецЕсли

#КонецОбласти 
//Ссылки и объекты

#Область Строки

// Фунцкия для преобразование строки в MIME.
// Параметры:
//		СтрокаДляПреобразования - Обязательный, строка
//							строка, кототую необходимо преобразовать
// Возвращает:
//		строка, кодированная MIME
//
Функция Строка_ВMIME(СтрокаДляПреобразования) Экспорт
	
	СтрокаБукв = "ЁАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюяё '""&";
	СтрокаКодов = "A8C0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFFB820272226";
	СтрокаВыходная ="";
	Для Ном = 1 По СтрДлина(СтрокаДляПреобразования) Цикл
		Буковка = Сред(СтрокаДляПреобразования, Ном, 1);
		Номерок = Найти(СтрокаБукв, Буковка);
		Если Номерок > 0 Тогда
			СтрокаВыходная = СтрокаВыходная + "%" + Сред(СтрокаКодов, Номерок*2-1, 2);
		Иначе
			СтрокаВыходная = СтрокаВыходная + Буковка;
		КонецЕсли;
	КонецЦикла;
	Возврат СтрокаВыходная;
	
КонецФункции

// Функция преобразует входящую строку с разделителями в массив строк
// В отличии от стандартной функции "СтрРазделить" разделитель может состоять из нескольких символов
//
// Параметры:
//	стрИсходная - обязательный, строка, исходная строка с разделителями,
//				которую надо преобразовать в массив;
//	стрРазделитель - необязательный, строка, по умолчанию ""
//				разделитель исходной строки;
//
// Возвращает:
//		Массив, тип элементов массива - строка;
//
// Если разделитель не указан, элементами масива будут символы строки
// 
Функция Строка_ПреобразоватьВМассив(Знач стрИсходная, стрРазделитель = "", ВключатьПустые = Ложь) Экспорт 

	МассивРезультат = Новый Массив;
	
	// Если разделителя нет, сложим строку в массив по символам
	Если стрРазделитель = "" Тогда
		Для а=1 по СтрДлина(стрИсходная) Цикл
			МассивРезультат.Добавить(Сред(стрИсходная,а,1));
		КонецЦикла;		
		Возврат МассивРезультат;		
	КонецЕсли;
	
	ПозицияРазделителя = Найти(стрИсходная,стрРазделитель);
	Пока ПозицияРазделителя <> 0 Цикл
		МассивРезультат.Добавить(Сред(стрИсходная,0,ПозицияРазделителя-1));
		стрИсходная = Сред(стрИсходная,ПозицияРазделителя+1);
		ПозицияРазделителя = Найти(стрИсходная,стрРазделитель);
		
	КонецЦикла;
	
	МассивРезультат.Добавить(Сред(стрИсходная,ПозицияРазделителя));
	
	// Если Не включать пустые, Обойти массив в обратном порядке и удалить пустые элементы массива
	Если Не ВключатьПустые Тогда
		ИндексМассива = МассивРезультат.Количество();
		Пока ИндексМассива > 0 Цикл
			ИндексМассива = ИндексМассива - 1;
			Если ПустаяСтрока(МассивРезультат[ИндексМассива]) Тогда
				МассивРезультат.Удалить(ИндексМассива);
			КонецЕсли;
			
		КонецЦикла;
		ИндексМассива = Неопределено;

	КонецЕсли; // Не включать пустые
 
	Возврат МассивРезультат;	
	
КонецФункции

// Функция объединяет строки переданные в параметре через пробел
// Пустые параметры игнорируются
// Функция предназначена для использования в СКД
//
// Параметры:
//		стр1..стр10 
//			- необязательный, строка, исходная строка, которую необходимо соединить
//
// Возвращает:
//		Строка, результат объединения строк
//
// 20170612 Заяш 
Функция Строка_СоединитьСтроки(
		стр1 = "", 
		стр2 = "", 
		стр3 = "",
		стр4 = "",
		стр5 = "",
		стр6 = "",
		стр7 = "",
		стр8 = "",
		стр9 = "",
		стр10 = ""
		) Экспорт
		
	стрРезультат = "";
	стрПараметр = "";
	
	Для сч = 1 По 10 Цикл
		
		Выполнить("стрПараметр = стр" + сч);
		
		Если стрПараметр = "" Тогда
			Продолжить;
		КонецЕсли;
		
		Если Не ПустаяСтрока(стрРезультат) Тогда
			стрРезультат = стрРезультат + " ";
		КонецЕсли;
		
		стрРезультат = стрРезультат + стрПараметр;
		
	КонецЦикла;
	сч = Неопределено;
	
	Пока Найти(стрРезультат, "  ") Цикл
		стрРезультат = СтрЗаменить(стрРезультат, "  ", " ");
	КонецЦикла;
	
	стрРезультат = СокрЛП(стрРезультат);
	
	Возврат стрРезультат;
	
КонецФункции

// Функция объединяет две строки и ставит между ними разделитель. Если одна из строк является пустой,
// То разделитель не ставится. Если разделитель  не определен ставится запятая-пробел ", "
//
// Параметры:
//		строка1 
//			- обязательный, строка, начальная строка
// 		строка2 
//			- обязательный, строка, конечная строка
//		разделитель 
//			- необязательный, строка. 
//			разделитель между начальной и конечной строкой
//			по умолчанию запятая ","
//
Функция Строка_СоединитьСтрокиЧерезРазделитель(стр1,стр2,стрРазделитель = Неопределено) Экспорт
	
	стрРезультат = СокрЛП(стр1);
	
	Если Не ПустаяСтрока(стрРезультат) Тогда
		Если Не ПустаяСтрока(СокрЛП(стр2)) Тогда
			Если стрРазделитель = Неопределено Тогда
				стрРазделитель = ", ";
			КонецЕсли;
			стрРезультат = стрРезультат + стрРазделитель;
		КонецЕсли;
	КонецЕсли;
	
	стрРезультат = СокрЛП(стрРезультат+стр2);
	
	Возврат стрРезультат;
	
КонецФункции

// Удаляет двойные кавычки с начала и конца строки, если они есть.
//
// Параметры:
//  Строка       - входная строка;
//
// Возвращаемое значение:
//  Строка - строка без двойных кавычек.
// 
Функция Строка_СократитьДвойныеКавычки(Знач Строка) Экспорт
	
	Результат = Строка;
	Пока Найти(Результат, """") = 1 Цикл
		Результат = Сред(Результат, 2); 
	КонецЦикла; 
	Пока Найти(Результат, """") = СтрДлина(Результат) Цикл
		Результат = Сред(Результат, 1, СтрДлина(Результат) - 1); 
	КонецЦикла; 
	Возврат Результат;
	
КонецФункции 

// Функция предназначена для удаления ствоенных символов. Например сдвоенных
// пробелов или ПС. Функция рекурсивная.
//
//	Параетры:
//		стрИсходная - 	обязательный, строка,
//						строка, в которой необходимо убрать дубли символов;
//		Символ - 	обязательный, строка,
//					символ, дубли которого следует искать;
//	Возвращает: 
//		Строка, без дублей символов;
//
Функция Строка_СократитьДвойныеСимволы(Знач стрИсходная, Символ) Экспорт
	
	стрРезультат = СтрЗаменить(стрИсходная,Символ+Символ,Символ);
	
	Если СтрДлина(стрИсходная) = СтрДлина(стрРезультат) Тогда
		Возврат стрРезультат;
	Иначе
		Возврат Строка_СократитьДвойныеСимволы(стрРезультат, Символ);
	КонецЕсли;
	
КонецФункции

// Оставляет в строке только цифры, все остальные символы удаляются
Функция Строка_ТолькоЦифры(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Фунцкия для транслитерации русски строк.
// Параметры:
//		стрРусскоеСлово - Обязательный, строка
//							строка, кототую необходимо транслитерировать
// Возвращает:
//		строка, транслитерированная входная строка
Функция Строка_Транслит(стрРусскоеСлово) Экспорт
	 
	стрРус 	="АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"
			+"абвгдеёжзийклмнопрстуфхцчшщъыьэюя"; 
	стрАнг 	="A///B///V///G///D///E///Yo//Zh//Z///I///Y///K///L///M///N///O///P///R///S///T///U///F///Kh//Ts//Ch//Sh//Shch'///Y///////E///Yu//Ja//" 
			+"a///b///v///g///d///e///yo//zh//z///i///y///k///l///m///n///o///p///r///s///t///u///f///kh//ts//ch//sh//shch'///y///////e///yu//ja//"; 
	стрРезультат = ""; 
	Для i = 1 по СтрДлина(стрРусскоеСлово) Цикл 
		s = Сред(стрРусскоеСлово, i,1); 
		k = Найти(стрРус, s); 
		Если k = 0 тогда 
			стрРезультат = стрРезультат + s; 
		Иначе 
			стрРезультат = стрРезультат + СтрЗаменить(Сред(стрАнг, (k - 1) * 4 + 1, 4), "/", ""); 
		КонецЕсли; 
	КонецЦикла; 
	Возврат стрРезультат;
	
КонецФункции

#Если Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция предназначена для удаления недопустимых символов из строки
//	Параметры:
//		стр - обязательный, строка
//				Исходная строка, из которой будут удаляться символы
//		ДопустимыеСимволы - Обязательный, строка
//				Строка, содержащая допустимые символы. Например "абвг"
Функция Строка_УдалитьНедопустимыеСимволы(стр, ДопустимыеСимволы) Экспорт

	Возврат СтрСоединить(СтрРазделить(стр, СтрСоединить(СтрРазделить(стр, ДопустимыеСимволы))))

КонецФункции
#КонецЕсли // #Если Не ВебКлиент И Не МобильныйКлиент Тогда

#Если Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция удаляет в строке недопустимые символы XML
//
// Параметры:
//	СтрокаХМЛ - Обязательный, строка
//				Строка, в которой необходимо удалить недопустимые символы
//				После выполнения функции из строки будут удалены недопустиые в XML символы
//
// Возвращает:
//	Булево. Результат выполнения. 
//	Если Истина, были удалены символы, строка изменена
//	Если Ложь, символов удалено не было, строка не изменена
//
//	20151211 Заяш
//  Прототип взыть отсюда: http://www.1s-portal.ru/index.php/stati/obmendannymi/12-xml/70-udalit-nedopustimye-simvoly-ml.html
//
 Функция Строка_УдалитьНедопустимыеСимволыXML(СтрокаХМЛ)
	 
	 Результат = Ложь;
	 Позиция = НайтиНедопустимыеСимволыXML(СтрокаХМЛ);
	 Пока Позиция <> 0 Цикл
		 Результат = Истина;
		 НедопустимыйСимвол = Сред(СтрокаХМЛ, Позиция,1);
		 СтрокаХМЛ = СтрЗаменить(СтрокаХМЛ, НедопустимыйСимвол, "");
		 Позиция = НайтиНедопустимыеСимволыXML(СтрокаХМЛ, Позиция-1);
	 КонецЦикла; 
	 
	 Возврат Результат;
	 
КонецФункции
#КонецЕсли //Если Не ВебКлиент И Не МобильныйКлиент 

#Если Не ВебКлиент И Не МобильныйКлиент И Не МобильноеПриложениеСервер Тогда
// Функция проверяет, является ли строка правильным адресом
// электронной почты
//
//	Параметры:
//		Обязательный, строка, адрес электронной почты, который необходимо проверить
//
//	Возвращает:
//		Булево, результат проверки переданной в параметр строки
//		Истина если это адрес электронной почты
//		Ложь в противном случае
//
//	Ниже функции и процедуры, необходимые для работы
//
//	Взято из разработки http://infostart.ru/public/141198
//	Автор dour-dead  http://infostart.ru/profile/43625/
//
Функция Строка_ЭтоАдресЭлектроннойПочты(EMail) Экспорт
	
	RegExp = Новый COMОбъект("VBScript.RegExp");// создаем объект для работы с регулярными выражениями
	RegExp.MultiLine = Ложь;					// истина — текст многострочный, ложь — одна строка
	RegExp.Global = Истина;						// истина — поиск по всей строке, ложь — до первого совпадения
	RegExp.IgnoreCase = Истина;					// истина — игнорировать регистр строки при поиске
	Шаблон = "^([A-Za-z0-9])+([A-Za-z0-9_\.-])*@([A-Za-z0-9]+)(([\.\-]?[A-Za-z0-9]+)*)\.([A-Za-z])+$"; //Шаблон = ".+@.+\..+"; //шаблон проверки e-mail //Шаблон = "|^[-0-9a-z_\.]+@[-0-9a-z_^\.]+\.[a-z]{2,6}$|i";
	RegExp.Pattern = Шаблон;					// шаблон (регулярное выражение)
	
	Если RegExp.Test(EMail) Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции
#КонецЕсли //Если Не ВебКлиент И Не МобильныйКлиент 

Функция ФорматированнаяСтрока_ВыделитьВхождение(Знач ВходящаяСтрока, ПодстрокаДляВыделения, Знач ЦветВыделения = Неопределено) Экспорт
	
	Проверка_Тип(ВходящаяСтрока, "Строка");
	Проверка_Тип(ПодстрокаДляВыделения, "Строка");
	
	Если ЦветВыделения = Неопределено Тогда
		#Если ТонкийКлиент ИЛИ ВебКлиент ИЛИ МобильныйКлиент Тогда
			ЦветВыделения = WebЦвета.Красный;
		#Иначе
			ЦветВыделения = ЦветаСтиля.ЦветОсобогоТекста;
		#КонецЕсли
	КонецЕсли;
	
	Проверка_Тип(ЦветВыделения, Тип("Цвет"));
	
	СимволРазделителя = Символы.НПП;
	
	// Заменить в исходной строке подстроку для выделения на подстроку с разделителями
	ВходящаяСтрока = 
		СтрЗаменить(
			ВходящаяСтрока, 
			ПодстрокаДляВыделения, 
			СимволРазделителя + ПодстрокаДляВыделения + СимволРазделителя
			);
	
	// Разделить строку в массив по символу разделителя
	МассивЧастейВходящейСтрокиСтроки = 
		СтрРазделить(
			ВходящаяСтрока,
			СимволРазделителя,
			Ложь // Не включать пустые
			);
			
	// Массив частей для сборки результата
	МассивЧастейИсходящейСтроки = Новый Массив;

	// Обойти массив частей строки
	Для Каждого ЧастьСтроки Из МассивЧастейВходящейСтрокиСтроки Цикл
		
		// Если эта часть строки совпадает с подстрокой выделения
		// тогда преобразовать ее в выделенную форматированную строку
		Если ЧастьСтроки = ПодстрокаДляВыделения Тогда
			ЧастьСтроки = Новый ФорматированнаяСтрока(ЧастьСтроки, , ЦветВыделения);
		КонецЕсли;

		// Добавить часть в массив частей исходящей строки
		МассивЧастейИсходящейСтроки.Добавить(ЧастьСтроки);
		
	КонецЦикла;
	
	// Сформировать и вернуть форматированную строку
	Возврат Новый ФорматированнаяСтрока(МассивЧастейИсходящейСтроки);

КонецФункции
	
#КонецОбласти 
//Строки

#Область ТабличныйДокумент

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция для преобразования табличного документа в таблицу значений.
// Предполагается, что в первой строке табличного документа содержаться имена колонок.
//
// Параметры
//  ТабличныйДокумент
//		Обязательный, ТабличныйДокумент
//		Табличный документ, который нужно преобразовать в таблицу значений
//
// Возвращаемое значение:
//   ТаблицаЗначений
//
// 20121010 Заяш
//
Функция ТабличныйДокумент_ВТаблицуЗначений(ТабличныйДокумент) Экспорт
	
	ТЗ=Новый ТаблицаЗначений();
	
	//Считываем колонки
	Для Стр=1 По ТабличныйДокумент.ВысотаТаблицы Цикл
		#Если Клиент Тогда
			ОбработкаПрерыванияПользователя();
		#КонецЕсли
		Если Стр>1 Тогда
			ТекСтр=ТЗ.Добавить();
		КонецЕсли;
		ПустаяСтрока=истина;
		Для Кол=1 По ТабличныйДокумент.ШиринаТаблицы Цикл
			Яч=ТабличныйДокумент.Область(Стр, Кол);
			Если Яч.СодержитЗначение Тогда
				Зн=Яч.Значение;
			Иначе
				Зн=Яч.Текст;
			КонецЕсли;
			Если ТипЗнч(Зн)=Тип("Строка") И ПустаяСтрока(Зн) Тогда
				Зн=Неопределено;
			КонецЕсли;
			
			//Добавляем колонку
			Если Стр=1 Тогда
				
				// В имени колонки убрать пробелы
				Зн = СокрЛП(Зн);
				Зн = СтрЗаменить(Зн, " ", "_");
				Зн = СтрЗаменить(Зн, Символы.ПС, "");
				Зн = СтрЗаменить(Зн, "-", "");
				
				// Если в таблице уже есть колонка стаким именем, добавить номер
				Если ТЗ.Колонки.Найти(Зн) <> Неопределено Тогда
					Счетчик = 0;
					
					Пока Истина Цикл
						Счетчик = Счетчик + 1;
						
						ЗнСоСчетчиком = Зн + "_" + Счетчик;
						
						НайденнаяКолонка = ТЗ.Колонки.Найти(ЗнСоСчетчиком);
						
						Если НайденнаяКолонка = Неопределено Тогда
							Зн = ЗнСоСчетчиком;
							Прервать;
							
						Иначе
							Продолжить;
							
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;
				
				ТЗ.Колонки.Добавить(Зн, ОписаниеТиповСтроки_Получить(255));
				
			Иначе
				ТекСтр[Кол-1]=Зн;
				
			КонецЕсли;
			
		КонецЦикла;
		Кол = Неопределено;
		
	КонецЦикла;
	Стр = Неопределено;
	
	Возврат ТЗ;
	
КонецФункции // ТабличныйДокумент_ВТаблицуЗначений()
#КонецЕсли

// Процедура рассчитывает и устанавливает ширину колонок в табличном документе
// 
// Параметры
//	ТабличныйДокумент - ТабличныйДокумент, обязательный
//						Табличный документ, в котором надо устаровить ширину колонок
//
// Происходит с ИТС
// Код взять с http://help1c.com/faq/view/417.html
//
// 20140126 Заяш 
//
Процедура ТабличныйДокумент_Колонки_УстановитьШиринуАвтоматически(ТабличныйДокумент) Экспорт
    
    Перем МаксимальноеКоличествоСтрок, МаксимальнаяШиринаКолонки;
    Перем КонечнаяСтрока, НачальнаяСтрока, ТекущаяКолонка, ТекущаяСтрока, НачалоДанных;
    Перем ОбластьШапки, ОбластьПодвала;
    Перем ШиринаКолонки, ТекстЯчейки, НомерСтрокиТекста;
    Перем КоличествоУровнейГруппировокСтрок, Отступ;
    Перем ШириныКолонок;
    
    // Максимальное количество строк отчета, которые будут использованы для расчета ширин колонок
 
    МаксимальноеКоличествоСтрок = 50;
    // Ограничение максимальной ширины колонки
 
    МаксимальнаяШиринаКолонки = 50;
    // Массив, в который будут помещаться ширины колонок
 
    ШириныКолонок = Новый Массив;
    // Получим количество уровней группировок в отчете для учета автоматического отступа
 
    КоличествоУровнейГруппировокСтрок = ТабличныйДокумент.КоличествоУровнейГруппировокСтрок();
    
    // Инициализируем начальные строки
 
    НачальнаяСтрока = 0;
    НачалоДанных = 0;
    
    // Найдем в результирующем документе область шапки таблицы
 
    ОбластьШапки = ТабличныйДокумент.Области.Найти("ШапкаТаблицы");
    Если ТипЗнч(ОбластьШапки) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
        
        // Из шапки таблицы получим начальную строку с которой будем рассчитывать ширины
         НачальнаяСтрока = ОбластьШапки.Верх;
        НачалоДанных = ОбластьШапки.Низ + 1;
    Иначе
        
        // Если область шапки таблицы не найдена, найдем область шапки строк
         ОбластьШапки = ТабличныйДокумент.Области.Найти("ШапкаСтрок");
        Если ТипЗнч(ОбластьШапки) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
            
            // Из шапки таблицы получим начальную строку с которой будем рассчитывать ширины
             НачальнаяСтрока = ОбластьШапки.Верх;
            НачалоДанных = ОбластьШапки.Низ + 1;
            
        КонецЕсли;
    КонецЕсли;
    
    // Получим область подвала отчета и вычислим конечную строку расчета
 
    ОбластьПодвала = ТабличныйДокумент.Области.Найти("Подвал");
    Если ТипЗнч(ОбластьПодвала) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
        // Область подвала найдена
        КонечнаяСтрока = ОбластьПодвала.Верх - 1;
        Если КонечнаяСтрока - НачальнаяСтрока > МаксимальноеКоличествоСтрок Тогда
            КонечнаяСтрока = НачальнаяСтрока + МаксимальноеКоличествоСтрок;
        КонецЕсли;
    Иначе 
            // Область подвала не найдена
        КонечнаяСтрока = НачальнаяСтрока + МаксимальноеКоличествоСтрок;
    КонецЕсли;
    
    // Ограничим конечную строку
    КонечнаяСтрока = Мин(КонечнаяСтрока, ТабличныйДокумент.ВысотаТаблицы);
    // Переберем все колонки отчета
    Для ТекущаяКолонка = 1 По ТабличныйДокумент.ШиринаТаблицы Цикл
        АвтоОтступ = 0;
        // Переберем строки, которые будут использованы для расчета ширин колонок
        Для ТекущаяСтрока = НачальнаяСтрока По КонечнаяСтрока Цикл
            ШиринаКолонки = 0;
            // Получим область текущей ячейки
            ОбластьЯчейки = ТабличныйДокумент.Область(ТекущаяСтрока, ТекущаяКолонка);
            Если ОбластьЯчейки.Лево <> ТекущаяКолонка Или ОбластьЯчейки.Верх <> ТекущаяСтрока Тогда
                // Данная ячейка принадлежит объединенным ячейкам и не является начальной ячейкой
                Продолжить;
            КонецЕсли;
            Если КоличествоУровнейГруппировокСтрок > 0 И ТекущаяСтрока = НачалоДанных Тогда
                // Для первой строки с данными получим значение автоотступа
                АвтоОтступ = ОбластьЯчейки.АвтоОтступ;
            КонецЕсли;
            // Получим текст ячейки
            ТекстЯчейки = ОбластьЯчейки.Текст;
            // Для каждой строки из текста ячейки рассчитаем количество символов в строке
            Для НомерСтрокиТекста = 1 По СтрЧислоСтрок(ТекстЯчейки) Цикл
                ШиринаТекстаЯчейки = СтрДлина(СтрПолучитьСтроку(ТекстЯчейки, НомерСтрокиТекста));
                // Если используется автоотступ, то прибавим к ширине ячейки его величину
                Если АвтоОтступ <> Неопределено И АвтоОтступ > 0 Тогда
                    ШиринаТекстаЯчейки = ШиринаТекстаЯчейки + КоличествоУровнейГруппировокСтрок * АвтоОтступ;
                КонецЕсли;
                ШиринаКолонки = Макс(ШиринаКолонки, ШиринаТекстаЯчейки);
            КонецЦикла;

            Если ШиринаКолонки > МаксимальнаяШиринаКолонки Тогда
                // Ограничим ширину колонки
                ШиринаКолонки = МаксимальнаяШиринаКолонки;
            КонецЕсли;
            Если ШиринаКолонки <> 0 Тогда
                // Ширина колонки рассчитана
                // Определим, сколько ячеек по ширине используется в области для текущей ячейки
                КоличествоКолонок = ОбластьЯчейки.Право - ОбластьЯчейки.Лево;
                // Переберем все ячейки, расположенные в области
                 Для НомерКолонки = 0 По КоличествоКолонок Цикл
                    Если ШириныКолонок.ВГраница() > ТекущаяКолонка - 1 + НомерКолонки Тогда
                        // В массиве ширин колонок уже был элемент для текущей колонки
                        Если ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = Неопределено Тогда
                            // Значение ширины колонки еще не было установлено
                            ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = ШиринаКолонки / (КоличествоКолонок + 1);
                        Иначе
                            // Значение ширины колонки уже было установлено
                             // Вычислим максимум ширины колонки
                             ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = 
                                Макс(ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки], ШиринаКолонки / (КоличествоКолонок + 1));
                        КонецЕсли;
                    Иначе
                        // В массиве ширин колонок еще не было элемента для данной колонки
                        // Добавим элемент в массив ширин колонок
                        ШириныКолонок.Вставить(ТекущаяКолонка - 1 + НомерКолонки, ШиринаКолонки / (КоличествоКолонок + 1));
                    КонецЕсли;
                КонецЦикла;
            КонецЕсли;
        КонецЦикла;    // Конец цикла перебора строк
    КонецЦикла;    // Конец цикла перебора колонок
    
    // Переберем все элементы в массиве вычисленных ширин колонок
     Для ТекущаяКолонка = 0 По ШириныКолонок.ВГраница() Цикл
        Если ШириныКолонок[ТекущаяКолонка] <> Неопределено Тогда
            // Ширина колонок установлена
            // Установим ширину области ячеек
            ТабличныйДокумент.Область(, ТекущаяКолонка + 1, НачалоДанных, ТекущаяКолонка + 1).ШиринаКолонки = ШириныКолонок[ТекущаяКолонка] + 1;
        КонецЕсли;
    КонецЦикла;
КонецПроцедуры 

#Если Не ВебКлиент И Не МобильныйКлиент И Не МобильноеПриложениеСервер Тогда
// Функция получает текстовое содержание табличного документа
//
// Параметры:
//		ТабДокумент - Обязательный, ТабличныйДокумент
//			Табличный документ, из которого надо получить текст
//	Возвращает:
//		Строка
//
Функция ТабличныйДокумент_ПолучитьТекст(ТабДокумент) Экспорт
	
	Текст = "";
	
	ВремФайл = Файл_ПолучитьВременныйФайл("TXT").ПолноеИмя;
	ТабДокумент.Записать(ВремФайл,ТипФайлаТабличногоДокумента.TXT);
	Текст = Новый ТекстовыйДокумент;
    Текст.Прочитать(ВремФайл);
    Текст = Текст.ПолучитьТекст();
	Попытка
		УдалитьФайлы(ВремФайл);
	Исключение
	КонецПопытки;
	
	Возврат Текст;
	
КонецФункции
#КонецЕсли

#Если Не ВебКлиент И Не МобильныйКлиент И Не МобильноеПриложениеСервер Тогда
Функция ТабличныйДокумент_ПолучитьТекстHTML(ТабДокумент) Экспорт
	
	ТекстHTML = "";
	
	ВремФайл = Файл_ПолучитьВременныйФайл("HTML").ПолноеИмя;
	ТабДокумент.Записать(ВремФайл,ТипФайлаТабличногоДокумента.HTML);
	ТекстHTML = Новый ТекстовыйДокумент;
    ТекстHTML.Прочитать(ВремФайл);
    ТекстHTML = ТекстHTML.ПолучитьТекст();
	Попытка
		УдалитьФайлы(ВремФайл);
	Исключение
	КонецПопытки;
	
	Возврат ТекстHTML;
	
КонецФункции
#КонецЕсли

//Функция предназначена для сборки частей  из массива в один табличный документ.
//Параметры
//		МассивЧастейтТабДок - Обязательный, масиив данных типа "ТабличныйДокумент"
//		ТабДокумент - 	Необязательный, табличный документ к которому следует присоеденить части из массива
//						Если этот параметр не определен, будет создан новый табличный документ
//Возвращает
//		ТабДокумент - Табличный документ состоящий из частей содержащихся в массиве
Функция ТабличныйДокумент_ПрисоеденитьМассив(МассивЧастейтТабДок,ТабДокумент = Неопределено) Экспорт
	
	// Для Отладки
	Если Ложь Тогда
		МассивЧастейтТабДок = Новый Массив;
		ТабДокумент = Новый ТабличныйДокумент;
	КонецЕсли;
	
	Проверка_Тип(МассивЧастейтТабДок, Тип("Массив"));
	Если ТабДокумент <> Неопределено Тогда
		Проверка_Тип(ТабДокумент, Тип("ТабличныйДокумент"));
	КонецЕсли;
	
	Если ТабДокумент = Неопределено Тогда
		ТабДокумент = Новый ТабличныйДокумент;
	КонецЕсли;
	
	Если МассивЧастейтТабДок.Количество() > 0 Тогда
		Для Каждого ЧастьТабДок Из МассивЧастейтТабДок Цикл
			ТабДокумент.Вывести(ЧастьТабДок);
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТабДокумент;
	
КонецФункции

#КонецОбласти 
//ТабличныйДокумент

#Область ТаблицаЗначений
#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда

// Дополнительный конструктор таблицы значений
// Создает таблицу значений по переданной таблице значений, дереву значений
// или строке описания колонок. 
// Строка описания колонок должна содержать имена колонок, разделенные запятыми.
//
Функция ТаблицаЗначений_Создать(ОписаниеКолонок) Экспорт
	
	//Для отладки
	Если Ложь Тогда
		ОписаниеКолонок = Новый ТаблицаЗначений;
	КонецЕсли;
	
	МассивДопустимыхТипов = Новый Массив;
	МассивДопустимыхТипов.Добавить(Тип("ДеревоЗначений"));
	МассивДопустимыхТипов.Добавить(Тип("ТаблицаЗначений"));
	МассивДопустимыхТипов.Добавить(Тип("Строка"));
	
	Проверка_Тип(ОписаниеКолонок, Новый ОписаниеТипов(МассивДопустимыхТипов));
	
	ТЗ = Новый ТаблицаЗначений;
	
	Если ТипЗнч(ОписаниеКолонок) = Тип("Строка") Тогда
		МассивИменКолонок = СтрРазделить(ОписаниеКолонок,",");
		
		Для Каждого ИмяКолонки Из МассивИменКолонок Цикл
			Попытка
				ТЗ.Колонки.Добавить(СокрЛП(ИмяКолонки));
			Исключение
			КонецПопытки;
		КонецЦикла;
		
	Иначе
		Для Каждого ИсходнаяКолонка Из ОписаниеКолонок.Колонки Цикл
			ТЗ.Колонки.Добавить(ИсходнаяКолонка.Имя, ИсходнаяКолонка.ТипЗначения, ИсходнаяКолонка.Заголовок, ИсходнаяКолонка.Ширина);
		КонецЦикла;
		ИсходнаяКолонка = Неопределено;
	КонецЕсли;
		
	Возврат ТЗ;
	
КонецФункции

// Функция для преобазования таблицы значений в дерево значений
// Для работы процедуры, необходимо чтобы в таблице были колонки "Родитель" и "ГУИД"
//
// Параметры: 
//	Дерево - обязательный, дерево значений, исходное дерево
//	Таблица - обязательный, таблица значений, таблица результата
//	ГУИД - необязательный, уникальный идентификатор. Нужен для обеспечения рекурсии
//			в коде параметр не заполнять
//
// Возвращает:
//	Дерево значений, преобразованное из таблицы значений
//
Функция ТаблицаЗначений_ВДеревоЗначений_Рекурсия(ТаблицаЗначенийИсточник, ДеревоЗначенийПриемник = Неопределено, Знач ГУИД = Неопределено)
	
	// Для отладки
	Если Ложь Тогда
		ДеревоЗначенийПриемник = Новый ДеревоЗначений;
		ТаблицаЗначенийИсточник = Новый ТаблицаЗначений;
	КонецЕсли;
	
	Если ГУИД = Неопределено Тогда
		Проверка_Тип(ТаблицаЗначенийИсточник, Тип("ТаблицаЗначений"));
		КолонкаРодитель = ТаблицаЗначенийИсточник.Колонки.Найти("Родитель");
		Если КолонкаРодитель = Неопределено Тогда
			ВызватьИсключение "В таблице-источнике нет колонки ""Родитель""";
		ИначеЕсли Не КолонкаРодитель.ТипЗначения.СодержитТип(Тип("УникальныйИдентификатор")) Тогда
			ВызватьИсключение "Колонка ""Родитель"" таблицы-источника должна иметь ТипЗначения = Тип(""УникальныйИдентификатор"")";
		КонецЕсли;
			
		КолонкаГУИД = ТаблицаЗначенийИсточник.Колонки.Найти("ГУИД");
		Если КолонкаРодитель = Неопределено Тогда
			ВызватьИсключение "В таблице-источнике нет колонки ""ГУИД""";
		ИначеЕсли Не КолонкаРодитель.ТипЗначения.СодержитТип(Тип("УникальныйИдентификатор")) Тогда
			ВызватьИсключение "Колонка ""ГУИД"" таблицы-источника должна иметь ТипЗначения = Тип(""УникальныйИдентификатор"")";
		КонецЕсли;
			
		Если ДеревоЗначенийПриемник = Неопределено Тогда
			ДеревоЗначенийПриемник = ДеревоЗначений_Создать(ТаблицаЗначенийИсточник);
		КонецЕсли;
		
		Проверка_Тип(ДеревоЗначенийПриемник, Тип("ДеревоЗначений"));
		ГУИД = Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000");
	КонецЕсли;
	
	СтруктураПоискаСтрокТаблицы = Новый Структура("Родитель", ГУИД);
	МассивНайденныхСтрокТаблицы = ТаблицаЗначенийИсточник.НайтиСтроки(СтруктураПоискаСтрокТаблицы);
	Для Каждого СтрокаТаблицы Из МассивНайденныхСтрокТаблицы Цикл
		СтрокаДерева = ДеревоЗначенийПриемник.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаТаблицы);
		ТаблицаЗначений_ВДеревоЗначений_Рекурсия(СтрокаДерева, ТаблицаЗначенийИсточник, СтрокаТаблицы.ГУИД);
	КонецЦикла;
	СтрокаТаблицы = Неопределено;
	
	Возврат ДеревоЗначенийПриемник;
	
КонецФункции

// Функция преобразует полученную таблицу значений в табличный документ
//
// Параметры
//  ТабЗначений
//		Обязательный, таблица значений
//
// Возвращаемое значение:
//	Табличный документ, полученный из таблицы значений.
//
// 20120917 17:10:49 Заяш
//
Функция ТаблицаЗначений_ВТабличныйДокумент(ТабЗначений) Экспорт
	
	#Если Клиент Тогда
		Состояние("Создание табличного документа.");
	#КонецЕсли
	
	ТабДок = Новый ТабличныйДокумент;
    ОбластьЗаголовка = ТабДок.ПолучитьОбласть(1, , 1, );
    ДетальнаяСтрока = ТабДок.ПолучитьОбласть(1, , 1, );
    КоличествоКолонок = ТабЗначений.Колонки.Количество();
	
    Для КолонкаТЗ = 0 По КоличествоКолонок - 1 Цикл
        Область = ОбластьЗаголовка.Область(1, КолонкаТЗ + 1);
        Область.Текст = ТабЗначений.Колонки[КолонкаТЗ].Имя;
    КонецЦикла;
    ТабДок.Вывести(ОбластьЗаголовка);
	
    Для Каждого СтрокаТЗ Из ТабЗначений Цикл
        Для ТекущееПоле = 0 По КоличествоКолонок - 1 Цикл
            Область = ДетальнаяСтрока.Область(1, ТекущееПоле + 1);
			ЗначениеЯчейки = СтрокаТЗ[ТекущееПоле];
			Область.Текст = ЗначениеЯчейки; 
			Область.ПараметрРасшифровки = "РасшифровкаЯчейки"+ТекущееПоле;
			Область.Расшифровка = ЗначениеЯчейки;
        КонецЦикла;
        ТабДок.Вывести(ДетальнаяСтрока);
	КонецЦикла;
	
	#Если Клиент Тогда
		Состояние("");
	#КонецЕсли
	
	ТабДок.ТолькоПросмотр = Истина;
	Возврат ТабДок;
        
КонецФункции

//Функция предназначена для объединения двух таблиц значений с одинаковой структурой колонок
//Передаваемые параметры;
//	ТЗ - Обязательный, таблица значений;
//	ТЗ1 - Обязательный, таблица значенией;
//	Сворачивать - не обязательный, булево. По умолчанию ложь. Признак того, следует ли сворачивать полученную ТЗ.
//Возвращает;
//	Результат - Таблица значений
Функция   ТаблицаЗначений_ОбъединитьТаблицы(ТЗ,ТЗ1,Сворачивать = Ложь) Экспорт
	
	Перем Запрос;
	Перем МВТ;
	Перем Результат; //Возвращаемое значение
	
	МВТ = Новый МенеджерВременныхТаблиц;
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МВТ;
	Запрос.Текст = "ВЫБРАТЬ
				   |	*
				   |ПОМЕСТИТЬ ТЗ
	               |ИЗ
	               |	&ТЗ КАК ТЗ
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ 
	               |	*
				   |ПОМЕСТИТЬ ТЗ1
	               |ИЗ
	               |	&ТЗ1 КАК ТЗ1";
					
	Запрос.УстановитьПараметр("ТЗ", ТЗ);
	Запрос.УстановитьПараметр("ТЗ1",ТЗ1);
	Запрос.Выполнить();
	
	Если Сворачивать Тогда
		Запрос.Текст = 	"Выбрать Различные 
						|	* 
						|Поместить Т 
						|	Из 
						|		(Выбрать 
						|			* 
						|		Из ТЗ 
						|
						|		ОБЪЕДИНИТЬ ВСЕ 
						|		
						|		Выбрать 
						|			* 
						|		Из ТЗ1) КАК ТТ";
		Запрос.Выполнить();
	Иначе
		Запрос.Текст = 	"Выбрать 
						|	* 
						|Поместить Т 
						|	Из 
						|		(Выбрать 
						|			* 
						|		Из ТЗ 
						|
						|		ОБЪЕДИНИТЬ ВСЕ 
						|		
						|		Выбрать 
						|			* 
						|		Из ТЗ1) КАК ТТ";
		Запрос.Выполнить();
	КонецЕсли;
	
	Запрос.Текст = "ВЫБРАТЬ * ИЗ Т
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
				   |УНИЧТОЖИТЬ Т
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |УНИЧТОЖИТЬ ТЗ
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |УНИЧТОЖИТЬ ТЗ1";
				   
	Результат = Запрос.Выполнить().Выгрузить();
		
	Возврат Результат;
	
КонецФункции

// Процедура заполняет строку ТЗ из Структуры
// Соответствия определяются по ключам структуры и именам колонок ТЗ
//
// Параметры:
//		СтрокаТЗ — Обязательный, строка таблицы значений
//		Структура — Обязательный, структура
//
Процедура ТаблицаЗначениейСтрока_ЗаполнитьИзСтруктуры(СтрокаТЗ,Структура) Экспорт
	
	Для Каждого ЭлементСтруктуры Из Структура Цикл
		Попытка
			СтрокаТЗ[ЭлементСтруктуры.Ключ] = ЭлементСтруктуры.Значение;			
		Исключение
		КонецПопытки;	
	КонецЦикла;
	
КонецПроцедуры

// Функция предназначена для создания структуры из строки ТЗ
// Ключи структуры соответствуют именам колонок
// Значения структуры соответствуют значенимя колонок
//
// Параметры:
//		СтрокаТЗ - Обязательный, строка таблицы значений
//
// Возвращает 
//		Струкутуру 
//
Функция   ТаблицаЗначениейСтрока_ПоместитьВСтруктуру(СтрокаТЗ) Экспорт

	Структура = Новый Структура;
	
	Для Каждого Колонка Из СтрокаТЗ.Владелец().Колонки Цикл
		
		Структура.Вставить(Колонка.Имя,СтрокаТЗ[Колонка.Имя]);
		
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

#КонецЕсли // Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда

#КонецОбласти 
//ТаблицаЗначений

#Область Типы

// Определяет корневой тип конфигурации по описанию типов, типу, метаданным, ссылке или объекту.
// Для описания типов берется первый тип массива типов.
// Для субобъектов конфигурации не возвращает имя корневого типа.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем метаданные.
//
// Возвращаемое значение:
//               – Строка - имя типа конфигурации;
//  Неопределено - не удалось получить имя типа.
//
// Автор: TormozIT
// Взять отсюда: http://kb.mista.ru/article.php?id=5
//
#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
Функция КорневойТипКонфигурации_Получить(Знач пОбъект) Экспорт

    Если ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда 
        МетаданныеТипа = пОбъект;
    Иначе
        Если ТипЗнч(пОбъект) = Тип("ОписаниеТипов") Тогда
            Если пОбъект.Типы().Количество() > 0 Тогда 
                пОбъект = пОбъект.Типы()[0];
            Иначе
                Возврат Неопределено;
            КонецЕсли;
        КонецЕсли;
        Если ТипЗнч(пОбъект) = Тип("Тип") Тогда
            МетаданныеТипа = Метаданные.НайтиПоТипу(пОбъект);
        Иначе
            МетаданныеТипа = Метаданные.НайтиПоТипу(ТипЗнч(пОбъект));
        КонецЕсли;
    КонецЕсли;
    Если МетаданныеТипа <> Неопределено Тогда 
        МассивФрагментов = СтрРазделить(МетаданныеТипа.ПолноеИмя(),".");
        Если МассивФрагментов.Количество() = 2 Тогда 
            Возврат МассивФрагментов[0];
        Иначе
            // Ссылка на субобъект
        КонецЕсли;
    КонецЕсли;
    Возврат Неопределено;
    
КонецФункции // ЛксПолучитьКорневойТипКонфигурации()
#КонецЕсли

// Проверяет, является ли строка именем корневого типа объекта БД.
//
// Параметры:
//  пИмяКорневогоТипа - Строка, Неопределено - имя корневого типа.
//
// Возвращаемое значение:
//  Истина       – тип является корневым типом объекта БД;
//  Ложь         – иначе.
//
// 20140121 Заяш 
// Автор TormozIT
// Взято из подсистемы "ИнструментыРазработчика"
// ирГлобальный.ЛксЛиКорневойТипОбъектаБД
//
Функция КорневойТипКонфигурации_Проверить(КорневойТип) Экспорт

	Если Ложь
		ИЛИ КорневойТип = "БизнесПроцесс" 
		ИЛИ КорневойТип = "Задача" 
		ИЛИ КорневойТип = "Документ"
		ИЛИ КорневойТип = "ПланВидовРасчета" 
		ИЛИ КорневойТип = "ПланВидовХарактеристик" 
		ИЛИ КорневойТип = "ПланОбмена"
		ИЛИ КорневойТип = "ПланСчетов" 
		ИЛИ КорневойТип = "Справочник"
	Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиКорневойТипОбъектаБД()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ОписаниеТиповДаты_Получить(ЧастиДаты) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));

	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);

	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);

КонецФункции // ПолучитьОписаниеТиповДаты() 

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ОписаниеТиповСтроки_Получить(ДлинаСтроки) Экспорт

	Возврат Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная));

КонецФункции // ОписаниеТиповСтроки_Получить()

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ОписаниеТиповЧисла_Получить(Разрядность,РазрядностьДробнойЧасти=0) Экспорт

	Массив = Новый Массив;

	Массив.Добавить(Тип("Число"));
	КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность,РазрядностьДробнойЧасти);

	Возврат Новый ОписаниеТипов(Массив, КвалификаторЧисла);

КонецФункции // ПолучитьОписаниеТиповЧисла() 

// Возвращает строковое представление типа. 
// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта"
// Для остальных типов приводит тип к строке, например "Число".
//
// 20130331 Заяш. Функция взята из модуля ОбщегоНазначения стандартных конфигураций
Функция Тип_ПолучитьСтроковоеПредставление(Знач Тип) Экспорт

	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
		
		Представление = "";
		
		Если Не ТипЗнч(Тип) = Тип("Тип") Тогда
			Тип = ТипЗнч(Тип);
		КонецЕсли;	
		
		Если ЭтоСсылка(Тип) Тогда
		
			ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
			ИмяОбъекта = СтрРазделить(ПолноеИмя, ".")[1];
			
			Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
				Представление = "СправочникСсылка";
			
			ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
				Представление = "ДокументСсылка";
			
			ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
				Представление = "БизнесПроцессСсылка";
			
			ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
				Представление = "ПланВидовХарактеристикСсылка";
			
			ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
				Представление = "ПланСчетовСсылка";
			
			ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
				Представление = "ПланВидовРасчетаСсылка";
			
			ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
				Представление = "ЗадачаСсылка";
			
			ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
				Представление = "ПланОбменаСсылка";
			
			ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
				Представление = "ПеречислениеСсылка";
				
			
			КонецЕсли;
			
			Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
			
		Иначе
			
			Результат = Строка(Тип);
			
		КонецЕсли;
		
		Возврат Результат;
	
	#Иначе // Все кроме толстого клиента обычного приложения выполнять на сервере
		
		// Выполнать через попытку, чтобы исключить передачу мутабельного значения на сервер
		Попытка
			Возврат общ_Сервер.Тип_ПолучитьСтроковоеПредставление(Тип);
			
		Исключение
			Возврат Строка(Тип);
			
		КонецПопытки;
		
	#КонецЕсли
	
КонецФункции

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Проверка того, что тип имеет ссылочный тип данных
//
// Параметры:
//	Тип — Тип или объект метаданных
//		необходимо проверить, педставляет ли этот тип
//
//	Возвращает:
//		Булево — признак того, что это ссылка
//
Функция Тип_ЭтоСсылка(Знач Тип) Экспорт
 
	Если Тип = Тип("Неопределено") Тогда
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ТипЗнч(Тип) = Тип("Тип") Тогда
		Возврат 
			Справочники.ТипВсеСсылки().СодержитТип(Тип)
			ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
			ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
			
			#Если Не МобильноеПриложениеСервер Тогда
			ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
			ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
			ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
			ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
			ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
			ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
			#КонецЕсли
			
			ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип);
			
	ИначеЕсли ТипЗнч(Тип) = Тип("ОбъектМетаданных") Тогда
		Возврат
			Метаданные.Справочники.Содержит(Тип)
			ИЛИ Метаданные.Документы.Содержит(Тип)
			ИЛИ Метаданные.Перечисления.Содержит(Тип)
			ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(Тип)
			
			#Если Не МобильноеПриложениеСервер Тогда
			ИЛИ Метаданные.ПланыСчетов.Содержит(Тип)
			ИЛИ Метаданные.ПланыВидовРасчета.Содержит(Тип)
			ИЛИ Метаданные.БизнесПроцессы.Содержит(Тип)
			ИЛИ Метаданные.Задачи.Содержит(Тип)
			#КонецЕсли
			
			ИЛИ Метаданные.ПланыОбмена.Содержит(Тип);
			
	Иначе
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции
#КонецЕсли

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция Тип_ПолучитьПустоеЗначение(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	ИначеЕсли ЗаданныйТип = Тип("Неопределено") Тогда
		Возврат Неопределено;
	ИначеЕсли ТипЗнч(ЗаданныйТип) = Тип("ОписаниеТипов") Тогда
		Если ЗаданныйТип.Типы().Количество() = 0 Тогда
			Возврат Неопределено;
		Иначе
			Возврат Новый(ЗаданныйТип.Типы()[0]);
		КонецЕсли;
	ИначеЕсли ТипЗнч(ЗаданныйТип) = Тип("Тип") Тогда
		Возврат Новый(ЗаданныйТип);
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Получает ссылочный тип по метаданным.
//
// Параметры:
//  пМетаданные  – ОбъектМетаданных.
//
// Возвращаемое значение:
//               – Тип - ссылочный;
//  Неопределено – тип нельзя получить.
//
// 20140121 Заяш 
// Автор TormozIT
// Взять из подситстемы ИнструментыРазработчика
// ирГлобальный.ЛксПолучитьСсылочныйТипПоМетаданным(пМетаданные)
//
Функция Тип_ПолучитьПоМетаданным(пМетаданные) Экспорт

	Результат = Неопределено;
	КорневойТип = КорневойТипКонфигурации_Получить(пМетаданные);
	Если КорневойТипКонфигурации_Проверить(КорневойТип) Тогда 
		Результат = Тип(КорневойТип + "Ссылка." + пМетаданные.Имя);
	КонецЕсли;
	Возврат Результат;

КонецФункции // Тип_ПолучитьПоМетаданным()
#КонецЕсли

#КонецОбласти 
// Типы

#Область Файлы

# Если Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция Файл_ПолучитьВременныйФайл(Расширение) Экспорт
// Функция возвращает имя временного файла на диске с заданным расширением
Функция Файл_ПолучитьВременныйФайл(Расширение) Экспорт
	
	Перем Результат;
	
	Результат = Новый Файл(ПолучитьИмяВременногоФайла(Расширение));
	
	Возврат Результат;
	
КонецФункции

// Функция ФайлМСОфиисВВебАрхив(ПолноеИмяФайла)
//
// Функция предназначена для сохранения файла МС Оффис как веб архива (*.mht)
// Сохранение производиться через запуск МС офиса
// 
// Параметры:
//	 	ПолноеИмяФайла — 	обязательный строка,
//							путь к файлу;
// Возращает:
//	 	Строка - при удачном выполнении, путь к файлу *.mht
//		Неопределено - при неудачном выполнении;
//
Функция Файл_МСОфиисВВебАрхив(ПолноеИмяФайла) Экспорт
	
	Перем Результат;
	
	Попытка
		Файл = Новый Файл(ПолноеИмяФайла);
		Расширение = нрег(Файл.Расширение);
		Если Найти(".html .htm .mhtml .mht", Расширение) > 0 тогда
			Результат = Файл.ПолноеИмя;
		ИначеЕсли Найти(".doc .docx", Расширение) > 0 тогда
			Файл = Файл_ПолучитьВременныйФайл("mht");
			ДокументОбъект_COM = ПолучитьCOMОбъект(ПолноеИмяФайла);
			ДокументОбъект_COM.SaveAs(Файл.ПолноеИмя, 9); //9 = wdFormatWebArchive
			ДокументОбъект_COM.Close();
			ДокументОбъект_COM = Неопределено; 
			Результат = Файл.ПолноеИмя;
			
		ИначеЕсли Найти(".xls", Расширение) > 0 тогда
			Файл = Файл_ПолучитьВременныйФайл("mht");
			ДокументОбъект_COM = ПолучитьCOMОбъект(ПолноеИмяФайла);
			ДокументОбъект_COM.SaveAs(Файл.ПолноеИмя, 45); //45 = xlWebArchive
			ДокументОбъект_COM.Close();
			ДокументОбъект_COM = Неопределено; 
			Результат = Файл.ПолноеИмя;
		Иначе
			ВызватьИсключение("Тип файла не поддерживается: '" + Расширение + "'");
		КонецЕсли;
	Исключение
		СообщитьОбОшибке("Не удалось конвертировать файл "+ПолноеИмяФайла+ " в *.mht по причине: " +ОписаниеОшибки());
		Результат = Неопределено;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

#КонецЕсли

#КонецОбласти

#Область Формы_ОбычноеПриложение

#Если ТолстыйКлиентОбычноеПриложение Тогда

// Вспомогательная процедура для обработки декомпиляции форм
// http://infostart.ru/public/99363/
//
Процедура ЭлементФормы_УстановитьПоложение(Элемент,Верх,Высота,Лево,Ширина) Экспорт

    Элемент.Верх = Верх;

    Элемент.Высота = Высота;

    Элемент.Лево = Лево;

    Элемент.Ширина = Ширина;

КонецПроцедуры

// Функция спрашивает пользователя записать ли объект, или нет, если он новый
//
// Параметры
//  ФормаОбъекта - Форма объекта, из которой пытаются произвести действия
//
// Возвращаемое значение:
//   Булево - Объект записан или нет
//
Функция ЗаписатьНовыйОбъектВФорме(ФормаОбъекта) Экспорт

	Если ФормаОбъекта.ЭтоНовый() Тогда
		Если Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(ФормаОбъекта.ЭтотОбъект.Ссылка)) Тогда
			ТекстВопроса = "Для выполнения данной операции необходимо записать документ. Записать?";
		Иначе // Справочник
			ТекстВопроса = "Для выполнения данной операции необходимо записать элемент. Записать?";
		КонецЕсли; 
		Ответ = Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет);
		Если Ответ <> КодВозвратаДиалога.Да Тогда
			Возврат Ложь;
		Иначе
			Попытка
				Возврат ФормаОбъекта.ЗаписатьВФорме();
			Исключение
				Сообщить(ОписаниеОшибки());
				Возврат Ложь;
			КонецПопытки;
		КонецЕсли;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЗаписатьНовыйОбъектВФорме()

// Функция ищет элемент управления на форме, который управляет основным реквизитом формы
//
// Параметры
//	Форма — Обязательный, обычная неуправляемая форма
//
// Возвращает
//	ЭлементУправления — элемент управления основного реквизита формы
// 
// 20151120 Заяш
//
Функция Форма_ЭлементУправленияОсновногоРеквизита_Получить(Форма) Экспорт
	
	Проверка_Тип(Форма, Тип("Форма"));
	
	ИмяОсновногоРеквизитаФормы = Форма_ПолучитьИмяОсновногоРеквизита(Форма);
	
	ЭлементУправленияОсновоногоРеквизитаФормы = Неопределено;
	Для Каждого ЭлементУправления Из Форма.ЭлементыФормы Цикл
		Если ЭлементУправления.Данные = ИмяОсновногоРеквизитаФормы Тогда
			ЭлементУправленияОсновоногоРеквизитаФормы = ЭлементУправления;
			Прервать;
		КонецЕсли;		
	КонецЦикла;
		
	Возврат ЭлементУправленияОсновоногоРеквизитаФормы;
	
КонецФункции

#КонецЕсли // ТолстыйКлиентОбычноеПриложение

// ========



// ФОРМА В XML

// http://infostart.ru/public/57431/
// Эти функции позволят получать из любой формы 1С 8.1 массив ее реквизитов, а также ее основной реквизит. 
// Главные функции - ПолучитьМассивИменРеквизитовФормы и ПолучитьИмяОсновногоРеквизитаФормы. 
// Функция СтрокаВнутрВХМЛТело взята отсюда http://infostart.ru/projects/1801. 
// Если будете применять в реальном времени, делайте кэширование ДокументDOM.
//
// Эти процедуры и функции продублированы в модуле ирГлобальный, там они имеют префик "Лкс"
// Дублирование сделано для независимости конфигурации от подсистемы "Инструменты разработчика".

#Если ТолстыйКлиентОбычноеПриложение Тогда
Функция СтрокаВнутрВХМЛТело(вхСтрока, выхХМЛТело = Неопределено) Экспорт
	
	//{ Получение одной длинной строки
	выхХМЛТело = СтрЗаменить(вхСтрока,СИМВОЛЫ.ПС,"");
	выхХМЛТело = СтрЗаменить(выхХМЛТело,СИМВОЛЫ.ВК,"");
	//}
	
	//{ Заменяем символы, критичные для XML
	//	& на &amp;
	//	< на &lt;
	//	> на &gt;
	выхХМЛТело = СтрЗаменить(выхХМЛТело,"&","&amp;");
	выхХМЛТело = СтрЗаменить(выхХМЛТело,"<","&lt;");
	выхХМЛТело = СтрЗаменить(выхХМЛТело,">","&gt;");
	//}
	
	//{ Замена одинарных символов
	выхХМЛТело = СтрЗаменить(выхХМЛТело,",","</data><data>");
	выхХМЛТело = СтрЗаменить(выхХМЛТело,"{","<elem><data>");
	выхХМЛТело = СтрЗаменить(выхХМЛТело,"}","</data></elem>");
	//}
	
	//{ Удаляем лишние блоки <data><elem> и </data></elem>
	выхХМЛТело = СтрЗаменить(выхХМЛТело,"<data><elem>","<elem>");
	выхХМЛТело = СтрЗаменить(выхХМЛТело,"</elem></data>","</elem>");
	//}
	
	//{ Добавляем перенос строки к </data> и к </elem> для удобства поиска различий
	выхХМЛТело = СтрЗаменить(выхХМЛТело,"</elem>","</elem>"+СИМВОЛЫ.ПС);
	выхХМЛТело = СтрЗаменить(выхХМЛТело,"</data>","</data>"+СИМВОЛЫ.ПС);
	//}
	
	Возврат выхХМЛТело;
	
КонецФункции

Функция Форма_ПолучитьДокументDOMФормы(Форма) Экспорт 
	
	СтрокаФормы = ЗначениеВСтрокуВнутр(Форма);
	XMLСтрокаФормы = СтрокаВнутрВХМЛТело(СтрокаФормы);
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(XMLСтрокаФормы);
	ПостроительDOM = Новый ПостроительDOM;
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	Возврат ДокументDOM;
	
КонецФункции // ПолучитьДокументDOMФормы()

Функция Форма_ПолучитьМассивИменРеквизитов(Форма) Экспорт
	
	ДокументDOM = Форма_ПолучитьДокументDOMФормы(Форма);
	РазыменовательПИ = Новый РазыменовательПространствИменDOM(ДокументDOM);
	ИмяЭлемента = "/elem[1]/elem[1]/elem[2]/elem[2]/elem/data[4]";
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(ИмяЭлемента + "/text()", ДокументDOM,
	РазыменовательПИ, ТипРезультатаDOMXPath.НеупорядоченныйИтераторУзлов);
	Массив = Новый Массив;
	Пока 1 = 1 Цикл
		Узел = РезультатXPath.ПолучитьСледующий();
		Если Узел = Неопределено Тогда
			Прервать;
		КонецЕсли;
		Текст = Узел.ТекстовоеСодержимое;
		Длина = СтрДлина(Текст);
		Текст = Сред(Текст, 2, Длина - 2);
		Массив.Добавить(Текст);
	КонецЦикла;
	Возврат Массив;
	
КонецФункции // 

Функция Форма_ПолучитьИмяОсновногоРеквизита(Форма) Экспорт
	
	ДокументDOM = Форма_ПолучитьДокументDOMФормы(Форма);
	РазыменовательПИ = Новый РазыменовательПространствИменDOM(ДокументDOM);
	ИмяЭлемента = "/elem[1]/elem[1]/elem[2]/elem[1]/data[1]/text()";
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(ИмяЭлемента, ДокументDOM, РазыменовательПИ, ТипРезультатаDOMXPath.Строка);
	КлючОсновногоРеквизита = РезультатXPath.СтроковоеЗначение;
	
	ИмяЭлемента = "/elem[1]/elem[1]/elem[2]/elem[2]/elem/elem[1]/data[1]/text()";
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(ИмяЭлемента, ДокументDOM, РазыменовательПИ,
	ТипРезультатаDOMXPath.УпорядоченныйИтераторУзлов);
	Счетчик = 1;
	Пока 1 = 1 Цикл
		Узел = РезультатXPath.ПолучитьСледующий();
		Если Узел = Неопределено Тогда
			Прервать;
		КонецЕсли;
		Если Узел.ТекстовоеСодержимое = КлючОсновногоРеквизита Тогда
			Прервать;
		КонецЕсли;
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	Если Узел = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИмяЭлемента = "/elem[1]/elem[1]/elem[2]/elem[2]/elem[" + Счетчик + "]/data[4]/text()";
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(ИмяЭлемента, ДокументDOM, РазыменовательПИ, ТипРезультатаDOMXPath.Строка);
	Длина = СтрДлина(РезультатXPath.СтроковоеЗначение);
	Возврат Сред(РезультатXPath.СтроковоеЗначение, 2, Длина - 2);
	
КонецФункции // 
#КонецЕсли

#КонецОбласти 
//Формы_ОбычноеПриложение

#Область ЧислаСуммы

// Функция преднезначена для расчета рентабельности в процентах
// Писалась для использования в вычисляемых полях компоновки данных
// 
// Параметры:
//		Вход - обязательный, число , входная сумма (сумма закупки)
//		Выход - обязательный, число, выходная сумма (сумма продажи)
//		Точность - необязательный, число. Точность округления
//
// Возвращает:
//		рентабельность, число
//
Функция   РасчитатьРентабельность(Вход,Выход,Точность=2) Экспорт
	
	Рентабельность = 0;
	
	Если Вход = 0  и Выход = 0 Тогда 
		Возврат 0;
	КонецЕсли;
	
	Попытка
		Если Вход <> 0 Тогда
			Рентабельность = Окр((Выход-Вход)/Вход*100,Точность);
		Иначе
			Рентабельность = 100;
		КонецЕсли;
	Исключение КонецПопытки;
	
	Возврат Рентабельность;
	
КонецФункции

// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция  ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт

	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(ЗначениеНеЗаполнено(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(ЗначениеНеЗаполнено(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);

	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если Не ЗначениеНеЗаполнено(Валюта) Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;

	Возврат РезультирующаяСтрока;

КонецФункции // ФорматСумм()

// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция  СформироватьСуммуПрописью(Сумма, Валюта) Экспорт

	Если Валюта.ПараметрыПрописиНаРусском = "" Тогда
		Возврат ФорматСумм(Сумма);
	Иначе
		Возврат ЧислоПрописью(Сумма, ,Валюта.ПараметрыПрописиНаРусском);
	КонецЕсли;

КонецФункции // СформироватьСуммуПрописью()

//Функция получения модуля числа
//Параметр: число
//Возвращаемое значение: число
Функция  ВзятьПоМодулю(Число) Экспорт
	
	Если Число < 0 Тогда
		
		Число = -Число;
		
	КонецЕсли;
	
	Возврат Число;
	
КонецФункции

//Функция округления числа вверх до целого
//Параметры:
//		Число	-	Обязательный, число,
//					Число для округления
//Возвращает:
//		ОВЧисло	-	число округленное вверх
Функция  ОкрВверх(Число) Экспорт

	//Ноль округлять не будем
	Если Число = 0 Тогда
		Возврат 0;
	КонецЕсли;
	
	//Округлим число до целого
	ОВЧисло	=	Окр(Число,0);
	
	//Если число округлилось вниз добавим ему единицу.
	Если ОВЧисло < Число Тогда
		ОВЧисло	=	ОВЧисло + 1;
	КонецЕсли;
	
	Возврат ОВЧисло;
	
КонецФункции

//Функция округления числа вниз до целого
//Параметры:
//		Число	-	Обязательный, число,
//					Число для округления
//Возвращает:
//		ОВЧисло	-	число округленное вверх
Функция  ОкрВниз(Число) Экспорт

	//Ноль округлять не будем
	Если Число = 0 Тогда
		Возврат 0;
	КонецЕсли;
	
	//Округлим число до целого
	ОВЧисло	=	Окр(Число,0);
	
	//Если число округлилось вверх отнимем единицу.
	Если ОВЧисло > Число Тогда
		ОВЧисло	=	ОВЧисло - 1;
	КонецЕсли;
	
	Возврат ОВЧисло;
	
КонецФункции

// Функция для отображения микрографиков в полях ввода
// 
// Параметры: 
//		Доля 
//			необязательный, число 0..1
//			Число, для котогоро необходимо построить микрограф
//		Масштаб
//			необязательный, целое положительное число
//		    Сколько делений отображает единицу. 
//			По умолчанию 10
//	
//	Возвращает:
//		Строка типа ||||| 50%
//			
Функция ТекстМикрограф(Доля=0, Масштаб = 10) Экспорт
    
    ПроцентГраф="";
    
    Для к = 1 по (Доля*Масштаб) Цикл ПроцентГраф = ПроцентГраф + "|";	КонецЦикла;
    
    Если ЗначениеЗаполнено(ПроцентГраф) Тогда
        ПроцентГраф = ПроцентГраф + " " + Формат(Доля*100, "ЧДЦ=0; ЧРД=,; ЧРГ=' '; ЧГ=3,0") + "%";
    Иначе
        ПроцентГраф = "0 %";
    КонецЕсли;
        
    Возврат ПроцентГраф;
    
КонецФункции  

Функция ЧислоВСтрокуДляURL(знач ПараметрЧисло) Экспорт
	
	Если ТипЗнч(ПараметрЧисло) = Тип("Строка") Тогда
		Попытка
			ПараметрЧисло = Число(ПараметрЧисло);
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Если ТипЗнч(ПараметрЧисло) <> Тип("Число") Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат Формат(ПараметрЧисло, "ЧРД=.; ЧН=0; ЧГ=0");

КонецФункции

#КонецОбласти

#Область Эксель

// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ КОНВЕРТАЦИИ XLS в MXL с сохранением форматирования

// Допустимые типы 
// adDouble = 5 Значение с плавающей точкой двойной точности 
// adDAte = 7 Дата 
// adCurrency = 6 Денежная сумма 
// adBoolean = 11 Булево 
// adVarWChar = 202 Символьная строка Unicode, заканчивающаяся NULL 
// adLongVarWChar = 203 Длинное строковое значение

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент И Не МобильноеПриложениеСервер Тогда
// Процедура конвертации XLS-->MXL с форматированием. Из семерки. Требует допиливания напильником.
Функция Эксель_КонвертироватьВMXL(ПолнИмя,Лист,R1=0,C1=0,R2=0,C2=0,КоэффШирина = 1, КоэффВысота = 1,КоэффШрифт = 1) Экспорт
	
	СпОбъединенных = Новый СписокЗначений; 
	СпИгнорируемых = Новый СписокЗначений; 
	Таб = Новый ТабличныйДокумент;
	
	ИмяФайла=СокрЛП(ПолнИмя); // файл Excel
	
	Excel = Новый COMОбъект("Excel.Application");
	Excel.Visible       = Ложь;
	Excel.DisplayAlerts = Ложь;
	
	Попытка
		РабочаяКнига = Excel.Workbooks.Open(ПолнИмя, , Истина);
	Исключение
		СообщитьОбОшибке("Не удалось открыть файл "+ИмяФайла);
		Возврат Неопределено;
	КонецПопытки; 
	
	//Проверим чтобы был указанный в параметрах лист
	КоличествоЛистовВXLS =  РабочаяКнига.Sheets.Count;
	Если Лист > КоличествоЛистовВXLS 
		ИЛИ Лист < 1 Тогда
		СообщитьОбОшибке("В файле " + ИмяФайла+" нет листа с номером " + Лист);
		Возврат Неопределено;
	КонецЕсли;
	
	РабочаяКнига.Sheets(Лист).Select();
	ФлЗащита = 0;
	Попытка 
		МаксРяд = РабочаяКнига.Sheets(Лист).Cells().SpecialCells(11).Row; 
		МаксКолонка = РабочаяКнига.Sheets(Лист).Cells().SpecialCells(11).Column;
	Исключение
		ФлЗащита = 1;
	КонецПопытки; 	
	
	Если (R1=0) и (R2=0) и (C1=0) и (C2=0) Тогда // автоопределение параметров
		Если ФлЗащита =1 Тогда
			Сообщить(ПолнИмя+"!"+Лист+"Нельзя автоматически определить размеры листа при включенной защите листа!"); 
			Возврат Неопределено;
		Иначе	  
			R1 = ?(R1=0,1,R1);
			R2 = Мин(МаксРяд,?(R2=0,МаксРяд,R2));  
			
			C1 = ?(C1=0,1,C1);
			C2 = Мин(МаксКолонка,?(C2=0,МаксКолонка,C2));  
		КонецЕсли;  
	Иначе
		// по возможности постараемся уменьшить диапазон
		Если ФлЗащита=1 Тогда
			R1 = ?(R1=0,1,R1);
			R2 = Макс(R1,R2);  
			C1 = ?(C1=0,1,C1);
			C2 = Макс(C1,C2);  
		Иначе    
			R1 = ?(R1=0,1,R1);
			R2 = Мин(МаксРяд,?(R2=0,МаксРяд,R2));  
			
			C1 = ?(C1=0,1,C1);
			C2 = Мин(МаксКолонка,?(C2=0,МаксКолонка,C2));  
		КонецЕсли;
	КонецЕсли;
	
	ЧислоРядов=R2-R1+1;
	ЧислоКолонок=C2-C1+1;
	
	ВсегоЯчеек = ЧислоРядов*ЧислоКолонок;
	
	Если (ЧислоРядов<1) или (ЧислоКолонок<1) Тогда
		Сообщить(ИмяФайла+": Неправильно указан диапазон для конвертации формы","!"); 
		Возврат Неопределено;
	КонецЕсли;
	
	
	Сдвиг=0; Сдвиг1=0;  Адрес="";
	
	//**********************************************
	// установка ширины столбцов по образцу таблицы
	Для Столб=C1 по C2 Цикл
		Ячейка=Excel.Cells(1,Столб);
		Ширина=Ячейка.ColumnWidth();
		Адрес="R1C"+Формат(Столб-Сдвиг,"ЧГ=0");
		
		Если Ячейка.EntireColumn.Hidden()=0 Тогда
			ВыбОбласть=	Таб.Область(Адрес);
			ВыбОбласть.ШиринаКолонки = Ширина*КоэффШирина;
		Иначе
			Сдвиг=Сдвиг+1;
		КонецЕсли;
	КонецЦикла;
	
	//установка высоты строк по образцу таблицы
	Для Стр=R1 по R2 Цикл
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли
		Ячейка=Excel.Cells(Стр,1);
		Высота=Ячейка.RowHeight();
		Адрес="R"+Формат(Стр-Сдвиг1,"ЧГ=0")+"C1";
		Если Ячейка.EntireRow.Hidden()=0 Тогда
			ВыбОбласть=	Таб.Область(Адрес);
			ВыбОбласть.ВысотаСтроки=Высота*КоэффВысота;
		Иначе
			Сдвиг1=Сдвиг1+1;
		КонецЕсли;
	КонецЦикла;
	
	//**********************************************
	//перенос значений и форматирования ячеек
	Сдвиг=0;
	Для Стр=R1 по R2 Цикл // по строкам
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли
		
		Ячейка=Excel.Cells(Стр,1);
		Если Ячейка.EntireRow.Hidden()=0 Тогда
			Сдвиг1=0;
			Для Столб=C1 по C2 Цикл
				#Если Клиент Тогда
				ОбработкаПрерыванияПользователя();
				ОбработаноЯчеек = (Стр - R1)*ЧислоКолонок+(Столб - C1);
				Процент = Окр((ОбработаноЯчеек/ВсегоЯчеек)*100,2,1);
				Состояние(ПолнИмя+"!"+Лист+" ~ "+Процент+"%");
				#КонецЕсли
				
				Ячейка=Excel.Cells(Стр,Столб);
				Если Ячейка.EntireColumn.Hidden()=0 Тогда
					Excel.Range(Ячейка,Ячейка).Select();
					СтрокВВыделенном = Excel.Selection.Rows.Count;
					СтолбцовВВыделенном= Excel.Selection.Columns.Count;
					
					НачАдр="R"+Стр+"C"+Столб;
					
					Если ((СтрокВвыделенном>1) или (СтолбцовВВыделенном>1)) и (СпИгнорируемых.НайтиПоЗначению(НачАдр)=Неопределено) Тогда
						
						СкрытоСтолбцов=0;
						Для счСтолб=Столб по (Столб+СтолбцовВВыделенном-1) Цикл
							Ячейка=Excel.Cells(1,счСтолб);
							Если Ячейка.EntireColumn.Hidden()<>0 Тогда
								СкрытоСтолбцов=СкрытоСтолбцов+1;
							КонецЕсли;	 
						КонецЦикла;	
						
						СкрытоСтрок=0;
						Для счСтрок=Стр по (Стр+СтрокВВыделенном-1) Цикл
							Ячейка=Excel.Cells(счСтрок,1);
							Если Ячейка.EntireRow.Hidden()<>0 Тогда
								СкрытоСтрок=СкрытоСтрок+1;
							КонецЕсли;	 
						КонецЦикла;	
						
						// это объединенный диапазон - крайняя левая верхняя ячейка
						КонСтр=Стр+СтрокВВыделенном-1-СкрытоСтрок;
						КонСтолб=Столб+СтолбцовВВыделенном-1-СкрытоСтолбцов;
						
						Диап="R"+Стр+"C"+Столб+":R"+КонСтр+"C"+КонСтолб;
						
						Если СпОбъединенных.НайтиПоЗначению(Диап)=Неопределено Тогда
							СпОбъединенных.Добавить(Диап);
						КонецЕсли;
						
						Для счСтрОбъед=1 по СтрокВВыделенном Цикл
							Для счСтолбОбъед=1 по СтолбцовВВыделенном Цикл
								ИгнорСтр=СокрЛП(Строка(Стр+счСтрОбъед-1));
								ИгнорСтолб=СокрЛП(Строка(Столб+счСтолбОбъед-1));
								Игнор="R"+ИгнорСтр+"C"+ИгнорСтолб;
								СпИгнорируемых.Добавить(Игнор)
							КонецЦикла;	
						КонецЦикла;	
					КонецЕсли; // обработка объединенных ячеек
					
					Адрес="R"+Формат(Стр-Сдвиг,"ЧГ=0")+"C"+Формат(Столб-Сдвиг1,"ЧГ=0");
					ВыбОбласть=Таб.Область(Адрес);
					
					//перенос значений ячеек
					ЗначениеЯчейки = Ячейка.Value;
					Если ТипЗнч(ЗначениеЯчейки) <> Тип("Число") Тогда
						ЗначениеЯчейки = СокрЛП(ЗначениеЯчейки);
					КонецЕсли;
					
					Если ЗначениеЗаполнено(ЗначениеЯчейки) Тогда
						ВыбОбласть.Текст=ЗначениеЯчейки;   
					КонецЕсли;
					
					// Шрифт ячейки
					Попытка
						Фонт = Ячейка.Font; 
						ВыбОбласть.Шрифт 
							= Новый Шрифт
								(
								ВыбОбласть.Шрифт,
								Фонт.Name(), 						// Имя шрифта
								Фонт.Size()*КоэффШрифт,				// Размер шрифта
								Фонт.Bold(),						// Признак полужирного шрифта
								Фонт.Italic(),						// Признак курсива
								?(Фонт.Underline()=2,Истина,Ложь)	// Признак подчеркнутого шрифта	
								);
					Исключение
					КонецПопытки;
							
					// Цвет Ячейки
					ВыбОбласть.ЦветТекста = Эксель_ПолучитьЦветВФормате1С(Фонт.Color);  	  
						
					// Выравнивание внутри ячейки
					Горизонтальное = Ячейка.HorizontalAlignment();
					Если Горизонтальное=-4108 Тогда  //центр
						ВыбОбласть.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Центр; 
					ИначеЕсли Горизонтальное=-4131  Тогда //лево
						ВыбОбласть.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Лево; 
					ИначеЕсли Горизонтальное=1  Тогда    //по значению 
						Если ТипЗнч(ЗначениеЯчейки) <> Тип("Число") Тогда
							ВыбОбласть.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Лево;
						Иначе
							ВыбОбласть.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
						КонецЕсли;
					ИначеЕсли Горизонтальное=-4152  Тогда  //право
						ВыбОбласть.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право; 
					ИначеЕсли Горизонтальное=-4130  Тогда // по ширине
						ВыбОбласть.ГоризонтальноеПоложение = ГоризонтальноеПоложение.ПоШирине; 
					ИначеЕсли Горизонтальное= 7  Тогда  // по центру выделения
						ВыбОбласть.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Центр; 
					КонецЕсли;
						
					Вертикальное = Ячейка.VerticalAlignment();
					
					Если Вертикальное =-4107 Тогда 
						ВыбОбласть.ВертикальноеПоложение = ВертикальноеПоложение.Низ; 
					ИначеЕсли Вертикальное =-4160 Тогда 
						ВыбОбласть.ВертикальноеПоложение = ВертикальноеПоложение.Верх; 
					Иначе 
						ВыбОбласть.ВертикальноеПоложение = ВертикальноеПоложение.Центр; 
					КонецЕсли;
					
					// Перенос текста в ячейке
					Если Ячейка.WrapText()=1 Тогда 
						ВыбОбласть.РазмещениеТекста = ТипРазмещенияТекстаТабличногоДокумента.Переносить; 
					Иначе  
						ВыбОбласть.РазмещениеТекста = ТипРазмещенияТекстаТабличногоДокумента.Авто; 
					КонецЕсли;
					
					// Фон ячейки
					Фон = Ячейка.Interior.ColorIndex;
					Если Фон<>-4142 Тогда // по умолчанию
						ВыбОбласть.ЦветФона = Эксель_ПолучитьЦветВФормате1С(Ячейка.Interior.Color); //фон  
					КонецЕсли;
					
					// перенос ориентации - при условии достаточно высокого релиза
					//Если Ячейка.Orientation<>-4128 Тогда // ориентация по умолчанию - ничего не ставим
					//	ВыбОбласть.ОриентацияТекста = Ячейка.Orientation;
					//КонецЕсли;
					
					// Перенос рамок
					РамкаСлева 	= Ячейка.Borders(7);
					РамкаСверху	= Ячейка.Borders(8);
					РамкаСнизу 	= Ячейка.Borders(9);
					РамкаСправа = Ячейка.Borders(10);
					
					// Коды цветов рамок
					КодЦветаСлева	= Эксель_ПолучитьКодЦветаРамкиЯчейки(РамкаСлева);
					КодЦветаСверху	= Эксель_ПолучитьКодЦветаРамкиЯчейки(РамкаСверху);
					КодЦветаСнизу	= Эксель_ПолучитьКодЦветаРамкиЯчейки(РамкаСнизу);
					КодЦветаСправа	= Эксель_ПолучитьКодЦветаРамкиЯчейки(РамкаСправа);
					
					// Рамку слева переносим только для первого столбца
					Если 
						Столб = C1 Или КодЦветаСлева=КодЦветаСнизу Тогда
						ВыбОбласть.ГраницаСлева = Эксель_ВидРамки(РамкаСлева.LineStyle(),РамкаСлева.Weight());
					Иначе
						ВыбОбласть.ГраницаСлева = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.НетЛинии);
					КонецЕсли;
					
					// Рамку сверху переносим только для первой строки
					Если Стр = R1 Или КодЦветаСверху=КодЦветаСнизу Тогда
						ВыбОбласть.ГраницаСверху = Эксель_ВидРамки(РамкаСверху.LineStyle(),РамкаСверху.Weight());
					Иначе
						ВыбОбласть.ГраницаСверху = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.НетЛинии);
					КонецЕсли;
					
					ВыбОбласть.ГраницаСнизу = Эксель_ВидРамки(РамкаСнизу.LineStyle(),РамкаСнизу.Weight());
					ВыбОбласть.ГраницаСправа = Эксель_ВидРамки(РамкаСправа.LineStyle(),РамкаСправа.Weight());
					
					// Покрасим рамку 
					Если КодЦветаСнизу >0 Тогда
						ВыбОбласть.ЦветРамки = Эксель_ПолучитьЦветВФормате1С(КодЦветаСнизу);
					Иначе
						ВыбОбласть.ЦветРамки = ЦветаСтиля.ЦветРамки;
					КонецЕсли;
					
				Иначе // скрытый столбец
					Сдвиг1=Сдвиг1+1;
				КонецЕсли;
			КонецЦикла; // по столбцам
		Иначе //скрытая строка!
			Сдвиг=Сдвиг+1;
		КонецЕсли;
		
	КонецЦикла; // по строкам
	
	// Объединение ячеек
	Для Каждого Диап Из СпОбъединенных Цикл
		Обл=Таб.Область(Диап);
		Обл.Объединить();
	КонецЦикла;	
	
	Возврат Таб;
	
КонецФункции 
#КонецЕсли

Функция Эксель_ВидРамки(Стиль,Толщина)
	
	Если Стиль = -4142 Тогда //xlNone
		Возврат Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.НетЛинии);  
	КонецЕсли;	
	
	Если Стиль = -4115 Тогда // пунктир
		Если Толщина = 2 Тогда // тонкая
			Возврат Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Точечная);
		ИначеЕсли Толщина = -4138 Тогда // средняя	
			Возврат Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.РедкийПунктир);
		ИначеЕсли Толщина = 4 Тогда //жирная    
			Возврат Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.БольшойПунктир);
		КонецЕсли;
	КонецЕсли;
	
	Если Стиль = 1 Тогда // сплошная одинарная
		Если Толщина = 2 Тогда // тонкая
			Возврат Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная);
		ИначеЕсли Толщина = -4138 Тогда // средняя	
			Возврат Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная,2);
		ИначеЕсли Толщина = 4 Тогда //жирная    
			Возврат Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная,3);
		КонецЕсли;
	КонецЕсли;
	
	Если Стиль = -4119 Тогда // двойная
		Возврат Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Двойная);
	КонецЕсли;
	// для всех неохваченных основных случаев - тонкая сплошная
	Возврат Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная);
	
КонецФункции //ВидРАмки

Функция Эксель_ПолучитьКодЦветаРамкиЯчейки(РамкаXLS)
	
	Если РамкаXLS.ColorIndex()<>-4142 Тогда // Значение по умолчанию
		Возврат РамкаXLS.Color();
	Иначе
		Возврат РамкаXLS.ColorIndex();
	КонецЕсли; 
	
КонецФункции

Функция Эксель_ПолучитьЦветВФормате1С(КодЦвета = 0)
	
	Если КодЦвета = 0 Тогда
		Возврат Новый Цвет(0,0,0);
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(КодЦвета) Тогда
		Возврат Новый Цвет();
	КонецЕсли;
	
	Цвет1С = Новый Структура("Красный,Зеленый,Синий,КрасныйВес,ЗеленыйВес,СинийВес");
	Цвет1С.Синий = Цел(КодЦвета/65536);
	Цвет1С.СинийВес = Цвет1С.Синий*65536;
	Цвет1С.Зеленый = Цел((КодЦвета-Цвет1С.СинийВес)/256);
	Цвет1С.ЗеленыйВес = Цвет1С.Зеленый*256;
	Цвет1С.Красный = Цел(КодЦвета-Цвет1С.СинийВес-Цвет1С.ЗеленыйВес);
	//Цвет.КрасныйВес = Цвет.Красный;
	
	Возврат Новый Цвет(Цвет1С.Красный,Цвет1С.Зеленый,Цвет1С.Синий);
	
КонецФункции

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
//Функция для получения из файла .xls таблицы значенией
//Передаваемые параметры:
//	ПутьКФайлуXLS			-	Обязательный, Строка, путь к загружаемому файлу на диске;
//	НачальнаяСтрокаXLS	    -	Необязательный, Число, с этой строки файла начнется загрузка; 
//	НачальнаяКолонкаXLS		-   Необязательный, Число, с этой колонки файла начнется загрузка;
//	КонечнаяСтрокаXLS	 	-	Необязательный, Число, с этой строки файла закончится загрузка;
//	КонечнаяКолонкаXLS		-	Необязательный, Число, с этой колонки файла закончится загрузка;
//	Лист					-	Необязательный, Число, какую страницу файла грузить
//	ИндикаторЧтенияXLS		- 	Необязательный,	Число, управляет индикатором чтения файла на форме (если надо);
//Возвращает:
//  ТаблицаРезультат		-	Таблицу значений с данными из файла
Функция Эксель_СоздатьТаблицуЗначений (ПутьКФайлуXLS,Лист=1,НачальнаяСтрокаXLS=0,НачальнаяКолонкаXLS=0,КонечнаяСтрокаXLS=0,КонечнаяКолонкаXLS=0, ИндикаторЧтенияXLS = неопределено) Экспорт

	// Проверка существования файла
	Файл = Новый Файл(ПутьКФайлуXLS);
	Если Не Файл.Существует() Тогда
		Предупредить("Файла "+ПутьКФайлуXLS+" не существует");
		Возврат Неопределено;
	КонецЕсли;
	ИндикаторЧтенияXLS = 0;

	ТаблицаРезультат	= Новый ТаблицаЗначений;
	
	Если ПутьКФайлуXLS = "" Тогда
		Предупредить("Необходимо указать путь к файлу");
		Возврат Неопределено;
	КонецЕсли;
	
	// Попытаемся получить объект xls
	Попытка
		COMОбъектXLS	= ПолучитьCOMОбъект(ПутьКФайлуXLS);
	Исключение
	    Предупредить("Невозможно загрузить файл по указанному адресу: "+ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки;
	
	//Проверим чтобы был указанный в параметрах лист
	КоличествоЛистовВXLS =  COMОбъектXLS.Sheets.Count;
	Если Лист > КоличествоЛистовВXLS 
		ИЛИ Лист < 1 Тогда
		Предупредить("В файле нет листа с номером " + Лист + " !");
		Возврат Неопределено;
	КонецЕсли;
	
	
	// Вычислим количество использованных строк в документе на 1-й странице
	НомерСпецЯчейки			= 11; // храниться номер строки конца страницы и номер последней колонки
	КоличествоСтрокВXLS		= COMОбъектXLS.Sheets(Лист).Cells.SpecialCells(НомерСпецЯчейки).Row;
	КоличествоКолонокВXLS	= COMОбъектXLS.Sheets(Лист).Cells.SpecialCells(НомерСпецЯчейки).Column;
	
	Если (КоличествоСтрокВXLS > 0) И (КоличествоКолонокВXLS > 0) Тогда
		
		Если КоличествоСтрокВXLS < НачальнаяСтрокаXLS Тогда
			Предупредить("Значение начальной строки больше количества строк в XLS");
			Возврат Неопределено;
		КонецЕсли;
		Если КоличествоСтрокВXLS < КонечнаяСтрокаXLS Тогда
			Предупредить("Значение конечной строки больше количества строк в XLS");
			Возврат Неопределено;
		КонецЕсли;
		Если КоличествоКолонокВXLS < НачальнаяКолонкаXLS Тогда
			Предупредить("Значение начальной колонки больше количества колонок в XLS");
			Возврат Неопределено;
		КонецЕсли;
		Если КоличествоКолонокВXLS < КонечнаяКолонкаXLS Тогда
			Предупредить("Значение конечной колонки больше количества колонок в XLS");
			Возврат Неопределено;
		КонецЕсли;
		Если (КонечнаяСтрокаXLS <> 0) И (КонечнаяСтрокаXLS < НачальнаяСтрокаXLS) Тогда
			Предупредить("Значение конечной строки меньше начальной");
			Возврат Неопределено;
		КонецЕсли;
		Если (КонечнаяКолонкаXLS <> 0) И (КонечнаяКолонкаXLS < НачальнаяКолонкаXLS) Тогда
			Предупредить("Значение конечной колонки меньше начальной");
			Возврат Неопределено;
		КонецЕсли;
		
		Если НачальнаяСтрокаXLS	= 0 Тогда
			НачальнаяСтрокаXLS	= 1;
		КонецЕсли;
		Если НачальнаяКолонкаXLS	= 0 Тогда
			НачальнаяКолонкаXLS	= 1;
		КонецЕсли;
		Если КонечнаяСтрокаXLS	= 0 Тогда
			КонечнаяСтрокаXLS	= КоличествоСтрокВXLS;
		КонецЕсли;
		Если КонечнаяКолонкаXLS	= 0 Тогда
			КонечнаяКолонкаXLS	= КоличествоКолонокВXLS;
		КонецЕсли;
		
		// Исходя из настроек читаем xls файл в таблицу значений
		
		// Создаем колонки в таблице значений
		ТаблицаРезультат.Колонки.Добавить("N",,"№",5);
		ТаблицаРезультат.Колонки.Добавить("NXLS",,"№ XLS",5);
		
		СоответствиеКолонок		= Новый Соответствие;
		НомерВТаблицеРезультат	= 0;
		Для А = НачальнаяКолонкаXLS По КонечнаяКолонкаXLS Цикл
			НомерВТаблицеРезультат	= НомерВТаблицеРезультат + 1;
			ТаблицаРезультат.Колонки.Добавить("Колонка" + Строка (НомерВТаблицеРезультат));
			СоответствиеКолонок.Вставить(А,"Колонка" + Строка (НомерВТаблицеРезультат));
		КонецЦикла;
	
	
		// Цикл по строкам XLS
		
		НомерСтрокиВРезультате	= 1;
		
		Для НомерСтроки = НачальнаяСтрокаXLS По  КонечнаяСтрокаXLS Цикл
			
			НоваяСтрока	= ТаблицаРезультат.Добавить();
			НоваяСтрока["N"]		=  НомерСтрокиВРезультате;
			НоваяСтрока["NXLS"]		=  НомерСтроки;
			
			
			Для НомерКолонки = НачальнаяКолонкаXLS По КонечнаяКолонкаXLS Цикл
				
				// Получим значения из XLS
				НоваяСтрока[СоответствиеКолонок[НомерКолонки]]	
					= СокрЛП(COMОбъектXLS.Sheets(Лист).Cells(НомерСтроки,НомерКолонки).Value);
				
			КонецЦикла;
			
			НомерСтрокиВРезультате	= НомерСтрокиВРезультате + 1;
			
			ИндикаторЧтенияXLS	
				=  (НомерСтроки  * 100)/(КонечнаяСтрокаXLS - НачальнаяСтрокаXLS + 1)
		
		КонецЦикла;
		
	Иначе
		Сообщить ("В XLS нет значимых строк или колонок");
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		COMОбъектXLS.Close();
	Исключение
		Общ.СообщитьОбОшибке
				(
				"Не удалось закрыть файл XLS: " 
				+ ОписаниеОшибки()
				);
	КонецПопытки;
	COMОбъектXLS = Неопределено;
	
	ИндикаторЧтенияXLS	= 0;

	Возврат ТаблицаРезультат;
	
КонецФункции
#КонецЕсли

#КонецОбласти 
//Эксель

#Область ИнструментыРазработчика

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Процедура выполняет алгоритм из справочника "Алгоритмы" подсистемы
// инструменты разработчика. Процедура проектировалась в первую очередь для
// исопльзования при автоматической рассылке почты.
//
// Параметры:
//		ИмяАлгоритма - обязательный, строка. Имя алгоритма, который необходимо выполнить
Процедура ИР_ВыполнитьАлгоритм(ИмяАлгоритма) Экспорт
	
	Алгоритм = Справочники.ирАлгоритмы.НайтиПоНаименованию(ИмяАлгоритма);
	
	Если Не ЗначениеЗаполнено(Алгоритм) Тогда
		ВызватьИсключение "Не найден алгоритм """+ИмяАлгоритма+""".";
	КонецЕсли;
	
	Выполнить(Алгоритм.ТекстАлгоритма);
	
КонецПроцедуры
#КонецЕсли

#КонецОбласти
// ИнструментрыРазработчика

#Область ПодменаРабочегоСтола

&НаСервере
Процедура РабочийСтол_СоздатьКнопкиПереключенияПриСозданииФормы(Форма) Экспорт
	
	ПанельРабочиеСтолы = Форма.Элементы.Вставить("_ПанельРабочиеСтолы",Тип("ГруппаФормы"),,Форма.ПодчиненныеЭлементы[0]);
	ПанельРабочиеСтолы.Вид = ВидГруппыФормы.КоманднаяПанель;
	Для каждого ОбщаяФорма Из Метаданные.ОбщиеФормы Цикл
		Если Лев(ОбщаяФорма.Имя,11) = "РабочийСтол" Тогда
			ИмяРабочегоСтола = Сред(ОбщаяФорма.Имя,12);
			КомандаКнопки = Форма.Команды.Добавить("РабочийСтолПереключить"+ИмяРабочегоСтола);
			КомандаКнопки.Действие = "РабочийСтолПереключить";
			НоваяКнопка = Форма.Элементы.Добавить("_"+ИмяРабочегоСтола, Тип("КнопкаФормы"), ПанельРабочиеСтолы);
			НоваяКнопка.ИмяКоманды = "РабочийСтолПереключить"+ИмяРабочегоСтола;
			НоваяКнопка.Заголовок = ИмяРабочегоСтола;
			НоваяКнопка.Пометка = ?(Форма.Заголовок = ИмяРабочегоСтола,Истина,Ложь);
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Процедура РабочийСтол_Переключить(Форма,Команда) Экспорт

	ИмяРабочегоСтола = Сред(Команда.Имя,23);
	Если ИмяРабочегоСтола = Форма.Заголовок Тогда
		Возврат;
	КонецЕсли;
	
	Если Форма.Открыта() Тогда
		Форма.Закрыть();
	КонецЕсли; 
	
	ОкноДляВывода=Неопределено; Окна=ПолучитьОкна();
	Для Каждого Окно Из Окна Цикл
		Если Окно.Основное=Истина Тогда
			ОкноДляВывода = Окно;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	ОткрытьФорму("ОбщаяФорма.РабочийСтол"+ИмяРабочегоСтола,,,,ОкноДляВывода);

КонецПроцедуры // РабочийСтолПереключить

&НаКлиенте
Процедура РабочийСтол_ОткрытьФормуВРабочейОбласти(ИмяФормы) Экспорт
	ОкноДляВывода=Неопределено; Окна=ПолучитьОкна();
	Для Каждого Окно Из Окна Цикл
		Если Окно.Основное=Истина Тогда
			ОкноДляВывода = Окно;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	ОткрытьФорму(ИмяФормы,,,,ОкноДляВывода);
КонецПроцедуры

// Процедуры для добавления в модуль управляемой формы
//
//&НаКлиенте
//Процедура РабочийСтолПереключить(Команда)
//	Общ.РабочийСтол_Переключить(ЭтаФорма,Команда);
//КонецПроцедуры

//&НаСервере
//Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
//	Общ.РабочийСтол_СоздатьКнопкиПереключенияПриСозданииФормы(ЭтаФорма);
//КонецПроцедуры

#КонецОбласти 
//ПодменаРабочегоСтола

#Область ВводПоПодстроке
//
// Процедуры взяты из разработки 
// "[8.1] Ввод по подстроке (альтернативный, расширенный)" http://infostart.ru/public/88043/
// Автор исхдных процедур Люлюк Евгений http://infostart.ru/profile/39468/
//
# Если ТолстыйКлиентОбычноеПриложение Тогда
	
// Процедура обслуживает событие АвтоПодборТекста элемента управления ПолеВвода для подмены автопоиска по тексту.
//
// Параметры
//  Элемент - поле ввода
//  Текст - текст введенный в поле ввода Вид
//  ТекстАвтоПодбора - текст автоподбора в поле Вид
//  СтандартнаяОбработка - булево, флаг стандартной обработки события автоподбора
//  СтруктураПараметров - Структура параметров запроса, ключ - имя параметра, значение - значение параметра.
//  ТипСправочника - Тип, тип справочника автоподбора текста
//
Процедура ВводПоПодстроке_ЭлементУправления_АвтоПодборТекста(Элемент, Текст, ТекстАвтоПодбора, СтандартнаяОбработка) Экспорт	
	
	//Получим массив значений соответствующий введенному тексту
	РазмерСпискаПодходящихЗначений = 1;
	СписокПодходящихЗначений = ВводПоПодстроке_СписокЗначений_Получить(Элемент, Текст, РазмерСпискаПодходящихЗначений);
	
	Если СписокПодходящихЗначений.Количество() > 0 Тогда
		СтандартнаяОбработка = Ложь;
		ТекстАвтоПодбора = Строка(СписокПодходящихЗначений[0].Значение);
	КонецЕсли;
	
КонецПроцедуры

Процедура ВводПоПодстроке_ЭлементУправления_ОкончаниеВводаТекста(Форма, Элемент, Текст, Значение, СтандартнаяОбработка) Экспорт
	
	Проверка_Тип(Форма, Тип("Форма"));
	
	//Введен пустой текст ничего не делаем
	Если Текст = "" Тогда
		Возврат;
	КонецЕсли;

	//Запомним текущее значение (оно нам еще понадобится)
	ТекущееЗначение = Элемент.Значение;
	
	//Получим массив значений соответствующий введенному тексту
	ПодходящиеЗначения = ВводПоПодстроке_СписокЗначений_Получить(Элемент, Текст);
	
	Если ПодходящиеЗначения = Неопределено Тогда //Данный тип объектов не обрабатываем
		Возврат;
	КонецЕсли;
	
	//Будем все сами обрабатывать (Стандартная обработка не нужна)
	СтандартнаяОбработка = Ложь;
	
	КоличествоЗначенийДляВыбора = ПодходящиеЗначения.Количество();
	
	Если КоличествоЗначенийДляВыбора = 0 Тогда
		Значение = ВводПоПодстроке_Значение_ВыбратьИзФормыВыбора(Элемент, ТекущееЗначение);	
	ИначеЕсли КоличествоЗначенийДляВыбора = 1 Тогда
		//Подходит всего одно значение
		Значение = ПодходящиеЗначения[0].Значение;
	ИначеЕсли КоличествоЗначенийДляВыбора <= 50  Тогда
		//Значений в списке не более 50
		ШиринаСпискаВыбора = 0;
		Для Каждого ЭлементСписка Из ПодходящиеЗначения Цикл
			ШиринаСпискаВыбора = Макс(ШиринаСпискаВыбора, СтрДлина(ЭлементСписка.Представление));
		КонецЦикла;
		Если ШиринаСпискаВыбора > 0 Тогда
			Элемент.ШиринаСпискаВыбора = 1.4 * ШиринаСпискаВыбора;
		КонецЕсли;
		ЗначениеЭлементаСпискаЗначений = Форма.ВыбратьИзСписка(ПодходящиеЗначения, Элемент);
		Если ЗначениеЭлементаСпискаЗначений = Неопределено Тогда
			Значение = Неопределено;
		Иначе
			Значение = ЗначениеЭлементаСпискаЗначений.Значение;
		КонецЕсли;
	Иначе
		Значение = ВводПоПодстроке_Значение_ВыбратьИзФормыВыбора(Элемент, ТекущееЗначение, ПодходящиеЗначения);	
	КонецЕсли;
	
	Если Значение = Неопределено Тогда
		Значение = ТекущееЗначение;
	КонецЕсли;

КонецПроцедуры

Функция ВводПоПодстроке_Значение_ВыбратьИзФормыВыбора(Элемент, ТекущееЗначение, СписокЗначенийДляОтбора = Неопределено)
	
	//Пользователь ввел не найд. текст Открываем форму выбора
	НайденныйОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(ТекущееЗначение)); 
	Если Метаданные.Справочники.Содержит(НайденныйОбъектМетаданных) Тогда //Справочник 
		ФормаВыбора = Справочники[НайденныйОбъектМетаданных.Имя].ПолучитьФормуВыбора(,Элемент,""); 
	ИначеЕсли Метаданные.Документы.Содержит(НайденныйОбъектМетаданных) Тогда //Документ 
		ФормаВыбора = Документы[НайденныйОбъектМетаданных.Имя].ПолучитьФормуВыбора(,Элемент,""); 
	КонецЕсли;	
	
	// Если передан список значений для отбора, прменим его
	Если Не СписокЗначенийДляОтбора = Неопределено Тогда
		ФормаВыбора.Отбор.Ссылка.ВидСравнения = ВидСравнения.ВСписке;
		ФормаВыбора.Отбор.Ссылка.Значение = СписокЗначенийДляОтбора;
		ФормаВыбора.Отбор.Ссылка.Использование = Истина;
	КонецЕсли;
	
	// Установить отбор по владельцу, если необходимо
	Если ЗначениеЗаполнено(Элемент.ВыборПоВладельцу) Тогда
		ФормаВыбора.ПараметрВыборПоВладельцу = Элемент.ВыборПоВладельцу;
		ФормаВыбора.ПараметрОтборПоВладельцу = Элемент.ВыборПоВладельцу;
	КонецЕсли;
	
	// Попытаться снять иерархический просмотр с формы выбора
	ЭлементУправленияОсновногоРеквизитаФормыВыбора = Общ.Форма_ЭлементУправленияОсновногоРеквизита_Получить(ФормаВыбора);
	Если Не ЭлементУправленияОсновногоРеквизитаФормыВыбора = Неопределено Тогда
		Попытка ЭлементУправленияОсновногоРеквизитаФормыВыбора.ИерархическийПросмотр = Ложь;
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	ВыбранноеЗначение = ФормаВыбора.ОткрытьМодально();
	Возврат ?(ВыбранноеЗначение = Неопределено, ТекущееЗначение, ВыбранноеЗначение);
	
КонецФункции
	
// Функция ищет подходящие значения для текста, введенного в элементе управления
// 
// Возвращает СписокЗначений
//
Функция ВводПоПодстроке_СписокЗначений_Получить(Элемент, Текст, РазмерСписка = 51)
	
	Проверка_Тип(Элемент, Тип("ПолеВвода"));
	Проверка_Тип(Текст,  Тип("Строка"));
	Проверка_Тип(РазмерСписка, Тип("Число"));

	НайденныйОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(Элемент.Значение));
	
	Если НайденныйОбъектМетаданных = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если НайденныйОбъектМетаданных.ВводПоСтроке.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ ПЕРВЫЕ %РазмерСписка%
	|ТаблицаПоиска.Ссылка КАК Значение%ДополнительныеПоля%
	| ИЗ " + НайденныйОбъектМетаданных.ПолноеИмя() + " КАК ТаблицаПоиска
	| ГДЕ %Условия%";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "%РазмерСписка%", Строка(РазмерСписка));
	
	Если Метаданные.Справочники.Содержит(НайденныйОбъектМетаданных) Тогда //Справочник
		ДополнительныеПоля = ",ТаблицаПоиска.Код, ТаблицаПоиска.ПометкаУдаления, ТаблицаПоиска.Предопределенный";
		Условия = ВводПоПодстроке_СформироватьТекстУсловийДляЗапроса(НайденныйОбъектМетаданных);
	ИначеЕсли Метаданные.Документы.Содержит(НайденныйОбъектМетаданных) Тогда //Документ
		ДополнительныеПоля = ",ТаблицаПоиска.Номер, ТаблицаПоиска.ПометкаУдаления, ТаблицаПоиска.Проведен";
		Условия = ВводПоПодстроке_СформироватьТекстУсловийДляЗапроса(НайденныйОбъектМетаданных);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Элемент.ВыборПоВладельцу) Тогда
		Условия
		= "ТаблицаПоиска.Владелец = &Владелец"
		+ ?(Не ПустаяСтрока(Условия), " И " + Условия, "")
		;
		Запрос.УстановитьПараметр("Владелец", Элемент.ВыборПоВладельцу);
	КонецЕсли;
	
	//Подготавливаем текст запроса заполняем шаблон
	Запрос.Текст = СтрЗаменить(Запрос.Текст,"%ДополнительныеПоля%", ДополнительныеПоля);
	Запрос.Текст = СтрЗаменить(Запрос.Текст,"%Условия%", Условия);
	
	ИщемТекст = Текст;
	ИщемТекст = СтрЗаменить(ИщемТекст, "%", Символ(255) + "%");
	
	Запрос.УстановитьПараметр("СтрокаПоиска", "%" + ИщемТекст + "%");
	Результат = Запрос.Выполнить();
	
	СЗ = Новый СписокЗначений;
	Для Каждого Строка Из Результат.Выгрузить() Цикл
		ВводПоПодстоке_СписокЗначений_ДобавитьЭлемент(СЗ, Строка, НайденныйОбъектМетаданных);
	КонецЦикла;
	
	Возврат СЗ;
	
КонецФункции

Процедура ВводПоПодстоке_СписокЗначений_ДобавитьЭлемент(СЗ, Строка, НайденныйОбъектМетаданных)
	
	Если Метаданные.Справочники.Содержит(НайденныйОбъектМетаданных) Тогда //Справочник
		
		Представление = "("+СокрЛП(Строка.Код)+") " + Строка.Значение;
		
		Если Строка.ПометкаУдаления Тогда
			Картинка = БиблиотекаКартинок.ПометитьНаУдаление;
		Иначе
			Картинка = БиблиотекаКартинок.Справочник;
		КонецЕсли;
		
	ИначеЕсли Метаданные.Документы.Содержит(НайденныйОбъектМетаданных) Тогда //Документ
		
		Представление = Неопределено;
		
		Если Строка.Проведен Тогда 
			Картинка = БиблиотекаКартинок.СинтаксическийКонтроль;
		ИначеЕсли Строка.ПометкаУдаления Тогда
			Картинка = БиблиотекаКартинок.ПометитьНаУдаление
		Иначе
			Картинка = БиблиотекаКартинок.Документ
		КонецЕсли;
		
	КонецЕсли;
	
	СЗ.Добавить(Строка.Значение, Представление,, Картинка);
	
КонецПроцедуры	

Функция ВводПоПодстроке_СформироватьТекстУсловийДляЗапроса(ОбъектМетаданных)
	
	Текст = "";
	
	Для Каждого Поле Из ОбъектМетаданных.ВводПоСтроке Цикл
		
		Если Не ПустаяСтрока(Текст) Тогда
			Текст = Текст + " ИЛИ ";
		КонецЕсли;
		
		Текст = Текст + "ТаблицаПоиска." + Поле.Имя + " ПОДОБНО &СтрокаПоиска СПЕЦСИМВОЛ """+Символ(255)+"""";
	КонецЦикла;
	
	Возврат Текст;
	
КонецФункции

#КонецЕсли 
//ТолстыйКлиентОбычноеПриложение

#КонецОбласти 
//ВВОД ПО ПОДСТРОКЕ

#Область Проверки


// Процедура - Не реализовано
// Как разработчик
// Я вызываю эту процедуры
// Чтобы пометить места в коде, которые я еще не реализовал
//
Процедура НеРеализовано() Экспорт
	
	ВызватьИсключение "Не реализовано";
	
КонецПроцедуры

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Функция проверяет есть ли у переданного объекта необходимое свойство.
// Если свойство отсутствует, вызывается исключение
//
// Параметры:
//  Объект  - Произвольный - Объект, у которого необходимо проверить наличие и значение свойства
//  ИмяСвойства - Строка - Имя свойства, которое необходимо проверить
//  ПроверяемыйТип — Тип — Тип, которому должно соответствовать проверяемое свойство
//  ВызыватьИсключение — Булево — Если истина и проверка не прошла, будет вызвано исключение.
//						Если лож и проверка не прошла — будет возвращен код ошибки
//
// Возвращаемое значение:
//   Строка   - описание ошибки при проверке
//				Если ошибки не было, то пустая строка
Функция Проверка_ЕстьСвойство(Объект,ИмяСвойства,ПроверяемыйТип = Неопределено, ПроверятьЗаполенность = Истина, Вызывать_Исключение = Истина) Экспорт

	Ошибка_Описание = "";
	
	// Пока обрабатываем только структуры
	Если ЗначениеЗаполнено(Проверка_Тип(Объект, Тип("Структура"))) Тогда
		ВызватьИсключение "Функция Проверка_ЕстьСвойство работает только с объектами типа ""Структура"". Обратитесь к разработчику";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПроверяемыйТип) Тогда
		Проверка_Тип(ПроверяемыйТип,Тип("Тип"));
	КонецЕсли;
		
	Если Не Объект.Свойство(ИмяСвойства) Тогда
		Ошибка_Описание = СтрШаблон("У объекта %1 нет свойства %2",Объект,ИмяСвойства);
		
	ИначеЕсли ТипЗнч(ПроверяемыйТип) = Тип("Тип") И  ТипЗнч(Объект[ИмяСвойства]) <> ПроверяемыйТип Тогда
		Ошибка_Описание = СтрШаблон("У объекта %1 свойство %2 не соответствует типу %3",Объект,ИмяСвойства,ПроверяемыйТип);

	ИначеЕсли ПроверятьЗаполенность И Не ЗначениеЗаполнено(Объект[ИмяСвойства]) Тогда
		Ошибка_Описание = СтрШаблон("У объекта %1 не заполнено свойство %2",Объект,ИмяСвойства);
		
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Ошибка_Описание) Тогда 
		Возврат "";
	КонецЕсли;
	
	Если Вызывать_Исключение Тогда
		Ошибка_Описание = 	
			Ошибка_Описание+"
			|Обратитесь к разработчику.";
		ВызватьИсключение Ошибка_Описание;
	Иначе
		Возврат Ошибка_Описание;
	КонецЕсли;
	
КонецФункции
#КонецЕсли

// Функция проверяет тип объекта
// Если тип не соответсвует вызывается исключение, или возвращается сообщение об ошибке.
Функция Проверка_Тип(парамОбъект, Знач ПроверяемыйТип, Вызвать_Исключение = Истина) Экспорт
	
	// ПРОВЕРКА ВХОДНЫХ ПАРАМЕТРОВ
	Если 
			Не ТипЗнч(ПроверяемыйТип) = Тип("Строка")
		И 	Не ТипЗнч(ПроверяемыйТип) = Тип("Тип") 
		И 	Не ТипЗнч(ПроверяемыйТип) = Тип("ОписаниеТипов")
	Тогда
		ВызватьИсключение 
			СтрШаблон(
				"Неверный тип параметра #2 '%1'. Параметр может иметь тип 'Строка', 'Тип' или 'ОписаниеТипов'",
				Тип_ПолучитьСтроковоеПредставление(ПроверяемыйТип)
				);
	КонецЕсли;

	// Обработка массива переменных
	Если 	ТипЗнч(парамОбъект) = Тип("Массив") 
		И	Не ПроверяемыйТип = "Массив"
		И	Не ПроверяемыйТип = Тип("Массив")
		И 	Не (ПроверяемыйТип = Тип("ОписаниеТипов") И ПроверяемыйТип.СодержитТип(Тип("Массив")))
	Тогда
		МассивОбъектов = парамОбъект;	
		
	Иначе
		МассивОбъектов = Новый Массив;
		МассивОбъектов.Добавить(парамОбъект);
		
	КонецЕсли;
	
	// ОСНОВНОЙ АЛГОРИТМ
	Ошибка_Описание = "";
	
	ДопустимТипНеопределено = Ложь;
	
	// Если Тип для проверки — строка. Тогда преобразовать его к описанию типов
	Если ТипЗнч(ПроверяемыйТип) = Тип("Строка") Тогда
		
		Попытка
			МассивИменТипов = СтрРазделить(ВРЕГ(ПроверяемыйТип), ",", Ложь);
			МассивТипов = Новый Массив;
			Для Каждого ИмяТипа Из МассивИменТипов Цикл
				ИмяТипа = СокрЛП(ИмяТипа);
				Если ИмяТипа = "НЕОПРЕДЕЛЕНО" Тогда
					ДопустимТипНеопределено = Истина;
				КонецЕсли;
				МассивТипов.Добавить(Тип(ИмяТипа));
				
			КонецЦикла;
			ИмяТипа = Неопределено;
			ПроверяемыйТип = Новый ОписаниеТипов(МассивТипов);
			
		Исключение
			ВызватьИсключение 
				СтрШаблон(
					"Неверное значение параметра #2. Тип '%1' не существует
					|%2",
					Строка(ПроверяемыйТип),
					ОписаниеОшибки()
					);
		КонецПопытки;
		
	КонецЕсли;
	
	Для Каждого ПроверяемыйОбъект Из МассивОбъектов Цикл
		
		Если ПроверяемыйОбъект = Неопределено И ДопустимТипНеопределено Тогда
			// ОК	
		
		ИначеЕсли  
			// Описание типов не содержит тип переданного объекта
			(ТипЗнч(ПроверяемыйТип) = Тип("ОписаниеТипов") И Не ПроверяемыйТип.СодержитТип(ТипЗнч(ПроверяемыйОбъект)))
			// И объект не соответствует переданному типу
			ИЛИ (ТипЗнч(ПроверяемыйТип) = Тип("Тип") И Не ТипЗнч(ПроверяемыйОбъект) = ПроверяемыйТип)
		Тогда
	
			Если ТипЗнч(ПроверяемыйТип) = Тип("ОписаниеТипов") Тогда
				ОписаниеПроверяемогоТипа  = "";
				Для Каждого Тип Из ПроверяемыйТип.Типы() Цикл
					ОписаниеПроверяемогоТипа = ОписаниеПроверяемогоТипа + Тип_ПолучитьСтроковоеПредставление(Тип) +Символы.ПС;
				КонецЦикла;
				ОписаниеПроверяемогоТипа = СокрЛП(ОписаниеПроверяемогоТипа);
			ИначеЕсли ТипЗнч(ПроверяемыйТип) = Тип("Тип") Тогда
				ОписаниеПроверяемогоТипа = Тип_ПолучитьСтроковоеПредставление(ПроверяемыйТип);
			Иначе
				ОписаниеПроверяемогоТипа = "";
			КонецЕсли;
			Ошибка_Описание = 
				СтрШаблон(
					"Тип параметра ""%1"" не соответствует типу ""%2""%3. 
					|Параметр ""%1"" имеет тип ""%4""",
					ПроверяемыйОбъект, // %1 
					ОписаниеПроверяемогоТипа, //%2
					?(ДопустимТипНеопределено, " или ""Неопределено""", ""), // %3
					Тип_ПолучитьСтроковоеПредставление(ТипЗнч(ПроверяемыйОбъект)) // %4
					);

		КонецЕсли;

	КонецЦикла;
	ПроверяемыйОбъект = Неопределено;
		
	Если Не ЗначениеЗаполнено(Ошибка_Описание) Тогда 
		Возврат "";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Ошибка_Описание) И Вызвать_Исключение Тогда
		Ошибка_Описание = 	
			Ошибка_Описание+"
			|Обратитесь к разработчику.";
		ВызватьИсключение 
			Ошибка_Описание;
	КонецЕсли;
		
	Возврат Ошибка_Описание;

КонецФункции

#КонецОбласти
// Проверки

#Область Отладка

#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
// Функция предназначена для просмотра данных временной таблицы во время отладки
// Код функции взять с http://infostart.ru/public/173803/
//
// Параметры:
//		МенеджерВремТаб - обязательный, менеджер временных таблиц
//		ИмяВремТаб - обязательый, строка, имя временной таблицы в менеджере
//		Порядок - необязательный, строка, имя колонки, по которой необходимо упорядочить полученный результат
//
// Возвращает: 
//		ТаблицаЗначений. Таблица значений содержит данные, содержащиеся во временной таблица
Функция Отладка_ПолучитьДанныеВТ(МенеджерВремТаб,ИмяВремтаб,Порядок = "") Экспорт
	
	Проверка_Тип(МенеджерВремТаб, Тип("МенеджерВременныхТаблиц"));
	Проверка_Тип(ИмяВремтаб, Тип("Строка"));
	Проверка_Тип(Порядок, Тип("Строка"));
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВремТаб;
	Запрос.Текст =
	"ВЫБРАТЬ
	| *
	|ИЗ
	| ВремТаб КАК ВремТаб
	|
	|УПОРЯДОЧИТЬ ПО Порядок";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст,"ВремТаб",ИмяВремтаб); 
	Если Порядок = "" тогда 
		Запрос.Текст = СтрЗаменить(Запрос.Текст,"УПОРЯДОЧИТЬ ПО Порядок","");
	Иначе 
		Запрос.Текст = СтрЗаменить(Запрос.Текст,"Порядок",Порядок);
	КонецЕсли; 
	
	ТЗ = Запрос.Выполнить().Выгрузить(); 
	
	Возврат ТЗ; 
	
КонецФункции
#КонецЕсли

#КонецОбласти 
//Отладка

#Область Устаревшие
// ЗАГЛУШКИ ПРОЦЕДУР И ФУНКЦИЙ, ДЛЯ СОВМЕСТИМОСТИ

#Если Не МобильноеПриложениеСервер Тогда
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	Возврат ИнформационнаяБаза_ПолучитьПредставление();	
КонецФункции
#КонецЕсли //  Не МобильноеПриложениеСервер

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
// Загдущка функции Менеджер_Получить, оставлена для совместимости
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт

	Возврат Менеджер_Получить(Ссылка);
	
КонецФункции 
#КонецЕсли

// Заглушка ОписаниеТиповСтроки_Получить, для совместимости
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт

	Возврат ОписаниеТиповСтроки_Получить(ДлинаСтроки);

КонецФункции // ПолучитьОписаниеТиповСтроки()

// Заглушка Тип_ПолучитьПустоеЗначение, для совместимости
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Возврат Тип_ПолучитьПустоеЗначение(ЗаданныйТип);
	
КонецФункции // ПустоеЗначениеТипа();

//Функция предназначена для сборки частей  из массива в один табличный документ.
//Параметры
//		МассивЧастейтТабДок - Обязательный, масиив данных типа "ТабличныйДокумент"
//		ТабДокумент - 	Необязательный, табличный документ к которому следует присоеденить части из массива
//						Если этот параметр не определен, будет создан новый табличный документ
//Возвращает
//		ТабДокумент - Табличный документ состоящий из частей содержащихся в массиве
Функция ПечатныеФормы_ПрисоеденитьКТабличномуДокументуМассив(МассивЧастейтТабДок,ТабДокумент = Неопределено) Экспорт
	
	ТабличныйДокумент_ПрисоеденитьМассив(МассивЧастейтТабДок, ТабДокумент);
	
КонецФункции

// Функция устарела, т.к. есть функция глобального контекста СтрШаблон
// Подставляет параметры в строку. Максимально возможное число параметров - 9.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров
// начинается с единицы.
//
// Параметры
//  СтрокаПодстановки  – Строка – шаблон строки с параметрами (вхождениями вида "%ИмяПараметра").
// Параметр<n>         - Строка - параметр
// Возвращаемое значение:
//   Строка   – текстовая строка с подставленными параметрами
//
// Пример:
// Строка = Строка_ПодставитьПараметры(НСтр("ru='%1 пошел в %2'"), "Вася", "Зоопарк");
//
// 20110723 Взято из БСП
Функция Строка_ПодставитьПараметры( Знач СтрокаПодстановки,
									Знач Параметр1 = Неопределено,
									Знач Параметр2 = Неопределено,
									Знач Параметр3 = Неопределено,
									Знач Параметр4 = Неопределено,
									Знач Параметр5 = Неопределено,
									Знач Параметр6 = Неопределено,
									Знач Параметр7 = Неопределено,
									Знач Параметр8 = Неопределено,
									Знач Параметр9 = Неопределено) Экспорт
	
	Если СтрокаПодстановки = Неопределено ИЛИ СтрДлина(СтрокаПодстановки) = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Результат = "";
	НачПозиция = 1;
	Позиция = 1;
	Пока Позиция <= СтрДлина(СтрокаПодстановки) Цикл
		СимволСтроки = Сред(СтрокаПодстановки, Позиция, 1);
		Если СимволСтроки <> "%" Тогда
			Позиция = Позиция + 1;
			Продолжить;
		КонецЕсли;
		Результат = Результат + Сред(СтрокаПодстановки, НачПозиция, Позиция - НачПозиция);
		Позиция = Позиция + 1;
		СимволСтроки = Сред(СтрокаПодстановки, Позиция, 1);
		
		Если СимволСтроки = "%" Тогда
			Позиция = Позиция + 1;
			НачПозиция = Позиция;
			Продолжить;
		КонецЕсли;
		
		Попытка
			НомерПараметра = Число(СимволСтроки);
		Исключение
			ВызватьИсключение НСтр("ru='Входная строка СтрокаПодстановки имеет неверный формат: %'" + СимволСтроки);
		КонецПопытки;
		
		Если СимволСтроки = "1" Тогда
			ЗначениеПараметра = Параметр1;
		ИначеЕсли СимволСтроки = "2" Тогда
			ЗначениеПараметра = Параметр2;
		ИначеЕсли СимволСтроки = "3" Тогда
			ЗначениеПараметра = Параметр3;
		ИначеЕсли СимволСтроки = "4" Тогда
			ЗначениеПараметра = Параметр4;
		ИначеЕсли СимволСтроки = "5" Тогда
			ЗначениеПараметра = Параметр5;
		ИначеЕсли СимволСтроки = "6" Тогда
			ЗначениеПараметра = Параметр6;
		ИначеЕсли СимволСтроки = "7" Тогда
			ЗначениеПараметра = Параметр7;
		ИначеЕсли СимволСтроки = "8" Тогда
			ЗначениеПараметра = Параметр8;
		ИначеЕсли СимволСтроки = "9" Тогда
			ЗначениеПараметра = Параметр9;
		Иначе
			ВызватьИсключение НСтр("ru='Входная строка СтрокаПодстановки имеет неверный формат: %'" + ЗначениеПараметра);
		КонецЕсли;
		Если ЗначениеПараметра = Неопределено Тогда
			ЗначениеПараметра = "";
	a	Иначе
			Попытка
				ЗначениеПараметра = Строка(ЗначениеПараметра);
			Исключение
				ЗначениеПараметра = Строка(ТипЗнч(ЗначениеПараметра));
			КонецПопытки;
		КонецЕсли;
		Результат = Результат + ЗначениеПараметра;
		Позиция = Позиция + 1;
		НачПозиция = Позиция;
	
	КонецЦикла;
	
	Если (НачПозиция <= СтрДлина(СтрокаПодстановки)) Тогда
		Результат = Результат + Сред(СтрокаПодстановки, НачПозиция, СтрДлина(СтрокаПодстановки) - НачПозиция + 1);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция Строка_СоеденитьСтрокиЧерезРазделитель(стр1,стр2,стрРазделитель = Неопределено) Экспорт
	
	Возврат Строка_СоединитьСтрокиЧерезРазделитель(стр1, стр2, стрРазделитель);
	
КонецФункции

#КонецОбласти 
// Устаревшие



